====================================
FILE: apps/client-tauri/src-tauri/Cargo.toml
====================================

[package]
name = "bf42lite"
version = "1.3.0"
description = "A simplified LAN multiplayer FPS"
authors = ["Pontus Falkman"]
edition = "2021"

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
serde = { version = "1", features = ["derive"] }
toml = "0.8"
serde_json = "1"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "time", "net"] }
futures-util = "0.3"
tokio-tungstenite = "0.21"
rmp-serde = "1"
tauri-plugin-shell = "2"
[features]
default = ["custom-protocol"]
custom-protocol = ["tauri/custom-protocol"]


====================================
FILE: apps/client-tauri/src-tauri/tauri.conf.json
====================================

{
  "$schema": "https://schema.tauri.app/config/2",

  "productName": "bf42lite",
  "version": "1.3.0",
  "identifier": "com.bf42lite.game",

  "build": {
    "beforeDevCommand": "pnpm run dev:web",
    "beforeBuildCommand": "pnpm run build:web",
    "frontendDist": "../dist",
    "devUrl": "http://localhost:5173"
  },

  "bundle": {
    "active": true,
    "category": "Game",
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "windows": {
      "digestAlgorithm": "sha256",
      "timestampUrl": ""
    },
    "macOS": {
      "entitlements": null,
      "exceptionDomain": "",
      "frameworks": [],
      "providerShortName": null,
      "signingIdentity": null
    },
    "linux": {
      "deb": {
        "depends": []
      }
    },
    "resources": [],
    "shortDescription": "",
    "longDescription": ""
  },

  "plugins": {},

  "app": {
    "withGlobalTauri": true,
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "bf42lite",
        "width": 1280,
        "height": 720,
        "useHttpsScheme": true
      }
    ],
    "security": {
      "csp": null
    }
  }
}


====================================
FILE: apps/client-tauri/src-tauri/game_config.toml
====================================

# game_config.toml

[movement]
move_speed = 6.0
gravity = -9.81
jump_force = 5.0
sprint_multiplier = 1.5
mouse_sensitivity = 0.1

[conquest]
# Tickets each team starts with
team_a_initial_tickets = 100
team_b_initial_tickets = 100

# Tickets lost per player death
tickets_per_death = 1

# Tickets per bleed tick when one team owns more flags
tickets_per_bleed = 1

# How often bleed is applied (in seconds of sim time)
bleed_interval_seconds = 5.0

# --- WEAPONS ---

[[weapons]]
id = 0
key = "ASSAULT_PRIMARY"
name = "Thompson"
damage_per_hit = 20.0
fire_rate = 0.12         # seconds between shots, matches client WEAPON_STATS for Assault
mag_size = 30
reserve_ammo = 120
recoil = 1.0

[[weapons]]
id = 1
key = "MEDIC_PRIMARY"
name = "MP40"
damage_per_hit = 18.0
fire_rate = 0.15         # seconds between shots, matches Medic
mag_size = 32
reserve_ammo = 128
recoil = 0.9

[[weapons]]
id = 2
key = "SCOUT_PRIMARY"
name = "Kar98k"
damage_per_hit = 80.0
fire_rate = 1.5          # seconds between shots, matches Scout bolt-action
mag_size = 5
reserve_ammo = 25
recoil = 2.0

# --- CLASSES ---

[[classes]]
id = 0
key = "ASSAULT"
name = "Assault"
max_health = 100.0
primary_weapon_id = 0

[[classes]]
id = 1
key = "MEDIC"
name = "Medic"
max_health = 110.0
primary_weapon_id = 1

[[classes]]
id = 2
key = "SCOUT"
name = "Scout"
max_health = 80.0
primary_weapon_id = 2


====================================
FILE: apps/client-tauri/src-tauri/weapons.json
====================================

[
  {
    "id": 0,
    "key": "ASSAULT_PRIMARY",
    "name": "Thompson",
    "damage_per_hit": 20.0,
    "fire_rate": 0.12,
    "mag_size": 30,
    "reserve_ammo": 120,
    "recoil": 1.0
  },
  {
    "id": 1,
    "key": "MEDIC_PRIMARY",
    "name": "MP40",
    "damage_per_hit": 18.0,
    "fire_rate": 0.15,
    "mag_size": 32,
    "reserve_ammo": 128,
    "recoil": 0.9
  },
  {
    "id": 2,
    "key": "SCOUT_PRIMARY",
    "name": "Kar98k",
    "damage_per_hit": 80.0,
    "fire_rate": 1.5,
    "mag_size": 5,
    "reserve_ammo": 25,
    "recoil": 2.0
  }
]


====================================
FILE: apps/client-tauri/src-tauri/classes.json
====================================

[
  {
    "id": 0,
    "key": "ASSAULT",
    "name": "Assault",
    "max_health": 100.0,
    "primary_weapon_id": 0
  },
  {
    "id": 1,
    "key": "MEDIC",
    "name": "Medic",
    "max_health": 110.0,
    "primary_weapon_id": 1
  },
  {
    "id": 2,
    "key": "SCOUT",
    "name": "Scout",
    "max_health": 80.0,
    "primary_weapon_id": 2
  }
]


====================================
FILE: apps/client-tauri/src-tauri/capabilities/default.json
====================================

{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "enables the default permissions",
  "windows": [
    "main"
  ],
  "permissions": [
    "core:default"
  ]
}


====================================
FILE: apps/client-tauri/src-tauri/capabilities/migrated.json
====================================

{
  "identifier": "migrated",
  "description": "permissions that were migrated from v1",
  "local": true,
  "windows": [
    "main"
  ],
  "permissions": [
    "core:default",
    "shell:allow-open"
  ]
}

====================================
FILE: apps/client-tauri/src-tauri/src/lib.rs
====================================

// apps/client-tauri/src-tauri/src/lib.rs

use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

mod sim;
mod network;
mod player;
mod protocol;
mod systems;
pub mod maps;
mod config;

use crate::sim::SimState;
use crate::protocol::ClientMessage;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    // Shared state between the sim loop and the websocket server
    let sim = Arc::new(Mutex::new(SimState::new()));
    let inputs = Arc::new(Mutex::new(HashMap::<u32, ClientMessage>::new()));

    tauri::Builder::default()
        .setup(move |_app| {
            // --- SIMULATION TICK LOOP (authoritative conquest logic) ---
            let sim_for_loop = sim.clone();
            let inputs_for_loop = inputs.clone();

            tauri::async_runtime::spawn(async move {
                use tokio::time::sleep;

                let mut last = Instant::now();

                // Simple fixed tick ~20 Hz
                loop {
                    let now = Instant::now();
                    let dt = now.duration_since(last).as_secs_f32();
                    last = now;

                    {
                        let mut sim_guard = sim_for_loop.lock().unwrap();
                        let inputs_guard = inputs_for_loop.lock().unwrap();
                        // This runs movement, combat and conquest, and builds a TickSnapshot.
                        // Network code will call update() again when needed, that is fine for now.
                        sim_guard.update(dt, &*inputs_guard);
                    }

                    sleep(Duration::from_millis(50)).await;
                }
            });

            // --- WEBSOCKET SERVER (clients connect here) ---
            let sim_for_net = sim.clone();
            let inputs_for_net = inputs.clone();

            tauri::async_runtime::spawn(async move {
                if let Err(e) =
                    network::start_server("127.0.0.1:8080", sim_for_net, inputs_for_net).await
                {
                    eprintln!("[NET] WebSocket server error: {e}");
                }
            });

            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}


====================================
FILE: apps/client-tauri/src-tauri/src/main.rs
====================================

#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    bf42lite::run();
}

====================================
FILE: apps/client-tauri/src-tauri/src/sim.rs
====================================

// apps/client-tauri/src-tauri/src/sim.rs
use std::collections::HashMap;
use crate::protocol::{
    TickSnapshot,
    EntitySnapshot,
    GameModeState,
    TeamId,
    TeamStruct,
    ScoreStruct,
    ClientMessage,
    LoadoutStruct,
    AmmoStruct,
    FlagSnapshot,
};

use crate::systems;
use crate::player::Player;
use crate::config::GameConfig;

pub struct SimState {
    pub players: HashMap<u32, Player>,
    pub tickets_a: f32,
    pub tickets_b: f32,
    pub frame_count: u64,
    pub flags: Vec<FlagZone>,
     pub config: GameConfig,
}

// Simple server-side representation of a Conquest flag.
pub struct FlagZone {
    pub id: u32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub radius: f32,

    // Which team currently owns the flag.
    pub owner: TeamId,

    // Capture progress: -1.0 .. 1.0
    // < 0 = leaning to TeamB, > 0 = leaning to TeamA, 0 = neutral
    pub capture: f32,
}

impl SimState {
    pub fn new() -> Self {
        // Try to load from a TOML file; fall back to defaults if missing.
let config = GameConfig::load_all();

        Self {
            players: HashMap::new(),
            tickets_a: 100.0,
            tickets_b: 100.0,
            frame_count: 0,
            flags: crate::maps::warehouse::create_flags(),
            config,
        }
    }

    pub fn handle_join(&mut self, id: u32) {
        let team = TeamId::TeamA; // simple for now
        let mut p = Player::new(id, team);
        p.respawn();
        self.players.insert(id, p);
        println!("[NET] Player {} joined", id);
    }

    pub fn handle_disconnect(&mut self, id: u32) {
        self.players.remove(&id);
        println!("[NET] Player {} disconnected", id);
    }

    pub fn update(
        &mut self,
        dt: f32,
        input_map: &HashMap<u32, ClientMessage>,
    ) -> TickSnapshot {
        // Debug: how many inputs did we get this tick?
        println!("[DEBUG] input_map len = {}", input_map.len());

        self.frame_count += 1;

        // 1. Run Systems
        systems::movement::update(
            &mut self.players,
            input_map,
            dt,
            self.frame_count,
            &self.config.movement,
        );

        // Debug after movement (keep your existing log)
        if let Some((id, p)) = self.players.iter().next() {
            println!(
                "[DEBUG] After movement: Player {} at ({:.1}, {:.1}, {:.1}) team={:?}",
                id, p.transform.x, p.transform.y, p.transform.z, p.team
            );
        }

        systems::combat::update(&mut self.players, input_map, dt, &self.config);

        // 2. Conquest logic: update flag capture + tickets
        systems::conquest::update_conquest(
            &mut self.flags,
            &self.players,
            &mut self.tickets_a,
            &mut self.tickets_b,
            dt,
            &game_config.conquest,
        );

        // 3. Game Mode Logic (winner)
        let winner = if self.tickets_a <= 0.0 {
            TeamId::TeamB
        } else if self.tickets_b <= 0.0 {
            TeamId::TeamA
        } else {
            TeamId::None
        };

        // 4. Snapshot Generation: entities
        let mut entities = Vec::new();
        for p in self.players.values() {
            entities.push(EntitySnapshot {
                // Match protocol.rs EntitySnapshot
                id: p.id,
                x: p.transform.x,
                y: p.transform.y,
                z: p.transform.z,
                yaw: p.transform.yaw,
                pitch: p.transform.pitch,

                // Protocol wants Option<f32> for health/stamina
                health: Some(p.health),
                stamina: Some(100.0), // placeholder until you have real stamina

                team: Some(TeamStruct { id: p.team }),
                score: Some(ScoreStruct {
                    kills: p.score_kills,
                    deaths: p.score_deaths,
                }),
                loadout: Some(LoadoutStruct {
                    class_id: p.class_id as u8, // cast if needed
                }),
                // TEMP: send zeros until Player has ammo fields
                ammo: Some(AmmoStruct {
                    current: 0,
                    reserve: 0,
                }),
            });
        }

        // 5. Snapshot Generation: flags
        let flags = self.flags
            .iter()
            .map(|f| FlagSnapshot {
                id: f.id,
                x: f.x,
                y: f.y,
                z: f.z,
                radius: f.radius,
                owner: f.owner,
                capture: f.capture,
            })
            .collect();

        TickSnapshot {
            entities,
            flags,
            game_state: GameModeState {
                team_a_tickets: self.tickets_a.round() as i32,
                team_b_tickets: self.tickets_b.round() as i32,
                match_ended: winner != TeamId::None,
                winner,
            },
        }
    }
}


====================================
FILE: apps/client-tauri/src-tauri/src/config.rs
====================================

// apps/client-tauri/src-tauri/src/config.rs
use serde::Deserialize;
use std::fs;

#[derive(Debug, Clone, Deserialize)]
pub struct MovementConfig {
    pub move_speed: f32,
    pub gravity: f32,
    pub jump_force: f32,
    pub sprint_multiplier: f32,
    pub mouse_sensitivity: f32,
}

impl Default for MovementConfig {
    fn default() -> Self {
        Self {
            move_speed: 6.0,
            gravity: -9.81,
            jump_force: 5.0,
            sprint_multiplier: 1.5,
            mouse_sensitivity: 0.1,
        }
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct WeaponConfig {
    pub id: u32,
    pub key: String,
    pub name: String,
    pub damage_per_hit: f32,
    pub fire_rate: f32, // seconds between shots
    pub mag_size: u32,
    pub reserve_ammo: u32,
    pub recoil: f32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ClassConfig {
    pub id: u8,
    pub key: String,
    pub name: String,
    pub max_health: f32,
    pub primary_weapon_id: u32,
}

#[derive(Debug, Deserialize, Clone)]
pub struct ConquestConfig {
    pub team_a_initial_tickets: i32,
    pub team_b_initial_tickets: i32,
    pub tickets_per_death: i32,
    pub tickets_per_bleed: i32,
    pub bleed_interval_seconds: f32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct GameConfig {
    #[serde(default)]
    pub movement: MovementConfig,

    #[serde(default)]
    pub weapons: Vec<WeaponConfig>,

    #[serde(default)]
    pub classes: Vec<ClassConfig>,
}

impl Default for GameConfig {
    fn default() -> Self {
        Self {
            // movement still has code defaults as a safety net
            movement: MovementConfig::default(),
            // NO in-code weapons/classes stats anymore
            weapons: Vec::new(),
            classes: Vec::new(),
        }
    }
}

impl GameConfig {
    /// Keep TOML loader for movement (and as a general config file if you want).
    pub fn load_from_file(path: &str) -> Self {
        let contents = fs::read_to_string(path).unwrap_or_else(|err| {
            eprintln!(
                "[GameConfig] Failed to read {}: {}. Using defaults.",
                path, err
            );
            String::new()
        });

        if contents.trim().is_empty() {
            eprintln!("[GameConfig] Empty or missing config file. Using defaults.");
            return GameConfig::default();
        }

        match toml::from_str::<GameConfig>(&contents) {
            Ok(cfg) => cfg,
            Err(err) => {
                eprintln!(
                    "[GameConfig] Failed to parse {}: {}. Using defaults.",
                    path, err
                );
                GameConfig::default()
            }
        }
    }

    /// Weapons/classes come only from JSON.
    pub fn load_all() -> Self {
        // 1) Start from TOML (for movement); weapons/classes will be overwritten by JSON
        let mut cfg = GameConfig::load_from_file("game_config.toml");

        // 2) weapons.json
        match fs::read_to_string("weapons.json") {
            Ok(text) => match serde_json::from_str::<Vec<WeaponConfig>>(&text) {
                Ok(weapons) => {
                    println!("[GameConfig] Loaded {} weapons from weapons.json", weapons.len());
                    cfg.weapons = weapons;
                }
                Err(err) => {
                    eprintln!("[GameConfig] Failed to parse weapons.json: {}. Leaving weapons empty.", err);
                    cfg.weapons.clear();
                }
            },
            Err(err) => {
                eprintln!(
                    "[GameConfig] Failed to read weapons.json: {}. Leaving weapons empty.",
                    err
                );
                cfg.weapons.clear();
            }
        }

        // 3) classes.json
        match fs::read_to_string("classes.json") {
            Ok(text) => match serde_json::from_str::<Vec<ClassConfig>>(&text) {
                Ok(classes) => {
                    println!("[GameConfig] Loaded {} classes from classes.json", classes.len());
                    cfg.classes = classes;
                }
                Err(err) => {
                    eprintln!("[GameConfig] Failed to parse classes.json: {}. Leaving classes empty.", err);
                    cfg.classes.clear();
                }
            },
            Err(err) => {
                eprintln!(
                    "[GameConfig] Failed to read classes.json: {}. Leaving classes empty.",
                    err
                );
                cfg.classes.clear();
            }
        }

        cfg
    }
}


====================================
FILE: apps/client-tauri/src-tauri/src/systems/mod.rs
====================================

// apps/client-tauri/src-tauri/src/systems/mod.rs
pub mod movement;
pub mod combat;
pub mod conquest;

====================================
FILE: apps/client-tauri/src-tauri/src/systems/conquest.rs
====================================

// apps/client-tauri/src-tauri/src/systems/conquest.rs

use std::collections::HashMap;

use crate::config::ConquestConfig;
use crate::player::Player;
use crate::protocol::TeamId;
use crate::sim::FlagZone;

/// Run conquest capture + ticket bleed for this tick.
pub fn update_conquest(
    flags: &mut Vec<FlagZone>,
    players: &HashMap<u32, Player>,
    tickets_a: &mut f32,
    tickets_b: &mut f32,
    dt: f32,
    cfg: &ConquestConfig,
) {
    if dt <= 0.0 {
        // Snapshot sender sometimes calls with dt = 0.0, skip progression.
        return;
    }

    // Tweak these to taste.
    const CAPTURE_SPEED: f32 = 0.25;    // progress per second
    const DECAY_SPEED: f32 = 0.10;      // decay when empty / contested
    const CAPTURE_THRESHOLD: f32 = 1.0; // when |capture| >= 1.0, flip owner
    // No TICKET_BLEED_PER_FLAG here anymore; we use cfg.tickets_per_bleed below.

    // === 1) Update capture progress for each flag ===
    for flag in flags.iter_mut() {
        let mut count_a = 0u32;
        let mut count_b = 0u32;

        // Count players inside radius by team.
        for p in players.values() {
            if p.is_dead {
                continue;
            }

            let dx = p.transform.x - flag.x;
            let dy = p.transform.y - flag.y;
            let dz = p.transform.z - flag.z;
            let dist_sq = dx * dx + dy * dy + dz * dz;

            if dist_sq <= flag.radius * flag.radius {
                match p.team {
                    TeamId::TeamA => count_a += 1,
                    TeamId::TeamB => count_b += 1,
                    _ => {}
                }
            }
        }

        // Debug: if anyone is in the zone, log counts once per tick.
        if count_a > 0 || count_b > 0 {
            println!(
                "[CONQUEST-TRACE] Flag {} players in radius: A={} B={} (pos=({:.1},{:.1},{:.1}), r={:.1})",
                flag.id, count_a, count_b, flag.x, flag.y, flag.z, flag.radius
            );
        }

        let old_owner = flag.owner;

        // Decide capture direction.
        let delta = if count_a > 0 && count_b == 0 {
            // Team A capturing.
            CAPTURE_SPEED * dt
        } else if count_b > 0 && count_a == 0 {
            // Team B capturing.
            -CAPTURE_SPEED * dt
        } else if count_a == 0 && count_b == 0 {
            // No one here: decay toward 0.
            if flag.capture > 0.0 {
                -DECAY_SPEED * dt
            } else if flag.capture < 0.0 {
                DECAY_SPEED * dt
            } else {
                0.0
            }
        } else {
            // Contested: decay toward 0.
            if flag.capture > 0.0 {
                -DECAY_SPEED * dt
            } else if flag.capture < 0.0 {
                DECAY_SPEED * dt
            } else {
                0.0
            }
        };

        flag.capture += delta;

        // Clamp capture to [-1.0, 1.0].
        if flag.capture > 1.0 {
            flag.capture = 1.0;
        }
        if flag.capture < -1.0 {
            flag.capture = -1.0;
        }

        // Debug: show capture progress if it's doing anything noticeable.
        if flag.capture.abs() > 0.01 {
            println!(
                "[CONQUEST-TRACE] Flag {} capture={:.2} owner={:?} (A={}, B={})",
                flag.id, flag.capture, flag.owner, count_a, count_b
            );
        }

        // Flip ownership when fully captured.
        if flag.capture >= CAPTURE_THRESHOLD && flag.owner != TeamId::TeamA {
            flag.owner = TeamId::TeamA;
        } else if flag.capture <= -CAPTURE_THRESHOLD && flag.owner != TeamId::TeamB {
            flag.owner = TeamId::TeamB;
        }

        // Log only when the owner actually changes.
        if old_owner != flag.owner {
            match flag.owner {
                TeamId::TeamA => {
                    println!("[CONQUEST] Flag {} captured by Team A", flag.id);
                }
                TeamId::TeamB => {
                    println!("[CONQUEST] Flag {} captured by Team B", flag.id);
                }
                _ => {
                    println!("[CONQUEST] Flag {} became neutral", flag.id);
                }
            }
        }
    }

    // === 2) Ticket bleed based on majority control ===
    let mut owned_a = 0u32;
    let mut owned_b = 0u32;

    for flag in flags.iter() {
        match flag.owner {
            TeamId::TeamA => owned_a += 1,
            TeamId::TeamB => owned_b += 1,
            _ => {}
        }
    }

    let bleed_per_flag = cfg.tickets_per_bleed as f32;

    if owned_a > owned_b {
        let advantage = (owned_a - owned_b) as f32;
        let bleed = advantage * bleed_per_flag * dt;
        *tickets_b -= bleed;
        if *tickets_b < 0.0 {
            *tickets_b = 0.0;
        }
    } else if owned_b > owned_a {
        let advantage = (owned_b - owned_a) as f32;
        let bleed = advantage * bleed_per_flag * dt;
        *tickets_a -= bleed;
        if *tickets_a < 0.0 {
            *tickets_a = 0.0;
        }
    }
}



