====================================
FILE: \docs\00_index.md
====================================

#### `docs/00_index.md`
*New Index File*
```markdown
# bf42lite Documentation Index (v1.3)

Simplified modular documentation focusing on LAN gameplay and hybrid authority.

## ðŸ§­ Design
- [10_vision_core.md](./10_vision_core.md)
- [20_design_gameplay.md](./20_design_gameplay.md)
- [30_design_sim_arch.md](./30_design_sim_arch.md)

## ðŸŒ Networking
- [40_design_net_protocol.md](./40_design_net_protocol.md)

## ðŸ’» Client
- [50_design_client_rendering.md](./50_design_client_rendering.md)

## ðŸ—‚ Backlog
- [60_development_backlog.md](./60_development_backlog.md)

## âš™ï¸ Infrastructure
- [70_repo_structure.md](./70_repo_structure.md)

====================================
FILE: \docs\10_vision_core.md
====================================

# Vision & Core Goals (v1.3)

**Project:** bf42lite
**Genre:** LAN / Local Multiplayer FPS
**Inspiration:** Battlefield 1942
**Players:** 2â€“12 (MVP: 2â€“4)
**Platforms:** Windows (primary), Linux (AppImage), macOS (later)
**Engine Stack:** JS/TS (Client Physics) + Three.js + Tauri + Rust (Server State)

## Vision
Deliver fast and responsive LAN battles with smooth movement, readable visuals, and consistent state.
Use Client Authority for movement and aiming, while the server ensures consistent results for health, tickets, and confirmed hits.

## Core Principles
* **Client controls continuous physics** (movement, aiming).
* **Server controls all discrete game rules** (health, kills, scores).
* **Hits feel instant** (client prediction) but are reconciled by the server so all players see the same outcome.
* **Minimal setup:** single host, quick join.

## Focus
LAN gameplay (no anti-cheat, but full consistency). Updated for Client-Predicted, Server-Reconciled Hits.

====================================
FILE: \docs\20_design_gameplay.md
====================================

# Gameplay Design (v1.3)

## Core Loop
Host or join â†’ Spawn â†’ Move, shoot, capture flags â†’ Die and respawn â†’ Tickets or time expire.

## Modes
| Mode | Description | Phase |
| :--- | :--- | :--- |
| **Conquest** | Hold control points to drain enemy tickets. | 4+ |
| **Team DM** | Eliminate enemies; tickets = respawns. | 4+ |
| **Sandbox** | Physics/weapons testing. | 2+ |

## Classes (Later)
* **Assault, Engineer, Support, Recon** (light roles only).

## Weapons (Phases 2â€“4)
* Rifle, SMG, Sniper, Grenade.

## Maps
* **Warehouse (MVP)**
* **Island (Phase 5)**

====================================
FILE: \docs\30_design_sim_arch.md
====================================

# Simulation Architecture (v1.3)

The architecture explicitly avoids cross-language determinism by splitting continuous vs. discrete responsibilities.

## Authority Split
| Feature | Authority | Location | Reason |
| :--- | :--- | :--- | :--- |
| **Movement Physics** | Client | `packages/sim` (TS) | Instant input response. |
| **Collision (visual)** | Client | TS | Immediate feedback. |
| **Hit Detection (final)** | Server | Rust | Ensures both players see the same result. |
| **Health/Death** | Server | Rust | Centralized game rules. |
| **Scoring/Tickets** | Server | Rust | Consistent match flow. |
| **Rate Limits** | Server | Rust | Prevents accidental spam. |

## Hit Model: Predict + Reconcile
**Client**
1.  Performs raycast.
2.  Shows hit spark / marker immediately.
3.  Sends a fire proposal: `{ type: "fire", origin, direction, weaponId, clientTick }`

**Server**
1.  Re-runs the raycast using authoritative positions.
2.  Confirms if the hit is valid.
3.  Computes damage.
4.  Broadcasts a final event: `{ type: "hitConfirmed", shooterId, targetId, damage }`

*This avoids â€œI was behind cover on my screenâ€ even on LAN.*

## Determinism Rules
* **Client** runs fixed timestep (1/60).
* **Server** stores authoritative transforms from client reports.
* **Server** validates movement with simple checks (max speed, max teleport).
* **Server** performs only discrete logic (health, respawns, tickets).

====================================
FILE: \docs\40_design_net_protocol.md
====================================

# Networking Protocol (v1.3)

## Transport
* **UDP:** State updates (positions, rotations).
* **TCP/WebSocket:** Reliable events (joins, hits, killfeed, system messages).

## Message Structure

### Client â†’ Server
* **State Update:** `{ type: 'update', x, y, z, yaw }`
* **Fire Proposal:** `{ type: 'fire', origin, direction, weaponId, clientTick }`
* **Actions:** `{ type: 'respawn', classId }`, etc.

### Server â†’ Client
* **Snapshot:** `{ type: 'snapshot', entities: [...], scores, tickets }`
* **Hit Confirmation:** `{ type: 'hitConfirmed', shooterId, targetId, damage }`
* **Death Event:** `{ type: 'death', victimId, killerId }`

## Encoding
* `msgpackr` for binary transport.
* `zod` schemas for strict validation (`packages/protocol`).

## Snapshot Rate
Target: 10â€“20 Hz snapshots, client interpolates to 60 FPS.

====================================
FILE: \docs\50_design_client_rendering.md
====================================

# Client Rendering (v1.3)

## Tech
Three.js + React overlay.

## Interpolation
* **Local player:** Immediate (predicted).
* **Remote players:** Interpolated between last two snapshots for smoothness.

## Visual Style
* Low-poly, flat shading, readable silhouettes.
* Target 60 FPS on basic GPUs/APUs.

====================================
FILE: \docs\60_backlog_phase1_core_mvp.md
====================================

# Development Backlog (v1.3)

**Current Focus:** Phase 4 â€” Core Gameplay & Hit Reconciliation

## Phases
| Phase | Goal | Deliverables |
| :--- | :--- | :--- |
| **1** | Core MVP | Movement, ECS loop, glTF models |
| **2** | LAN Loopback | Host/join, basic messages |
| **3** | Visual Polish | Camera, HUD, map |
| **4** | Core Gameplay | Shooting, hit reconcile, death/respawn, tickets |
| **5** | Expansion | Vehicles, Island map, class roles |

## Phase 4 Acceptance Criteria
* [ ] Player movement is smooth on other clients via interpolation.
* [ ] Client proposes fire; server validates and confirms hits.
* [ ] Server applies damage, death, respawn logic.
* [ ] Tickets drain reliably and reach Game Over state.

====================================
FILE: \docs\70_repo_structure.md
====================================

# Infrastructure & Repo Layout (v1.4)

## Tree Overview

```text
bf42lite/
â”œâ”€â”€ .gitattributes
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ bf_42_lite_simplified_docs.md
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ pnpm-workspace.yaml
â”œâ”€â”€ tsconfig.base.json
â”œâ”€â”€ apps/
â”‚   â””â”€â”€ client-tauri/
â”‚       â”œâ”€â”€ src/          # TypeScript client: rendering, input, prediction
â”‚       â”œâ”€â”€ src-tauri/    # Rust host: state, validation, relay (inside the app)
â”‚       â”œâ”€â”€ public/       # Static assets (models, etc.)
â”‚       â””â”€â”€ dist/         # Built client bundle
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ sim/              # Shared ECS simulation: movement, health, etc.
â”‚   â”œâ”€â”€ net/              # Networking adapters (loopback, WebSocket)
â”‚   â”œâ”€â”€ protocol/         # Binary schemas and helpers
â”‚   â””â”€â”€ host-node/        # Dev-only Node host
â””â”€â”€ docs/                 # Modular design + backlog docs


====================================
FILE: \docs\80_backlog_phase2_expansion.md
====================================

Phase 2 expands bf42lite from infantry-only combat into a simplified combined-arms Battlefield-style game.
The goal is to introduce classes, vehicles, conquest mode, dynamic spawning, and a larger map while keeping all systems â€œLiteâ€ and manageable for a solo developer.

Purpose

Phase 2 introduces several major features:

â€¢ Lite classes
â€¢ Simplified vehicle framework
â€¢ Conquest game mode
â€¢ Dynamic spawnpoints
â€¢ Ticket bleed
â€¢ Stationary defenses
â€¢ Island-style combined-arms map

This phase also sets the foundation for future projects such as BF2Lite and BF2142Lite.

High-Level Deliverables

Gameplay:

Three infantry classes with simplified abilities.

Basic loadout system.

Vehicles:

GenericVehicle base class.

First vehicle: Tank using simplified hover-based movement.

Game Mode:

Conquest mode including capture points and capture progress.

Spawning:

Deploy screen allowing spawnpoint selection based on flag ownership.

Map:

Island map with flags, beaches, hills, and sea approach routes.

Balancing:

Ticket bleed based on majority flag ownership.

Stationary Defenses:

AA gun and coastal gun implemented as immobile vehicles.

Phase Breakdown

3.1. Conquest Core

Flag Zones:

Each flag has a capture radius and an ownership state.

Capture progress increases toward the team with more players inside the radius.

Progress stops if team counts are equal.

Dynamic Spawnpoints:

Each flag contains several spawnpoints.

When a team captures a flag, its spawnpoints become available to that team.

Ticket System Update:

Teams still lose a ticket when a player dies.

A team holding more than half the flags causes enemy tickets to drain slowly over time.

This component should be completed before vehicle work begins.

3.2. Lite Classes

Class Selection:

Added to Deploy Screen.

Loadouts assigned per class.

Grunt:

Primary weapon: SMG.

Ability: Heal aura activates if stationary for several seconds.

Heavy:

Primary weapon: Bazooka.

Ability: Wrench repairs friendly vehicles when used as melee.

Scout:

Primary weapon: Bolt-action rifle.

Ability: High-zoom mode for long-range aiming.

3.3. Vehicle Core Framework

Mount System:

Player enters vehicle with a key press.

Player model becomes hidden.

Camera attaches to vehicle seat.

Inputs are sent to the vehicle instead of the player character.

GenericVehicle Architecture:

Health value.

Seat definitions.

Movement model type (land, air, sea).

Weapon systems.

Spawn and respawn properties.

Tank (Land Vehicle):

Uses four downward raycasts to simulate hover-like suspension.

Remains upright at all times.

Independent turret and barrel rotation.

Slow but powerful movement and firing.

3.4. Additional Vehicle Units

Plane:

Always moves forward.

Pitch controlled by mouse vertical input.

Roll controlled by mouse horizontal input.

No stall system; simplified flight.

Boat:

Uses buoyancy to stay near water level.

Forward acceleration and slow turning.

Stationary Defenses:

Coastal gun with high-damage shell.

AA gun with high rate of fire.

Implemented as vehicles without movement.

Phase 2 Map: Island

Map Design Goals:

Large enough for vehicle combat.

Several flag zones (beach, hill, center).

Shoreline for boat landings.

Open sky for aircraft.

Areas for stationary defenses.

Technical Requirements

Physics:

VehicleController for all vehicles.

Hover simulation with raycasts.

Simplified buoyancy for boats.

Simplified pitch/roll flight model.

Networking:

Vehicle input messages from client to server.

Vehicle state included in snapshots.

Vehicles predicted locally with server reconciliation.

Rendering:

Cameras mounted to vehicle seats.

Turret rotation animations.

Optional visual effects for boats and planes.

UI:

Updated Deploy Screen with class and spawnpoint selection.

Indicators for flag ownership and capture progress.

Display for active vehicle seat.

Optional Stretch Goals

Infantry:

Grenade launcher for Heavy.

Smoke grenade for Scout.

Vehicles:

Jeep (fast, unarmored).

Transport boat.

Commander (Lite):

Single ability: artillery strike triggered by a marked location.

Acceptance Criteria

Phase 2 is complete when:

â€¢ Flags can be captured and ownership changes correctly.
â€¢ Ticket bleed works and can end a match.
â€¢ Class selection functions at spawn.
â€¢ Vehicles can be entered and exited consistently.
â€¢ Tank movement and firing are functional.
â€¢ Planes and boats operate with basic stability.
â€¢ Island map performs at or near 60 FPS.
â€¢ Multiple clients can play a full Conquest match from start to finish.

====================================
FILE: \docs\architecture_overview_v1_ascii.md
====================================

# bf42lite â€” Architecture Overview (Updated 2025)

This document describes the current architecture of **bf42lite**, reflecting the latest refactors:
- Server-authoritative simulation (Rust)
- Client (TS) as a prediction/visualization layer only
- Config-driven gameplay rules (TOML/JSON)
- Deterministic tick loop
- Snapshot networking model

---

## 1. High-Level Architecture

The game consists of **three main layers**:

1. **Engine-Core (Rust + TS shared schema)**  
   - ECS components (Transform, Velocity, Health, Ammo, Soldier, Team, etc.)  
   - Tick-based deterministic simulation loop  
   - Prediction & reconciliation model  
   - Snapshot schema and message formats (in `@bf42lite/protocol`)

2. **Game Logic Layer (Rust)**  
   - Conquest rules (capture, bleed, tickets, match end, winner)  
   - Weapon damage, firing rules, rpm enforcement  
   - Movement physics (gravity, jump, speed)  
   - Respawns & spawn points  
   - Map geometry (flags, radii, base spawns)

3. **Client (TypeScript)**  
   - Rendering (Three.js + Tauri canvas)  
   - HUD/UI  
   - Crosshair, recoil, view animations  
   - Sound, hitmarkers, screen effects  
   - Input gathering  
   - Prediction + interpolation of entities between snapshots

The **server owns all gameplay truth**.  
The **client only predicts visually** and corrects from snapshots.

---

## 2. Networking Model

### 2.1 Input â†’ Server  
Client sends:
- movement inputs  
- aim direction  
- fire requests  
- class selection  
- spawn requests  

### 2.2 Server Simulation  
Server applies:
- movement physics  
- combat calculations  
- flag capture  
- ticket loss  
- bleeding  
- setting `match_ended` & `winner`

### 2.3 Snapshot â†’ Client  
Server sends snapshots containing:
```ts
{
  tick: number,
  entities: [...],
  game_state: {
     team_a_tickets: number,
     team_b_tickets: number,
     match_ended: boolean,
     winner: 'TEAM_A' | 'TEAM_B' | null
  },
  flags: [...FlagSnapshot...]
}
Client interpolates remote entities and reconciles the local player.

3. Prediction, Reconciliation, Interpolation
Prediction (Client)

Client simulates its own movement frame-to-frame using:

movement config values

local inputs

last known server state

Reconciliation (Client)

On snapshot:

Rewind to server-confirmed position

Re-apply predicted inputs

Correct divergence

Interpolation (Client)

Remote players:

Stored in a small buffer

Interpolated smoothly across snapshots

Never predicted

4. Game Rules Ownership
System	Owner	Notes
Movement physics	Server	Client predicts; server corrects.
Weapon damage	Server	All damage/hits authoritative.
Fire rate enforcement	Server	Cannot fire too quickly client-side.
Conquest ticket rules	Server	Capture, bleed, per-death ticket loss.
Map geometry	Server	Spawn points, flags, radii.
Match start/end	Server	Exported via snapshot.
HUD/UI	Client	Purely render-only.
Crosshair & recoil	Client	Cosmetic only.
Interpolation	Client	Smooth remote entities.
5. Config-Driven Data

game_config.toml contains:

[movement]

[conquest]

[[weapons]]

[[classes]]

Rust loads the config; the client may load it only for prediction/UX.

6. Directory Diagram (Conceptual)
root
â”œâ”€â”€ apps
â”‚   â”œâ”€â”€ client-tauri (TS)
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ core/ (renderer, weapon visuals)
â”‚   â”‚   â”‚   â”œâ”€â”€ systems/ (prediction, interpolation)
â”‚   â”‚   â”‚   â”œâ”€â”€ ui/ (HUDUpdater, UIManager)
â”‚   â”‚   â”‚   â”œâ”€â”€ net/ (NetworkManager)
â”‚   â”‚   â””â”€â”€ src-tauri/ (Rust server)
â”‚   â”‚       â”œâ”€â”€ config.rs
â”‚   â”‚       â”œâ”€â”€ sim.rs
â”‚   â”‚       â”œâ”€â”€ systems/
â”‚   â”‚       â”‚   â”œâ”€â”€ conquest.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ combat.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ movement.rs
â”‚   â”‚       â””â”€â”€ maps/
â”œâ”€â”€ packages
â”‚   â”œâ”€â”€ protocol
â”‚   â””â”€â”€ engine-core
â””â”€â”€ docs


====================================
FILE: \docs\conquest.md
====================================

# Conquest System â€” Authoritative Server Implementation (2025)

This document explains the **server-side Conquest system**.  
Everything in this file reflects the **current**, fully server-authoritative model.

---

## 1. Overview

Conquest is managed entirely on the **server (Rust)**.  
The client simply renders whatever the snapshot provides.

Server maintains:

- Flag ownership & capture progress  
- Tickets for both teams  
- Ticket loss per death  
- Ticket bleed from flag majority  
- Match end conditions  
- Winner declaration  

This ensures all gameplay logic is secure and consistent across clients.

---

## 2. Capture Logic

Each flag is represented as:

```rust
pub struct FlagZone {
    pub id: u32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub radius: f32,
    pub owner: TeamId,
    pub capture: f32,  // -1.0..1.0
}
Steps per tick:
Count players inside radius per team.

Choose capture direction:

If only Team A present â†’ capture += speed

If only Team B present â†’ capture -= speed

If contested or empty â†’ capture decays toward 0

Flip owner if capture >= 1.0 or <= -1.0.

Write updated flags into the snapshot.

3. Tickets
Tickets represent remaining team strength.

Server updates tickets through:

3.1 Ticket Loss per Death
Triggered in combat system:

Team of the dead player loses tickets_per_death.

3.2 Ticket Bleed
Controlled by majority flag ownership:

css
Copy code
if A owns more flags â†’ B bleeds
if B owns more flags â†’ A bleeds
Amount:

ini
Copy code
bleed = advantage * tickets_per_bleed * dt
3.3 Ticket Floor
Tickets never go below 0.

4. Match End
The server marks the match as ended when:

nginx
Copy code
team_a_tickets <= 0  â†’ winner = TeamB
team_b_tickets <= 0  â†’ winner = TeamA
This sets:

rust
Copy code
match_ended = true
winner = Some(TeamWinner)
These values are included in the snapshotâ€™s game_state.

5. Config-Driven Conquest
Defined in game_config.toml:

toml
Copy code
[conquest]
team_a_initial_tickets = 100
team_b_initial_tickets = 100
tickets_per_death = 1
tickets_per_bleed = 1
bleed_interval_seconds = 5.0
The server reads these at startup and initializes ConquestState accordingly.

6. Snapshot Fields
Server sends:

ts
Copy code
game_state: {
  team_a_tickets: number,
  team_b_tickets: number,
  match_ended: boolean,
  winner: 'TEAM_A' | 'TEAM_B' | null
}

flags: FlagSnapshot[]
Client HUD uses these values exclusively.

7. Client Role
Client is purely visual:

Draws flags on minimap

Shows capture bar from flag.capture

Shows ticket counts

Plays capture/bleed animations

Shows game-over screen from game_state.match_ended

Client does not compute tickets or capture.

====================================
FILE: \docs\frametime_and_tickrate.md
====================================

==============================

FRAMETIME \& TICKRATE (TXT)

==============================



bf42lite uses a classic networked-FPS timing model inspired by GoldSrc / Source, designed for predictable simulation, smooth rendering, and minimal input latency.



This document defines how frametime, tickrate, and snapshot frequency interact.



Key Concepts



FPS (Frames Per Second)

How many frames the client renders each second.

Typical targets for bf42lite presets:



Potato: 30 FPS



Medium: 90 FPS



High: 120 FPS



Frametime

The duration of one frame. Lower is better.

Examples:



30 FPS â†’ ~33ms



60 FPS â†’ ~16.6ms



90 FPS â†’ ~11.1ms



120 FPS â†’ ~8.3ms



Simulation Tick (Server Tickrate)

How often the server simulates and sends authoritative updates.

Example:



30 Hz tickrate â†’ simulation every 33ms



60 Hz tickrate â†’ simulation every 16.6ms



bf42lite aims for 60 Hz server simulation by default.



Snapshot Frequency

How often the server sends world snapshots to clients. Usually equal to tickrate unless throttled.



Interpolation

Client blends between snapshots to smooth movement. Prevents jitter.



Prediction

Client simulates its own player until an authoritative snapshot arrives.



High-Level Model



Server simulates at 60 Hz



Server sends snapshots at 60 Hz (or throttled to ~30 Hz for weak clients)



Client renders at independent FPS: 30 / 90 / 120 depending on preset



Client interpolates between snapshots



Client predicts local movement and corrects with reconciliation



This decouples rendering from simulation.



Why 60 Hz Simulation Is Chosen



Simple and stable timing (16.6ms steps)



Easy to interpolate to ANY render FPS (30, 60, 90, 120, 144)



Compatible with handhelds and midrange PCs



Keeps network bandwidth reasonable



GoldSrc, Source, Quake, Overwatch 1, TF2 all used similar logic



How Rendering Interacts With Tickrate



Rendering FPS is NOT required to match server tickrate.

Examples:



Case 1: 30 FPS (Potato) vs 60 Hz server



Render every 33ms



Interpolate between every 2 server ticks



Input latency increases, but gameplay stays predictable



Good for weak hardware



Case 2: 90 FPS (Steam Deck OLED) vs 60 Hz server



Render every 11ms



Smooth visual interpolation



Input sampled 3 times per simulation step



Very responsive handheld experience



Case 3: 120 FPS (PC) vs 60 Hz server



Render every ~8ms



High fluidity



Low input latency



Great for 120/144 Hz monitors



In all cases, gameplay correctness remains identical.



Recommended Snapshot Strategy



Default:



60 Hz snapshots for Medium and High presets



Fallback:



30 Hz snapshots for Potato preset (if bandwidth or CPU is restricted)



Client interpolation handles both cases smoothly.



Input Sampling



Client should sample inputs every render frame.

This means:



30 FPS preset samples input 30 times per second



90 FPS preset samples input 90 times per second



120 FPS preset samples input 120 times per second



Inputs are bundled and sent to the server at a fixed rate (e.g., 60 Hz).



Input latency is therefore tied more to frametime than to tickrate.



Reconciliation Loop



When a snapshot arrives:



Correct local player authoritative state



Reapply stored inputs (unacknowledged steps)



Fix visual errors via interpolation and smoothing



This ensures consistency across all three presets.



Frametime Stability



Stable frametime is more important than raw FPS.



A stable:



30 FPS (33ms)

feels better than a spiky:



45 â†’ 70 â†’ 50 â†’ 85 â†’ 40 FPS



Your 30/90/120 targets are chosen because:



They divide evenly into 60 Hz simulation



They match common screen refresh rates



They keep frametime stable and predictable



Summary of Target Rates



POTATO:



Render: 30 FPS



Server tick: 60 Hz



Snapshots: 30â€“60 Hz depending on bandwidth



Goal: keep frametime consistent for weak hardware



MEDIUM (Steam Deck OLED):



Render: 90 FPS



Server tick: 60 Hz



Snapshots: 60 Hz



Goal: extremely smooth handheld experience



HIGH (1080p PC):



Render: 120 FPS



Server tick: 60 Hz



Snapshots: 60 Hz



Goal: high responsiveness for 120/144 Hz players



====================================
FILE: \docs\graphics_scaling.md
====================================

==========================

GRAPHICS SCALING (TXT)

==========================



bf42lite uses three scalable presets: Potato (30 FPS), Medium (90 FPS), and High (120 FPS).

No postprocessing. All scaling is done using classic GoldSrc-style adjustments: geometry, textures, particles, and world detail.



Geometry and LOD



Potato:



Lowest LOD



Many props removed



Medium:



Medium LOD



All key props present



High:



Full detail LOD



All props + clutter



Textures



Potato:



256â€“512 max textures



Aggressive mip bias



Bilinear filtering



Medium:



512â€“1024 textures



Normal mip bias



Bilinear or trilinear



High:



1024 hero textures allowed



Trilinear filtering



Lighting



Potato:



Baked lightmaps only



No shadows or blob shadows



Very limited dynamic lights (~4)



Medium:



Baked lightmaps



Projected/blob shadows



More dynamic lights (~12)



High:



Baked lightmaps



Higher-res projected shadows



Many dynamic lights (~24)



Particles



Potato: Cap ~128



Minimal explosions



Short-lived smoke



Simplified tracers



Medium: Cap ~256â€“512



Standard explosions



Persistent but capped smoke



Normal tracers



High: Cap ~512â€“1024



Large explosions



Dense debris and persistent smoke



Full tracer density



Decals (bullet holes, impacts)



Potato: ~32 decals cap, aggressive fade

Medium: ~128 decals cap, normal fade

High: ~256â€“512 decals cap, slow fade



Ragdolls



Potato: 0â€“1, very short lifetime

Medium: 3â€“4, medium lifetime

High: 6â€“8, long lifetime



Props and World Detail



Potato: minimal foliage, minimal debris

Medium: full intended props

High: full props + clutter meshes



Audio Scaling



Potato: ~16 voices

Medium: 48â€“64 voices

High: 64â€“96 voices



Simulation / Network Considerations



Preset does NOT affect tickrate.

Only visual density and GPU load scale across presets.



====================================
FILE: \docs\map.md
====================================

This document describes how map data, flags, spawns, and geometry now work.

---

## 1. Overview

The **server owns all gameplay-related map data**:

- flag positions  
- flag radii  
- initial ownership  
- spawn points for teams  
- world boundaries  
- terrain areas relevant for gameplay  

The client does not own any authoritative geometry.

---

## 2. Flag Data Structure

```rust
pub struct FlagZone {
    pub id: u32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub radius: f32,
    pub owner: TeamId,
    pub capture: f32,
}
Flags are defined in Rust under maps/ and loaded into the simulation.

3. Spawn Points
Rust provides spawn positions for:

Team A bases

Team B bases

Possible forward spawns (later)

Safe spawn checks

Client only shows spawn UI; server validates and executes respawns.

4. Why Server Owns Map Data
Prevents client-side cheating by altering geometry

Ensures consistent collision and capture zones

Simplifies gameplay code

Makes flag ownership authoritative

Clientâ€™s map/minimap is presentation-only.

5. Snapshot Map Data
Snapshots include:

ts
Copy code
flags[] {
  id,
  x, y, z,
  radius,
  owner,
  capture
}
Client uses this purely to draw UI.

6. Future Extensions
The current model supports future systems:

dynamic objectives

vehicle spawns

destructible structures

map scripting (scripted events)

line-of-sight / minimap fog-of-war

====================================
FILE: \docs\performance_presets.md
====================================

==========================

PERFORMANCE PRESETS (TXT)

==========================



bf42lite â€“ GoldSrc-inspired, no postprocessing

Three presets based on target hardware and refresh-rate goals.



PRESETS:



POTATO â†’ 30 FPS



MEDIUM â†’ 90 FPS



HIGH â†’ 120 FPS



PRESET: POTATO (30 FPS target)



Target hardware:



Very old iGPUs (Intel HD 500)



Low-end Chromebooks



Old preowned PCs



Resolution:



720p



FPS Target:



30 FPS stable (half of 60 Hz)



Shadows:



None or simple blob



Textures:



Low resolution (256â€“512 max)



Geometry / Props:



Lowest LODs



Many props removed to reduce draw calls



Particles:



Cap ~128 total



Decals:



Cap ~32 total



Ragdolls:



0 to 1 active at once



Dynamic lights:



Roughly 4 active lights



Notes:



Pure fallback mode for very weak systems



Ensures game is still playable even at minimal hardware



PRESET: MEDIUM (90 FPS target â€“ Steam Deck OLED)



Target hardware:



Steam Deck OLED (90 Hz)



Lowâ€“mid PCs and handheld devices



Resolution:



1280x800



FPS Target:



90 FPS stable



Shadows:



Cheap blob or projected shadows



Textures:



Medium resolution (512â€“1024)



Geometry / Props:



Full low-poly world



All intended props present



Particles:



Cap roughly 256 to 512



Decals:



Cap around 128



Ragdolls:



3 to 4 active



Dynamic lights:



Around 12 active lights



Notes:



Primary design preset



Smooth handheld experience designed for the 90 Hz OLED screen



PRESET: HIGH (120 FPS target â€“ Midrange PC)



Target hardware:



Midrange gaming PCs (RTX 3060 / RX 6600 / 2060 class)



Resolution:



1080p



FPS Target:



120 FPS (never below 60)



Shadows:



Higher-quality projected shadows



Textures:



Mediumâ€“High (1024 for hero assets)



Geometry / Props:



Full detail, clutter included



Particles:



Cap ~512 to 1024



Decals:



Cap ~256 to 512



Ragdolls:



6 to 8 active



Dynamic lights:



Around 24 active lights



Notes:



Designed for 120â€“144 Hz desktop monitors



Smooth, high-end PC experience



Preset Summary (TXT Form)



POTATO â€“ 30 FPS â€“ 720p â€“ weak hardware

MEDIUM â€“ 90 FPS â€“ 1280x800 â€“ Steam Deck OLED

HIGH â€“ 120 FPS â€“ 1080p â€“ midrange PCs



====================================
FILE: \docs\weapons.md
====================================


# Weapons & Classes â€” Data-Driven, Server-Authoritative

This document describes the weapon and class system in bf42lite.

---

## 1. Overview

All **gameplay-critical** weapon and class stats are **owned by the server (Rust)**.  
The client loads the same data only for:

- prediction  
- HUD labels  
- recoil/crosshair visuals  
- ammo indicators  

Damage, RPM enforcement, and hit validation are always done on the server.

---

## 2. Data Sources

### 2.1 game_config.toml  
Movement, conquest, and global rules.

### 2.2 weapons.json / classes.json  
Per-weapon fields such as:

- damage  
- rpm  
- muzzle velocity  
- ammo capacity  
- allowed classes  

These are loaded by Rust at startup.

---

## 3. Server Responsibilities

Server controls:

- Bullet/hit detection  
- Damage calculation  
- Fire rate enforcement  
- Ammo consumption  
- Weapon switching validation  
- Reload timing  
- Death state  

This eliminates prediction cheating and client authority.

---

## 4. Client Responsibilities

Client uses the same weapon definitions to:

- animate recoil  
- draw crosshair expansion  
- show weapon name  
- show ammo HUD  
- play sound/muzzle flash  
- predict local refire timing (cosmetic only)

Server may override predicted refire with snapshots.

---

## 5. Snapshot Data

Snapshot includes:

```ts
entity.weapon_state = {
  weapon_id: number,
  ammo_current: number,
  ammo_reserve: number,
  is_reloading: boolean,
}
Client mirrors this exactly.

6. Fire Request Flow
Client â†’ send fire request.

Server:

checks RPM

checks ammo

checks hit

applies damage

updates ammo

Snapshot â†’ client shows:

ammo

hitmarker

death state

7. Why Server Authoritative
Prevents exploited RPM

Consistent, fair damage

Predictable balancing

Multiplayer-safe

