====================================
FILE: \docs\00_index.md
====================================

#### `docs/00_index.md`
*New Index File*
```markdown
# bf42lite Documentation Index (v1.3)

Simplified modular documentation focusing on LAN gameplay and hybrid authority.

## ðŸ§­ Design
- [10_vision_core.md](./10_vision_core.md)
- [20_design_gameplay.md](./20_design_gameplay.md)
- [30_design_sim_arch.md](./30_design_sim_arch.md)

## ðŸŒ Networking
- [40_design_net_protocol.md](./40_design_net_protocol.md)

## ðŸ’» Client
- [50_design_client_rendering.md](./50_design_client_rendering.md)

## ðŸ—‚ Backlog
- [60_development_backlog.md](./60_development_backlog.md)

## âš™ï¸ Infrastructure
- [70_repo_structure.md](./70_repo_structure.md)

====================================
FILE: \docs\10_vision_core.md
====================================

# Vision & Core Goals (v1.3)

**Project:** bf42lite
**Genre:** LAN / Local Multiplayer FPS
**Inspiration:** Battlefield 1942
**Players:** 2â€“12 (MVP: 2â€“4)
**Platforms:** Windows (primary), Linux (AppImage), macOS (later)
**Engine Stack:** JS/TS (Client Physics) + Three.js + Tauri + Rust (Server State)

## Vision
Deliver fast and responsive LAN battles with smooth movement, readable visuals, and consistent state.
Use Client Authority for movement and aiming, while the server ensures consistent results for health, tickets, and confirmed hits.

## Core Principles
* **Client controls continuous physics** (movement, aiming).
* **Server controls all discrete game rules** (health, kills, scores).
* **Hits feel instant** (client prediction) but are reconciled by the server so all players see the same outcome.
* **Minimal setup:** single host, quick join.

## Focus
LAN gameplay (no anti-cheat, but full consistency). Updated for Client-Predicted, Server-Reconciled Hits.

====================================
FILE: \docs\20_design_gameplay.md
====================================

# Gameplay Design (v1.3)

## Core Loop
Host or join â†’ Spawn â†’ Move, shoot, capture flags â†’ Die and respawn â†’ Tickets or time expire.

## Modes
| Mode | Description | Phase |
| :--- | :--- | :--- |
| **Conquest** | Hold control points to drain enemy tickets. | 4+ |
| **Team DM** | Eliminate enemies; tickets = respawns. | 4+ |
| **Sandbox** | Physics/weapons testing. | 2+ |

## Classes (Later)
* **Assault, Engineer, Support, Recon** (light roles only).

## Weapons (Phases 2â€“4)
* Rifle, SMG, Sniper, Grenade.

## Maps
* **Warehouse (MVP)**
* **Island (Phase 5)**

====================================
FILE: \docs\30_design_sim_arch.md
====================================

# Simulation Architecture (v1.3)

The architecture explicitly avoids cross-language determinism by splitting continuous vs. discrete responsibilities.

## Authority Split
| Feature | Authority | Location | Reason |
| :--- | :--- | :--- | :--- |
| **Movement Physics** | Client | `packages/sim` (TS) | Instant input response. |
| **Collision (visual)** | Client | TS | Immediate feedback. |
| **Hit Detection (final)** | Server | Rust | Ensures both players see the same result. |
| **Health/Death** | Server | Rust | Centralized game rules. |
| **Scoring/Tickets** | Server | Rust | Consistent match flow. |
| **Rate Limits** | Server | Rust | Prevents accidental spam. |

## Hit Model: Predict + Reconcile
**Client**
1.  Performs raycast.
2.  Shows hit spark / marker immediately.
3.  Sends a fire proposal: `{ type: "fire", origin, direction, weaponId, clientTick }`

**Server**
1.  Re-runs the raycast using authoritative positions.
2.  Confirms if the hit is valid.
3.  Computes damage.
4.  Broadcasts a final event: `{ type: "hitConfirmed", shooterId, targetId, damage }`

*This avoids â€œI was behind cover on my screenâ€ even on LAN.*

## Determinism Rules
* **Client** runs fixed timestep (1/60).
* **Server** stores authoritative transforms from client reports.
* **Server** validates movement with simple checks (max speed, max teleport).
* **Server** performs only discrete logic (health, respawns, tickets).

====================================
FILE: \docs\40_design_net_protocol.md
====================================

# Networking Protocol (v1.3)

## Transport
* **UDP:** State updates (positions, rotations).
* **TCP/WebSocket:** Reliable events (joins, hits, killfeed, system messages).

## Message Structure

### Client â†’ Server
* **State Update:** `{ type: 'update', x, y, z, yaw }`
* **Fire Proposal:** `{ type: 'fire', origin, direction, weaponId, clientTick }`
* **Actions:** `{ type: 'respawn', classId }`, etc.

### Server â†’ Client
* **Snapshot:** `{ type: 'snapshot', entities: [...], scores, tickets }`
* **Hit Confirmation:** `{ type: 'hitConfirmed', shooterId, targetId, damage }`
* **Death Event:** `{ type: 'death', victimId, killerId }`

## Encoding
* `msgpackr` for binary transport.
* `zod` schemas for strict validation (`packages/protocol`).

## Snapshot Rate
Target: 10â€“20 Hz snapshots, client interpolates to 60 FPS.

====================================
FILE: \docs\50_design_client_rendering.md
====================================

# Client Rendering (v1.3)

## Tech
Three.js + React overlay.

## Interpolation
* **Local player:** Immediate (predicted).
* **Remote players:** Interpolated between last two snapshots for smoothness.

## Visual Style
* Low-poly, flat shading, readable silhouettes.
* Target 60 FPS on basic GPUs/APUs.

====================================
FILE: \docs\60_backlog_phase1_core_mvp.md
====================================

# Development Backlog (v1.3)

**Current Focus:** Phase 4 â€” Core Gameplay & Hit Reconciliation

## Phases
| Phase | Goal | Deliverables |
| :--- | :--- | :--- |
| **1** | Core MVP | Movement, ECS loop, glTF models |
| **2** | LAN Loopback | Host/join, basic messages |
| **3** | Visual Polish | Camera, HUD, map |
| **4** | Core Gameplay | Shooting, hit reconcile, death/respawn, tickets |
| **5** | Expansion | Vehicles, Island map, class roles |

## Phase 4 Acceptance Criteria
* [ ] Player movement is smooth on other clients via interpolation.
* [ ] Client proposes fire; server validates and confirms hits.
* [ ] Server applies damage, death, respawn logic.
* [ ] Tickets drain reliably and reach Game Over state.

====================================
FILE: \docs\70_repo_structure.md
====================================

# Infrastructure & Repo Layout (v1.4)

## Tree Overview

```text
bf42lite/
â”œâ”€â”€ .gitattributes
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ bf_42_lite_simplified_docs.md
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ pnpm-workspace.yaml
â”œâ”€â”€ tsconfig.base.json
â”œâ”€â”€ apps/
â”‚   â””â”€â”€ client-tauri/
â”‚       â”œâ”€â”€ src/          # TypeScript client: rendering, input, prediction
â”‚       â”œâ”€â”€ src-tauri/    # Rust host: state, validation, relay (inside the app)
â”‚       â”œâ”€â”€ public/       # Static assets (models, etc.)
â”‚       â””â”€â”€ dist/         # Built client bundle
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ sim/              # Shared ECS simulation: movement, health, etc.
â”‚   â”œâ”€â”€ net/              # Networking adapters (loopback, WebSocket)
â”‚   â”œâ”€â”€ protocol/         # Binary schemas and helpers
â”‚   â””â”€â”€ host-node/        # Dev-only Node host
â””â”€â”€ docs/                 # Modular design + backlog docs


====================================
FILE: \docs\80_backlog_phase2_expansion.md
====================================

Phase 2 expands bf42lite from infantry-only combat into a simplified combined-arms Battlefield-style game.
The goal is to introduce classes, vehicles, conquest mode, dynamic spawning, and a larger map while keeping all systems â€œLiteâ€ and manageable for a solo developer.

Purpose

Phase 2 introduces several major features:

â€¢ Lite classes
â€¢ Simplified vehicle framework
â€¢ Conquest game mode
â€¢ Dynamic spawnpoints
â€¢ Ticket bleed
â€¢ Stationary defenses
â€¢ Island-style combined-arms map

This phase also sets the foundation for future projects such as BF2Lite and BF2142Lite.

High-Level Deliverables

Gameplay:

Three infantry classes with simplified abilities.

Basic loadout system.

Vehicles:

GenericVehicle base class.

First vehicle: Tank using simplified hover-based movement.

Game Mode:

Conquest mode including capture points and capture progress.

Spawning:

Deploy screen allowing spawnpoint selection based on flag ownership.

Map:

Island map with flags, beaches, hills, and sea approach routes.

Balancing:

Ticket bleed based on majority flag ownership.

Stationary Defenses:

AA gun and coastal gun implemented as immobile vehicles.

Phase Breakdown

3.1. Conquest Core

Flag Zones:

Each flag has a capture radius and an ownership state.

Capture progress increases toward the team with more players inside the radius.

Progress stops if team counts are equal.

Dynamic Spawnpoints:

Each flag contains several spawnpoints.

When a team captures a flag, its spawnpoints become available to that team.

Ticket System Update:

Teams still lose a ticket when a player dies.

A team holding more than half the flags causes enemy tickets to drain slowly over time.

This component should be completed before vehicle work begins.

3.2. Lite Classes

Class Selection:

Added to Deploy Screen.

Loadouts assigned per class.

Grunt:

Primary weapon: SMG.

Ability: Heal aura activates if stationary for several seconds.

Heavy:

Primary weapon: Bazooka.

Ability: Wrench repairs friendly vehicles when used as melee.

Scout:

Primary weapon: Bolt-action rifle.

Ability: High-zoom mode for long-range aiming.

3.3. Vehicle Core Framework

Mount System:

Player enters vehicle with a key press.

Player model becomes hidden.

Camera attaches to vehicle seat.

Inputs are sent to the vehicle instead of the player character.

GenericVehicle Architecture:

Health value.

Seat definitions.

Movement model type (land, air, sea).

Weapon systems.

Spawn and respawn properties.

Tank (Land Vehicle):

Uses four downward raycasts to simulate hover-like suspension.

Remains upright at all times.

Independent turret and barrel rotation.

Slow but powerful movement and firing.

3.4. Additional Vehicle Units

Plane:

Always moves forward.

Pitch controlled by mouse vertical input.

Roll controlled by mouse horizontal input.

No stall system; simplified flight.

Boat:

Uses buoyancy to stay near water level.

Forward acceleration and slow turning.

Stationary Defenses:

Coastal gun with high-damage shell.

AA gun with high rate of fire.

Implemented as vehicles without movement.

Phase 2 Map: Island

Map Design Goals:

Large enough for vehicle combat.

Several flag zones (beach, hill, center).

Shoreline for boat landings.

Open sky for aircraft.

Areas for stationary defenses.

Technical Requirements

Physics:

VehicleController for all vehicles.

Hover simulation with raycasts.

Simplified buoyancy for boats.

Simplified pitch/roll flight model.

Networking:

Vehicle input messages from client to server.

Vehicle state included in snapshots.

Vehicles predicted locally with server reconciliation.

Rendering:

Cameras mounted to vehicle seats.

Turret rotation animations.

Optional visual effects for boats and planes.

UI:

Updated Deploy Screen with class and spawnpoint selection.

Indicators for flag ownership and capture progress.

Display for active vehicle seat.

Optional Stretch Goals

Infantry:

Grenade launcher for Heavy.

Smoke grenade for Scout.

Vehicles:

Jeep (fast, unarmored).

Transport boat.

Commander (Lite):

Single ability: artillery strike triggered by a marked location.

Acceptance Criteria

Phase 2 is complete when:

â€¢ Flags can be captured and ownership changes correctly.
â€¢ Ticket bleed works and can end a match.
â€¢ Class selection functions at spawn.
â€¢ Vehicles can be entered and exited consistently.
â€¢ Tank movement and firing are functional.
â€¢ Planes and boats operate with basic stability.
â€¢ Island map performs at or near 60 FPS.
â€¢ Multiple clients can play a full Conquest match from start to finish.

====================================
FILE: \docs\architecture_overview_v1_ascii.md
====================================

===========================================================
                    BF42LITE â€“ ARCHITECTURE
         (Where We Started â†’ Where We Are â†’ v1.0 Goal)
===========================================================


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. WHERE WE STARTED (Early Prototypes)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚     CLIENT (TS)          â”‚
                   â”‚  - movement logic        â”‚
                   â”‚  - prediction             â”‚
                   â”‚  - interpolation          â”‚
                   â”‚  - rendering              â”‚
                   â”‚  ALL in one place         â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â”‚ (mixed logic)
                                â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚  SERVER (Rust/Tauri)     â”‚
                   â”‚  - minimal movement      â”‚
                   â”‚  - basic combat          â”‚
                   â”‚  - hardcoded flags/maps  â”‚
                   â”‚  tightly coupled to UI   â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

       â€¢ Hard-coded gameplay rules everywhere  
       â€¢ Duplicate logic in TS + Rust  
       â€¢ No engine/game separation  
       â€¢ No package boundaries  
       â€¢ Legacy TS network code still in tree  



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2. WHERE WE ARE NOW (v0.4 Modular Client Baseline)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚           MONOREPO ROOT             â”‚
               â”‚  packages/   apps/   src-tauri/     â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                     TYPESCRIPT SIDE                     â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     packages/
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ @bf42lite/protocol    -> shared message schemas        â”‚
     â”‚ @bf42lite/net         -> WS/Tauri network adapters     â”‚
     â”‚ @bf42lite/engine-core -> generic ECS utilities         â”‚
     â”‚ @bf42lite/games-bf42  -> BF42 components/constants     â”‚
     â”‚ @bf42lite/sim         -> TS prediction sim (bitecs)    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     apps/client-tauri/
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ ClientGame (orchestrator)                              â”‚
     â”‚ Systems: prediction, interpolation, reconciler          â”‚
     â”‚ Renderer: Three.js scene, models, flags                 â”‚
     â”‚ Managers: InputManager, UIManager, NetworkManager       â”‚
     â”‚ HUDUpdater: single HUD authority                        â”‚
     â”‚ WorldRender: ECS â†’ render state                         â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                                  â”‚
                                  â–¼

     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                    RUST SIDE (Server)                   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     src-tauri/
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ Server tick loop                                        â”‚
     â”‚ systems/movement.rs                                     â”‚
     â”‚ systems/combat.rs                                       â”‚
     â”‚ systems/conquest.rs                                     â”‚
     â”‚ maps/warehouse.rs                                       â”‚
     â”‚ snapshot.rs (TickSnapshot builder)                      â”‚
     â”‚ player.rs / game_state.rs                               â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     â€¢ Server authoritative over:                             
       movement, combat, flags, tickets, respawn, match end   
     â€¢ Client predicts & reconciles                            
     â€¢ Snapshots drive rendering                               


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3. WHERE WE ARE GOING (v1.0 Target Architecture)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      CONFIG ASSETS          â”‚
                      â”‚  maps/*.toml                â”‚
                      â”‚  gamemodes/*.toml           â”‚
                      â”‚  weapons/*.toml             â”‚
                      â”‚  classes/*.toml             â”‚
                      â”‚  movement.toml              â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚  (data-driven)
                                      â–¼

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Rust Side â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

crates/
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  engine (WASM-ready)      â”‚  game-bf42 (rules)                       â”‚
â”‚  - ECS core               â”‚  - Conquest rules                        â”‚
â”‚  - math                   â”‚  - Weapon configs                        â”‚
â”‚  - physics                â”‚  - Movement parameters                   â”‚
â”‚  - WASM bindings          â”‚  - Map loading                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚  native
                â”‚
                â”‚ WASM
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚      CLIENT USES RUST SIM VIA WASM     â”‚
        â”‚     (prediction + reconciliation)       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TS Side (Final Form) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

packages/
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ @bf42lite/protocol   â†’ types only                                   â”‚
â”‚ @bf42lite/net        â†’ transport adapters                            â”‚
â”‚ @bf42lite/engine-coreâ†’ rendering helpers, TS ECS glue               â”‚
â”‚ @bf42lite/games-bf42 â†’ client-side components & visuals              â”‚
â”‚ @bf42lite/sim        â†’ becomes WASM wrapper over Rust sim            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

client-tauri/
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ UI, HUD, settings, Three.js renderer                                â”‚
â”‚ ClientGame orchestrates WASM sim + Renderer + Systems               â”‚
â”‚ No gameplay rules hardcoded                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4. FLOW SUMMARY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

                  SERVER (RUST)
             (authoritative simulation)
                         â”‚
                         â”‚ snapshots @ tick
                         â–¼
       CLIENT (TS + RUST/WASM sim for prediction)
                         â”‚
                         â”‚ input @ 30Hz
                         â–¼
                  SERVER (RUST)

Prediction â†’ Reconciliation â†’ Interpolation â†’ Rendering  
All gameplay rules resolved via **data configs**, not hardcoded.


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5. LONG-TERM EXTENSION LAYER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Vehicles â”‚ AI bots â”‚ New maps â”‚ Game modes â”‚ Zombie faction â”‚ Spotting â”‚ UI Themes  
All plug into the **game crate** + config files,  
NOT into the engine or the renderer.


===========================================================
END OF ASCII ARCHITECTURE OVERVIEW
===========================================================


====================================
FILE: \docs\frametime_and_tickrate.md
====================================

==============================

FRAMETIME \& TICKRATE (TXT)

==============================



bf42lite uses a classic networked-FPS timing model inspired by GoldSrc / Source, designed for predictable simulation, smooth rendering, and minimal input latency.



This document defines how frametime, tickrate, and snapshot frequency interact.



Key Concepts



FPS (Frames Per Second)

How many frames the client renders each second.

Typical targets for bf42lite presets:



Potato: 30 FPS



Medium: 90 FPS



High: 120 FPS



Frametime

The duration of one frame. Lower is better.

Examples:



30 FPS â†’ ~33ms



60 FPS â†’ ~16.6ms



90 FPS â†’ ~11.1ms



120 FPS â†’ ~8.3ms



Simulation Tick (Server Tickrate)

How often the server simulates and sends authoritative updates.

Example:



30 Hz tickrate â†’ simulation every 33ms



60 Hz tickrate â†’ simulation every 16.6ms



bf42lite aims for 60 Hz server simulation by default.



Snapshot Frequency

How often the server sends world snapshots to clients. Usually equal to tickrate unless throttled.



Interpolation

Client blends between snapshots to smooth movement. Prevents jitter.



Prediction

Client simulates its own player until an authoritative snapshot arrives.



High-Level Model



Server simulates at 60 Hz



Server sends snapshots at 60 Hz (or throttled to ~30 Hz for weak clients)



Client renders at independent FPS: 30 / 90 / 120 depending on preset



Client interpolates between snapshots



Client predicts local movement and corrects with reconciliation



This decouples rendering from simulation.



Why 60 Hz Simulation Is Chosen



Simple and stable timing (16.6ms steps)



Easy to interpolate to ANY render FPS (30, 60, 90, 120, 144)



Compatible with handhelds and midrange PCs



Keeps network bandwidth reasonable



GoldSrc, Source, Quake, Overwatch 1, TF2 all used similar logic



How Rendering Interacts With Tickrate



Rendering FPS is NOT required to match server tickrate.

Examples:



Case 1: 30 FPS (Potato) vs 60 Hz server



Render every 33ms



Interpolate between every 2 server ticks



Input latency increases, but gameplay stays predictable



Good for weak hardware



Case 2: 90 FPS (Steam Deck OLED) vs 60 Hz server



Render every 11ms



Smooth visual interpolation



Input sampled 3 times per simulation step



Very responsive handheld experience



Case 3: 120 FPS (PC) vs 60 Hz server



Render every ~8ms



High fluidity



Low input latency



Great for 120/144 Hz monitors



In all cases, gameplay correctness remains identical.



Recommended Snapshot Strategy



Default:



60 Hz snapshots for Medium and High presets



Fallback:



30 Hz snapshots for Potato preset (if bandwidth or CPU is restricted)



Client interpolation handles both cases smoothly.



Input Sampling



Client should sample inputs every render frame.

This means:



30 FPS preset samples input 30 times per second



90 FPS preset samples input 90 times per second



120 FPS preset samples input 120 times per second



Inputs are bundled and sent to the server at a fixed rate (e.g., 60 Hz).



Input latency is therefore tied more to frametime than to tickrate.



Reconciliation Loop



When a snapshot arrives:



Correct local player authoritative state



Reapply stored inputs (unacknowledged steps)



Fix visual errors via interpolation and smoothing



This ensures consistency across all three presets.



Frametime Stability



Stable frametime is more important than raw FPS.



A stable:



30 FPS (33ms)

feels better than a spiky:



45 â†’ 70 â†’ 50 â†’ 85 â†’ 40 FPS



Your 30/90/120 targets are chosen because:



They divide evenly into 60 Hz simulation



They match common screen refresh rates



They keep frametime stable and predictable



Summary of Target Rates



POTATO:



Render: 30 FPS



Server tick: 60 Hz



Snapshots: 30â€“60 Hz depending on bandwidth



Goal: keep frametime consistent for weak hardware



MEDIUM (Steam Deck OLED):



Render: 90 FPS



Server tick: 60 Hz



Snapshots: 60 Hz



Goal: extremely smooth handheld experience



HIGH (1080p PC):



Render: 120 FPS



Server tick: 60 Hz



Snapshots: 60 Hz



Goal: high responsiveness for 120/144 Hz players



====================================
FILE: \docs\graphics_scaling.md
====================================

==========================

GRAPHICS SCALING (TXT)

==========================



bf42lite uses three scalable presets: Potato (30 FPS), Medium (90 FPS), and High (120 FPS).

No postprocessing. All scaling is done using classic GoldSrc-style adjustments: geometry, textures, particles, and world detail.



Geometry and LOD



Potato:



Lowest LOD



Many props removed



Medium:



Medium LOD



All key props present



High:



Full detail LOD



All props + clutter



Textures



Potato:



256â€“512 max textures



Aggressive mip bias



Bilinear filtering



Medium:



512â€“1024 textures



Normal mip bias



Bilinear or trilinear



High:



1024 hero textures allowed



Trilinear filtering



Lighting



Potato:



Baked lightmaps only



No shadows or blob shadows



Very limited dynamic lights (~4)



Medium:



Baked lightmaps



Projected/blob shadows



More dynamic lights (~12)



High:



Baked lightmaps



Higher-res projected shadows



Many dynamic lights (~24)



Particles



Potato: Cap ~128



Minimal explosions



Short-lived smoke



Simplified tracers



Medium: Cap ~256â€“512



Standard explosions



Persistent but capped smoke



Normal tracers



High: Cap ~512â€“1024



Large explosions



Dense debris and persistent smoke



Full tracer density



Decals (bullet holes, impacts)



Potato: ~32 decals cap, aggressive fade

Medium: ~128 decals cap, normal fade

High: ~256â€“512 decals cap, slow fade



Ragdolls



Potato: 0â€“1, very short lifetime

Medium: 3â€“4, medium lifetime

High: 6â€“8, long lifetime



Props and World Detail



Potato: minimal foliage, minimal debris

Medium: full intended props

High: full props + clutter meshes



Audio Scaling



Potato: ~16 voices

Medium: 48â€“64 voices

High: 64â€“96 voices



Simulation / Network Considerations



Preset does NOT affect tickrate.

Only visual density and GPU load scale across presets.



====================================
FILE: \docs\performance_presets.md
====================================

==========================

PERFORMANCE PRESETS (TXT)

==========================



bf42lite â€“ GoldSrc-inspired, no postprocessing

Three presets based on target hardware and refresh-rate goals.



PRESETS:



POTATO â†’ 30 FPS



MEDIUM â†’ 90 FPS



HIGH â†’ 120 FPS



PRESET: POTATO (30 FPS target)



Target hardware:



Very old iGPUs (Intel HD 500)



Low-end Chromebooks



Old preowned PCs



Resolution:



720p



FPS Target:



30 FPS stable (half of 60 Hz)



Shadows:



None or simple blob



Textures:



Low resolution (256â€“512 max)



Geometry / Props:



Lowest LODs



Many props removed to reduce draw calls



Particles:



Cap ~128 total



Decals:



Cap ~32 total



Ragdolls:



0 to 1 active at once



Dynamic lights:



Roughly 4 active lights



Notes:



Pure fallback mode for very weak systems



Ensures game is still playable even at minimal hardware



PRESET: MEDIUM (90 FPS target â€“ Steam Deck OLED)



Target hardware:



Steam Deck OLED (90 Hz)



Lowâ€“mid PCs and handheld devices



Resolution:



1280x800



FPS Target:



90 FPS stable



Shadows:



Cheap blob or projected shadows



Textures:



Medium resolution (512â€“1024)



Geometry / Props:



Full low-poly world



All intended props present



Particles:



Cap roughly 256 to 512



Decals:



Cap around 128



Ragdolls:



3 to 4 active



Dynamic lights:



Around 12 active lights



Notes:



Primary design preset



Smooth handheld experience designed for the 90 Hz OLED screen



PRESET: HIGH (120 FPS target â€“ Midrange PC)



Target hardware:



Midrange gaming PCs (RTX 3060 / RX 6600 / 2060 class)



Resolution:



1080p



FPS Target:



120 FPS (never below 60)



Shadows:



Higher-quality projected shadows



Textures:



Mediumâ€“High (1024 for hero assets)



Geometry / Props:



Full detail, clutter included



Particles:



Cap ~512 to 1024



Decals:



Cap ~256 to 512



Ragdolls:



6 to 8 active



Dynamic lights:



Around 24 active lights



Notes:



Designed for 120â€“144 Hz desktop monitors



Smooth, high-end PC experience



Preset Summary (TXT Form)



POTATO â€“ 30 FPS â€“ 720p â€“ weak hardware

MEDIUM â€“ 90 FPS â€“ 1280x800 â€“ Steam Deck OLED

HIGH â€“ 120 FPS â€“ 1080p â€“ midrange PCs



