====================================
FILE: \packages\net\package.json
====================================

{
  "name": "@bf42lite/net",
  "version": "1.3.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc -b",
    "dev": "tsc -b -w"
  },
  "dependencies": {
    "@bf42lite/protocol": "workspace:*",
    "msgpackr": "^1.10.0"
  },
  "devDependencies": {
    "@types/node": "^24.10.1",
    "typescript": "^5.0.0"
  }
}


====================================
FILE: \packages\net\tsconfig.json
====================================

{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "composite": true,
    "skipLibCheck": true,
    "types": ["node"]
  },
  "include": ["src"]
}


====================================
FILE: \packages\net\src\index.ts
====================================

export * from './types';
export * from './WebSocketAdapter';
export * from './LoopbackAdapter';

====================================
FILE: \packages\net\src\LoopbackAdapter.ts
====================================

import { NetworkAdapter, NetworkStats } from './types';
import { ClientMessage, ServerMessage } from '@bf42lite/protocol';

export class LoopbackAdapter implements NetworkAdapter {
  private connected = false;
  private peer: LoopbackAdapter | null = null;
  
  private onMsgCallbacks: ((msg: any) => void)[] = [];
  private onConnectCallbacks: (() => void)[] = [];
  
  public latencyMs = 0; 

  constructor() {}

  static pair(): [LoopbackAdapter, LoopbackAdapter] {
    const a = new LoopbackAdapter();
    const b = new LoopbackAdapter();
    a.peer = b;
    b.peer = a;
    return [a, b];
  }

  async connect(_url: string): Promise<void> {
    setTimeout(() => {
      this.connected = true;
      this.onConnectCallbacks.forEach(cb => cb());
    }, 10);
  }

  disconnect() {
    this.connected = false;
  }

  isConnected() { return this.connected; }

  send(msg: ClientMessage | ServerMessage) {
    const peer = this.peer; // Capture locally to satisfy TS in setTimeout
    if (!peer) return;
    
    const data = JSON.parse(JSON.stringify(msg));

    if (this.latencyMs > 0) {
      setTimeout(() => peer.receive(data), this.latencyMs);
    } else {
      peer.receive(data);
    }
  }

  private receive(msg: any) {
    if (this.connected) {
      this.onMsgCallbacks.forEach(cb => cb(msg));
    }
  }

  onMessage(cb: (msg: any) => void) { this.onMsgCallbacks.push(cb); }
  onConnect(cb: () => void) { this.onConnectCallbacks.push(cb); }
  onDisconnect(_cb: (reason?: string) => void) {}
  
  getStats(): NetworkStats {
    return { rtt: 0, loss: 0, bytesIn: 0, bytesOut: 0 };
  }
}

====================================
FILE: \packages\net\src\types.ts
====================================

import { ClientMessage, ServerMessage } from '@bf42lite/protocol';

export interface NetworkStats {
  rtt: number;      // Round Trip Time (ms)
  loss: number;     // Packet loss % (simulated or real)
  bytesIn: number;
  bytesOut: number;
}

export interface NetworkAdapter {
  // Connection Management
  connect(url: string): Promise<void>;
  disconnect(): void;
  isConnected(): boolean;

  // Messaging
  send(msg: ClientMessage): void;
  
  // Event Listeners
  onMessage(callback: (msg: ServerMessage) => void): void;
  onConnect(callback: () => void): void;
  onDisconnect(callback: (reason?: string) => void): void;

  // Diagnostics
  getStats(): NetworkStats;
}

====================================
FILE: \packages\net\src\WebSocketAdapter.ts
====================================

import { NetworkAdapter, NetworkStats } from './types';
import { pack, unpack } from 'msgpackr';
import { ClientMessage, ServerMessage } from '@bf42lite/protocol';

export class WebSocketAdapter implements NetworkAdapter {
  private socket: WebSocket | null = null;
  private handlers = {
    message: [] as ((msg: ServerMessage) => void)[],
    connect: [] as (() => void)[],
    disconnect: [] as ((reason?: string) => void)[]
  };
  
  private stats: NetworkStats = { rtt: 0, loss: 0, bytesIn: 0, bytesOut: 0 };

  isConnected(): boolean {
    return this.socket?.readyState === WebSocket.OPEN;
  }

  async connect(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.socket = new WebSocket(url);
      this.socket.binaryType = 'arraybuffer';

      this.socket.onopen = () => {
        console.log(`[Net] Connected to ${url}`);
        this.handlers.connect.forEach(cb => cb());
        resolve();
      };

      this.socket.onerror = (err) => {
        console.error('[Net] Connection Error', err);
        if (this.socket?.readyState !== WebSocket.OPEN) {
          reject(err);
        }
      };

      this.socket.onclose = (event) => {
        console.log('[Net] Disconnected', event.reason);
        this.handlers.disconnect.forEach(cb => cb(event.reason));
      };

      this.socket.onmessage = (event) => {
        try {
          const data = new Uint8Array(event.data as ArrayBuffer);
          this.stats.bytesIn += data.byteLength;
          
          // Decode Binary -> Object
          const msg = unpack(data) as ServerMessage;
          
          this.handlers.message.forEach(cb => cb(msg));
        } catch (e) {
          console.error('[Net] Failed to decode message', e);
        }
      };
    });
  }

  disconnect(): void {
    this.socket?.close();
  }

  send(msg: ClientMessage): void {
    if (!this.isConnected()) return;

    // Encode Object -> Binary
    const data = pack(msg);
    this.stats.bytesOut += data.byteLength;
    
    this.socket?.send(data);
  }

  onMessage(cb: (msg: ServerMessage) => void) { this.handlers.message.push(cb); }
  onConnect(cb: () => void) { this.handlers.connect.push(cb); }
  onDisconnect(cb: (reason?: string) => void) { this.handlers.disconnect.push(cb); }

  getStats() { return this.stats; }
}

