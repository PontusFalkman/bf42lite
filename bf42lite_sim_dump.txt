====================================
FILE: \packages\sim\package.json
====================================

{
  "name": "@bf42lite/sim",
  "version": "1.3.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc -b",
    "dev": "tsc -b -w"
  },
  "dependencies": {
    "bitecs": "^0.3.40"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}


====================================
FILE: \packages\sim\tsconfig.json
====================================

{
    "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "composite": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}


====================================
FILE: \packages\sim\src\components.d.ts
====================================

import { IWorld } from 'bitecs';
export declare const Vector3: {
    x: "f32";
    y: "f32";
    z: "f32";
};
export declare const Transform: import("bitecs").ComponentType<{
    rotation: "f32";
    x: "f32";
    y: "f32";
    z: "f32";
}>;
export declare const Velocity: import("bitecs").ComponentType<{
    x: "f32";
    y: "f32";
    z: "f32";
}>;
export declare const InputState: import("bitecs").ComponentType<{
    moveX: "f32";
    moveY: "f32";
    viewX: "f32";
    viewY: "f32";
    buttons: "ui32";
    lastTick: "ui32";
}>;
export declare const Me: import("bitecs").ComponentType<import("bitecs").ISchema>;
export interface SimWorld extends IWorld {
    time: number;
    dt: number;
    [key: string]: any;
}


====================================
FILE: \packages\sim\src\components.js
====================================

import { defineComponent, Types } from 'bitecs';
// --- CORE ENGINE COMPONENTS ---
export const Vector3 = { x: Types.f32, y: Types.f32, z: Types.f32 };
export const Transform = defineComponent({
    ...Vector3,
    rotation: Types.f32 // Y-axis rotation (Yaw)
});
export const Velocity = defineComponent(Vector3);
// Generic Input: The Engine doesn't care what "Button 1" does.
// It just knows the button is pressed.
export const InputState = defineComponent({
    moveX: Types.f32, // WASD / Left Stick X
    moveY: Types.f32, // WASD / Left Stick Y
    viewX: Types.f32, // Mouse X / Right Stick X
    viewY: Types.f32, // Mouse Y / Right Stick Y
    buttons: Types.ui32, // Bitmask for actions (Jump, Fire, Reload, Enter Vehicle)
    lastTick: Types.ui32
});
// Tags
export const Me = defineComponent(); // Local player authority


====================================
FILE: \packages\sim\src\components.ts
====================================

import { defineComponent, Types, IWorld } from 'bitecs';

// --- CORE ENGINE COMPONENTS ---

export const Vector3 = { x: Types.f32, y: Types.f32, z: Types.f32 };

export const Transform = defineComponent({
  ...Vector3,
  rotation: Types.f32 // Y-axis rotation (Yaw)
});

export const Velocity = defineComponent(Vector3);

// Generic Input: The Engine doesn't care what "Button 1" does.
// It just knows the button is pressed.
export const InputState = defineComponent({
  moveX: Types.f32,    // WASD / Left Stick X
  moveY: Types.f32,    // WASD / Left Stick Y
  viewX: Types.f32,    // Mouse X / Right Stick X
  viewY: Types.f32,    // Mouse Y / Right Stick Y
  buttons: Types.ui32, // Bitmask for actions (Jump, Fire, Reload, Enter Vehicle)
  lastTick: Types.ui32
});

// Tags
export const Me = defineComponent(); // Local player authority

// The Simulation World Contract
export interface SimWorld extends IWorld {
  time: number;
  dt: number;
  // The engine doesn't know about 'tickets', but it allows
  // modules to attach arbitrary data if needed.
  [key: string]: any; 
}

====================================
FILE: \packages\sim\src\index.d.ts
====================================

import { createWorld, addEntity, removeEntity, addComponent, pipe, defineQuery } from 'bitecs';
import { SimWorld } from './components';
export { addEntity, removeEntity, addComponent, createWorld, pipe, defineQuery };
export * from './components';
export * from './systems/movement';
export type System = (world: SimWorld) => SimWorld;
export type SystemFactory = () => System;
export declare const createSimulation: (gameSystems?: SystemFactory[]) => {
    world: SimWorld;
    step: (dt: number) => void;
};


====================================
FILE: \packages\sim\src\index.js
====================================

import { createWorld, addEntity, removeEntity, addComponent, pipe, defineQuery } from 'bitecs';
import { createMovementSystem } from './systems/movement';
export { addEntity, removeEntity, addComponent, createWorld, pipe, defineQuery };
export * from './components';
export * from './systems/movement';
export const createSimulation = (gameSystems = []) => {
    const world = createWorld();
    world.time = 0;
    world.dt = 1 / 60;
    const coreSystems = [
        createMovementSystem()
    ];
    const pipeline = pipe(...coreSystems, ...gameSystems.map(create => create()));
    const step = (dt) => {
        world.dt = dt;
        world.time += dt;
        pipeline(world);
    };
    return { world, step };
};


====================================
FILE: \packages\sim\src\index.ts
====================================

import { createWorld, addEntity, removeEntity, addComponent, pipe, defineQuery, IWorld } from 'bitecs';
import { SimWorld } from './components';
import { createMovementSystem } from './systems/movement';

export { addEntity, removeEntity, addComponent, createWorld, pipe, defineQuery };
export * from './components';
export * from './systems/movement';

// FIX: Define the System type manually since bitecs might not export ISystem
export type System = (world: SimWorld) => SimWorld;
export type SystemFactory = () => System;

export const createSimulation = (gameSystems: SystemFactory[] = []) => {
  const world = createWorld() as SimWorld;
  world.time = 0;
  world.dt = 1 / 60;

  const coreSystems = [
    createMovementSystem() 
  ];

  const pipeline = pipe(
    ...coreSystems,
    ...gameSystems.map(create => create())
  );

  const step = (dt: number) => {
    world.dt = dt;
    world.time += dt;
    pipeline(world);
  };

  return { world, step };
};

====================================
FILE: \packages\sim\src\systems\health.ts
====================================


====================================
FILE: \packages\sim\src\systems\movement.d.ts
====================================

import { SimWorld } from '../components';
export declare const MOVEMENT_CONSTANTS: {
    MOVE_SPEED: number;
    AIR_SPEED_FACTOR: number;
    GRAVITY: number;
    JUMP_FORCE: number;
};
export declare const MOVEMENT_VERSION = "movement-v1.0.0";
export declare const createMovementSystem: () => import("bitecs").System<[], SimWorld>;


====================================
FILE: \packages\sim\src\systems\movement.js
====================================

import { defineSystem, defineQuery } from 'bitecs';
import { Transform, Velocity, InputState } from '../components';
// --- TUNING ---
const MOVE_SPEED = 10.0;
const AIR_SPEED_FACTOR = 0.6; // New: 60% control when airborne (adds weight)
const GRAVITY = -25.0; // New: Snappier gravity (was -20)
const JUMP_FORCE = 9.0; // New: Higher jump to match gravity
const GROUND_TOLERANCE = 0.05; // New: Forgiving check (was 0.001)
const BUTTON_JUMP = 1;
export const MOVEMENT_CONSTANTS = {
    MOVE_SPEED: 10.0,
    AIR_SPEED_FACTOR: 0.6,
    GRAVITY: -25.0,
    JUMP_FORCE: 9.0,
    // ...
};
export const MOVEMENT_VERSION = "movement-v1.0.0";
console.log("Client movement version:", MOVEMENT_VERSION);
export const createMovementSystem = () => {
    const query = defineQuery([Transform, Velocity, InputState]);
    return defineSystem((world) => {
        const dt = world.dt;
        const entities = query(world);
        for (let i = 0; i < entities.length; ++i) {
            const id = entities[i];
            // 1. GROUND CHECK
            // We use a larger tolerance so we don't miss jumps due to micro-floating
            // TODO: Later, replace this with a raycast for platforms/terrain
            const isGrounded = Transform.y[id] <= GROUND_TOLERANCE;
            // 2. APPLY ROTATION
            Transform.rotation[id] = InputState.viewX[id];
            // 3. CALCULATE MOVEMENT
            // Reduce speed if in the air for better "physics feel"
            const speed = isGrounded ? MOVE_SPEED : (MOVE_SPEED * AIR_SPEED_FACTOR);
            const forward = -InputState.moveY[id]; // W = +1 (forward), S = -1 (backward)
            const right = InputState.moveX[id]; // A/D
            const yaw = Transform.rotation[id];
            const sin = Math.sin(yaw);
            const cos = Math.cos(yaw);
            // Match server basis exactly:
            // forward: (sin, cos)
            // right:   (cos, -sin)
            const vecFwdX = sin;
            const vecFwdZ = cos;
            const vecRightX = cos;
            const vecRightZ = -sin;
            const dx = vecFwdX * forward + vecRightX * right;
            const dz = vecFwdZ * forward + vecRightZ * right;
            Velocity.x[id] = dx * speed;
            Velocity.z[id] = dz * speed;
            // 4. GRAVITY & JUMPING
            Velocity.y[id] += GRAVITY * dt;
            const wantsJump = (InputState.buttons[id] & BUTTON_JUMP) !== 0;
            if (isGrounded && wantsJump) {
                // Only allow jump if not already shooting up (prevents double-force glitches)
                if (Velocity.y[id] <= 0.1) {
                    Velocity.y[id] = JUMP_FORCE;
                }
            }
            // 5. INTEGRATE POSITION
            Transform.x[id] += Velocity.x[id] * dt;
            Transform.z[id] += Velocity.z[id] * dt;
            Transform.y[id] += Velocity.y[id] * dt;
            // 6. FLOOR COLLISION
            // Hard constraint to keep us on the map
            if (Transform.y[id] < 0) {
                Transform.y[id] = 0;
                // If we were falling, stop. 
                // If we just jumped (Vel > 0), let it happen!
                if (Velocity.y[id] < 0) {
                    Velocity.y[id] = 0;
                }
            }
        }
        return world;
    });
};


====================================
FILE: \packages\sim\src\systems\movement.ts
====================================

import { defineSystem, defineQuery } from 'bitecs';
import { Transform, Velocity, InputState, SimWorld } from '../components';

// --- TUNING ---
const MOVE_SPEED = 10.0;
const AIR_SPEED_FACTOR = 0.6; // New: 60% control when airborne (adds weight)
const GRAVITY = -25.0;        // New: Snappier gravity (was -20)
const JUMP_FORCE = 9.0;       // New: Higher jump to match gravity
const GROUND_TOLERANCE = 0.05;// New: Forgiving check (was 0.001)

const BUTTON_JUMP = 1; 
export const MOVEMENT_CONSTANTS = {
  MOVE_SPEED: 10.0,
  AIR_SPEED_FACTOR: 0.6,
  GRAVITY: -25.0,
  JUMP_FORCE: 9.0,
  // ...
};
export const MOVEMENT_VERSION = "movement-v1.0.0";
console.log("Client movement version:", MOVEMENT_VERSION);

export const createMovementSystem = () => {
  const query = defineQuery([Transform, Velocity, InputState]);

  return defineSystem((world: SimWorld) => {
    const dt = world.dt;
    const entities = query(world);

    for (let i = 0; i < entities.length; ++i) {
      const id = entities[i];

      // 1. GROUND CHECK
      // We use a larger tolerance so we don't miss jumps due to micro-floating
      // TODO: Later, replace this with a raycast for platforms/terrain
      const isGrounded = Transform.y[id] <= GROUND_TOLERANCE;

      // 2. APPLY ROTATION
      Transform.rotation[id] = InputState.viewX[id];

      // 3. CALCULATE MOVEMENT
      // Reduce speed if in the air for better "physics feel"
      const speed = isGrounded ? MOVE_SPEED : (MOVE_SPEED * AIR_SPEED_FACTOR);

      const forward = -InputState.moveY[id]; // W = +1 (forward), S = -1 (backward)
      const right   = InputState.moveX[id]; // A/D
      
      const yaw = Transform.rotation[id];
      const sin = Math.sin(yaw);
      const cos = Math.cos(yaw);

// Match server basis exactly:
// forward: (sin, cos)
// right:   (cos, -sin)
const vecFwdX   = sin;
const vecFwdZ   = cos;
const vecRightX = cos;
const vecRightZ = -sin;

const dx = vecFwdX * forward + vecRightX * right;
const dz = vecFwdZ * forward + vecRightZ * right;

      Velocity.x[id] = dx * speed;
      Velocity.z[id] = dz * speed;

      // 4. GRAVITY & JUMPING
      Velocity.y[id] += GRAVITY * dt;

      const wantsJump = (InputState.buttons[id] & BUTTON_JUMP) !== 0;

      if (isGrounded && wantsJump) {
        // Only allow jump if not already shooting up (prevents double-force glitches)
        if (Velocity.y[id] <= 0.1) {
            Velocity.y[id] = JUMP_FORCE;
        }
      }

      // 5. INTEGRATE POSITION
      Transform.x[id] += Velocity.x[id] * dt;
      Transform.z[id] += Velocity.z[id] * dt;
      Transform.y[id] += Velocity.y[id] * dt;

      // 6. FLOOR COLLISION
      // Hard constraint to keep us on the map
      if (Transform.y[id] < 0) {
        Transform.y[id] = 0;
        
        // If we were falling, stop. 
        // If we just jumped (Vel > 0), let it happen!
        if (Velocity.y[id] < 0) {
            Velocity.y[id] = 0;
        }
      }
    }
    return world;
  });
};

