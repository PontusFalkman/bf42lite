===============================
 DUMP FOR: apps/client-tauri/src
===============================

---------- DIRECTORY TREE ----------

Folder PATH listing for volume New Volume
Volume serial number is BC16-B8E7
D:\BF42LITE\APPS\CLIENT-TAURI\SRC
ª   main.ts
ª   
+---core
ª       ClientGame.ts
ª       FlagRenderer.ts
ª       InputManager.ts
ª       Renderer.ts
ª       WeaponSystem.ts
ª       
+---managers
ª       NetworkManager.ts
ª       UIManager.ts
ª       
+---systems
        handleSnapshot.ts
        Reconciler.ts
        updateGameFrame.ts
        

---------- FILE CONTENTS ----------

## FILE: apps\client-tauri\src\main.ts
---------------------------
import { ClientGame } from './core/ClientGame';

// Prevent context menu
document.addEventListener('contextmenu', event => event.preventDefault());

console.log("Starting bf42lite Client...");
const game = new ClientGame();
game.start();


## FILE: apps\client-tauri\src\core\ClientGame.ts
---------------------------
import {
    createSimulation,
    Transform,
    Velocity,
    InputState,
    Me,
    addComponent,
    addEntity,
    defineQuery,
    createMovementSystem,
  } from '@bf42lite/engine-core';
  import {
    Health,
    Ammo,
    Soldier,
    Team,
    CapturePoint,
    Loadout,
  } from '@bf42lite/games-bf42';
  import { Renderer } from './Renderer';
  import { NetworkManager } from '../managers/NetworkManager';
  import { InputManager } from './InputManager';
  import { UIManager } from '../managers/UIManager';
  import { WeaponSystem } from './WeaponSystem';
  import { Reconciler } from '../systems/Reconciler';
  import { handleSnapshot } from '../systems/handleSnapshot';
  import { updateGameFrame } from '../systems/updateGameFrame';
  import { FlagRenderer } from './FlagRenderer';
  import { Snapshot, FlagSnapshot } from '@bf42lite/protocol';
  
  export class ClientGame {
    private movementSystem = createMovementSystem();
    private sim = createSimulation();
    private flagRenderer: FlagRenderer;
    private flags: FlagSnapshot[] = [];
  
    private renderer: Renderer;
    private net: NetworkManager;
    private input: InputManager;
    private ui: UIManager;
    private weaponSystem: WeaponSystem;
    private reconciler: Reconciler;
  
    private localEntityId: number = -1;
    private running: boolean = false;
    private lastFrameTime: number = 0;
    private currentTick: number = 0;
    private currentFps: number = 0;
    private lastRtt: number = 0;
  
    private sendAccumulator: number = 0;
    private readonly SEND_INTERVAL = 1 / 30;
    private readonly INTERPOLATION_DELAY_MS = 100;
  
    private playerQuery = defineQuery([Transform, Soldier]);
    private flagQuery = defineQuery([CapturePoint, Transform]);
  
    constructor() {
      this.renderer = new Renderer();
      this.net = new NetworkManager();
      this.input = new InputManager();
      this.reconciler = new Reconciler();
  
      // Conquest flag renderer (uses the main THREE.Scene from Renderer)
      this.flagRenderer = new FlagRenderer(this.renderer.getScene());
  
      // UI + class selection wiring
      this.input.setInteraction(false);
      this.weaponSystem = new WeaponSystem(this.renderer, this.net);
      this.ui = new UIManager((classId: number) => {
        console.log(`Spawn requested with Class ID: ${classId}`);
        this.net.sendSpawnRequest(classId);
        this.weaponSystem.setClass(classId);
      });
      this.input.setInteraction(true);
  
      this.initNetworkCallbacks();
      this.net.connect('ws://localhost:8080');
  
      this.createLocalPlayer();
    }
  
    private createLocalPlayer() {
      this.localEntityId = addEntity(this.sim.world);
  
      addComponent(this.sim.world, Transform, this.localEntityId);
      addComponent(this.sim.world, Velocity, this.localEntityId);
      addComponent(this.sim.world, InputState, this.localEntityId);
      addComponent(this.sim.world, Me, this.localEntityId);
  
      addComponent(this.sim.world, Health, this.localEntityId);
      addComponent(this.sim.world, Ammo, this.localEntityId);
      addComponent(this.sim.world, Soldier, this.localEntityId);
      addComponent(this.sim.world, Team, this.localEntityId);
      addComponent(this.sim.world, Loadout, this.localEntityId);
    }
  
    private initNetworkCallbacks() {
      this.net.onConnected = () => {
        console.log('Connected to server');
      };
  
      this.net.onDisconnected = () => {
        console.log('Disconnected from server');
      };
  
      this.net.onSnapshot = (msg: Snapshot) => {
        // Centralized snapshot handling: entities, tickets, game over, etc.
        handleSnapshot(msg, this.sim.world, this.renderer, this.net, this.ui);
  
        // --- Conquest flags ---
        this.flags = msg.flags ?? [];
        this.flagRenderer.updateFromSnapshot(this.flags);
  
        // --- Local player sync (restored) ---
        const myServerEntity = msg.entities.find(
          (e: any) => this.net.getLocalId(e.id) === this.localEntityId,
        );
  
        if (myServerEntity) {
          const wasDead = Health.isDead[this.localEntityId] === 1;
          const isNowDead = !!myServerEntity.isDead;
  
          // Teleport on respawn to avoid smoothing artifacts
          if (wasDead && !isNowDead && myServerEntity.pos) {
            this.reconciler.clearHistory();
            Transform.x[this.localEntityId] = myServerEntity.pos.x;
            Transform.y[this.localEntityId] = myServerEntity.pos.y;
            Transform.z[this.localEntityId] = myServerEntity.pos.z;
          }
  
          // Health + death state
// Health + death state.
// Protocol now sends health as a plain number.
const hp =
  typeof myServerEntity.health === 'number'
    ? myServerEntity.health
    : 100;

Health.current[this.localEntityId] = hp;
Health.isDead[this.localEntityId] = isNowDead ? 1 : 0;
this.ui.updateRespawn(isNowDead, myServerEntity.respawnTimer || 0);


  
          // Team
          if (myServerEntity.team) {
            Team.id[this.localEntityId] =
              myServerEntity.team.id === 'TeamA' ? 1 : 2;
          }
  
          // Loadout / class
          if (myServerEntity.loadout) {
            Loadout.classId[this.localEntityId] = myServerEntity.loadout.classId;
          }
  
          // Ammo + weapon UI
          const WEAPON_NAMES = { 0: 'THOMPSON', 1: 'MP40', 2: 'KAR98K' } as const;
          const myClassId = Loadout.classId[this.localEntityId] || 0;
          const name = WEAPON_NAMES[myClassId as keyof typeof WEAPON_NAMES];
  
          if (myServerEntity.ammo) {
            this.ui.updateAmmo(
              myServerEntity.ammo.current,
              myServerEntity.ammo.reserve,
              name,
            );
          }
  
          // Reconciliation (movement correction)
          if (myServerEntity.lastProcessedTick !== undefined) {
            const rtt = this.reconciler.reconcile(
              myServerEntity.lastProcessedTick,
              myServerEntity,
              this.localEntityId,
              this.sim.world,
              this.movementSystem,
            );
            if (rtt > 0) this.lastRtt = rtt;
          }
        }
      };
    }
  
    public start() {
      if (this.running) return;
      this.running = true;
      this.lastFrameTime = performance.now();
      requestAnimationFrame(this.loop);
    }
  
    public stop() {
      this.running = false;
    }
  
    private loop = (now: number) => {
      if (!this.running) return;
      requestAnimationFrame(this.loop);
  
      const dt = (now - this.lastFrameTime) / 1000;
      this.lastFrameTime = now;
      if (dt > 0) this.currentFps = Math.round(1 / dt);
  
      // Per-frame input + sim + movement
      const cmd = updateGameFrame(
        dt,
        this.currentTick,
        this.localEntityId,
        this.sim.world,
        this.input,
        this.movementSystem,
      );
  
      // Prediction history
      if (this.localEntityId >= 0 && cmd) {
        this.reconciler.pushHistory(
          this.currentTick,
          cmd,
          Transform.x[this.localEntityId],
          Transform.y[this.localEntityId],
          Transform.z[this.localEntityId],
        );
      }
  
      // Throttled input send
      this.sendAccumulator += dt;
      while (this.sendAccumulator >= this.SEND_INTERVAL) {
        if (cmd) {
          this.net.send(cmd);
        }
        this.sendAccumulator -= this.SEND_INTERVAL;
      }
  
      // Weapons + interpolation
      this.weaponSystem.update(dt, this.localEntityId, this.currentTick);
      this.currentTick++;
      this.net.interpolateRemotePlayers(now - this.INTERPOLATION_DELAY_MS);
  
      this.updateRenderAndUI();
    };
  
    private updateRenderAndUI() {
      this.ui.updateStats(this.currentFps, this.lastRtt);
      if (this.localEntityId >= 0) {
        this.ui.updateHealth(Health.current[this.localEntityId]);
      }
  
      // Render Players
      const players = this.playerQuery(this.sim.world);
      for (const eid of players) {
        const isMe = eid === this.localEntityId;
        const state = {
          type: 'player' as const,
          pos: {
            x: Transform.x[eid],
            y: Transform.y[eid],
            z: Transform.z[eid],
          },
          rot: Transform.rotation[eid],
          pitch: isMe ? InputState.viewY[eid] : 0,
          team: Team.id[eid],
        };
        this.renderer.updateEntity(eid, state, isMe);
      }
  
      // Render ECS capture points (if still used)
      const flags = this.flagQuery(this.sim.world);
      for (const eid of flags) {
        const state = {
          type: 'flag' as const,
          pos: {
            x: Transform.x[eid],
            y: Transform.y[eid],
            z: Transform.z[eid],
          },
          rot: 0,
          team: CapturePoint.team[eid],
          progress: CapturePoint.progress[eid],
        };
        this.renderer.updateEntity(eid, state, false);
      }
  
      this.renderer.render();
    }
  }
  

## FILE: apps\client-tauri\src\core\FlagRenderer.ts
---------------------------
// src/core/FlagRenderer.ts
import * as THREE from 'three';
import { FlagSnapshot } from '@bf42lite/protocol';

export class FlagRenderer {
  private scene: THREE.Scene;
  private flags = new Map<number, THREE.Object3D>();

  constructor(scene: THREE.Scene) {
    this.scene = scene;
  }

  /**
   * Update or create flag meshes from the latest snapshot.
   */
  updateFromSnapshot(flags: FlagSnapshot[]): void {
    const seen = new Set<number>();

    for (const f of flags) {
      let group = this.flags.get(f.id);
      if (!group) {
        group = this.createFlagMesh(f);
        this.scene.add(group);
        this.flags.set(f.id, group);
      }

      this.updateFlagTransform(group, f);
      this.updateFlagOwner(group, f.owner);
      this.setCaptureProgress(group, this.captureTo01(f.capture));
      seen.add(f.id);
    }

    // Remove any flags that are no longer present.
    for (const [id, obj] of this.flags) {
      if (!seen.has(id)) {
        this.scene.remove(obj);
        this.flags.delete(id);
      }
    }
  }

  /**
   * Convert capture value (-1..1) to 0..1.
   *  0.0 => full Team B
   *  0.5 => neutral
   *  1.0 => full Team A
   */
  private captureTo01(capture: number): number {
    const c = Math.max(-1, Math.min(1, capture));
    return (c + 1) * 0.5;
  }

  private createFlagMesh(flag: FlagSnapshot): THREE.Object3D {
    const group = new THREE.Group();
    group.name = `flag-${flag.id}`;

    // Flag pole
    const poleGeom = new THREE.BoxGeometry(0.2, 4.0, 0.2);
    const poleMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
    const pole = new THREE.Mesh(poleGeom, poleMat);
    pole.position.set(0, 2.0, 0);
    pole.name = 'pole';
    group.add(pole);

    // Flag plate (ownership color)
    const plateGeom = new THREE.BoxGeometry(1.2, 0.8, 0.1);
    const plateMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
    const plate = new THREE.Mesh(plateGeom, plateMat);
    plate.position.set(0.7, 3.0, 0);
    plate.name = 'plate';
    group.add(plate);

    // Capture bar (under the plate)
    const barGeom = new THREE.BoxGeometry(1.0, 0.15, 0.1);
    const barMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const bar = new THREE.Mesh(barGeom, barMat);
    bar.position.set(-0.5, 1.0, 0); // left edge at -0.5 when scale.x = 1
    bar.name = 'captureBar';
    group.add(bar);

    // World position
    group.position.set(flag.x, flag.y, flag.z);

    return group;
  }

  private updateFlagTransform(group: THREE.Object3D, flag: FlagSnapshot): void {
    group.position.set(flag.x, flag.y, flag.z);
  }

  /**
   * Interpret the owner value (number or string) and set plate color.
   * We support both numeric (0/1/2) and string ('TeamA'/'TeamB') encodings.
   */
  private updateFlagOwner(group: THREE.Object3D, owner: FlagSnapshot['owner']): void {
    const plate = group.getObjectByName('plate') as THREE.Mesh | null;
    if (!plate) return;

    const mat = plate.material as THREE.MeshBasicMaterial;

    const o = owner as any;

    const isTeamA = o === 1 || o === 'TeamA' || o === 'A';
    const isTeamB = o === 2 || o === 'TeamB' || o === 'B';

    if (isTeamA) {
      mat.color.set(0x0080ff); // blue
    } else if (isTeamB) {
      mat.color.set(0xff4040); // red
    } else {
      mat.color.set(0xcccccc); // neutral
    }
  }

  /**
   * Set capture bar fill (0..1).
   */
  private setCaptureProgress(group: THREE.Object3D, capture: number): void {
    const bar = group.getObjectByName('captureBar') as THREE.Mesh | null;
    if (!bar) return;

    // Clamp 0..1
    const c = Math.max(0, Math.min(1, capture));

    bar.scale.x = c;
    // Keep left edge fixed, grow to the right
    bar.position.x = (c - 1) * 0.5;
  }
}


## FILE: apps\client-tauri\src\core\InputManager.ts
---------------------------
import { ClientInput } from '@bf42lite/protocol';

// Helper: Convert degrees to radians
const toRad = (deg: number) => deg * (Math.PI / 180);

export class InputManager {
  private keys = new Set<string>();
  private buttons = new Set<number>();
  
  private yaw = 0;
  private pitch = 0; 
  private readonly MAX_PITCH = toRad(85);

  // === 1. ADD STATE FLAGG ===
  private isInteractionEnabled = false; 

  constructor() {
    window.addEventListener('keydown', (e) => this.keys.add(e.code));
    window.addEventListener('keyup', (e) => this.keys.delete(e.code));
    window.addEventListener('mousedown', (e) => this.buttons.add(e.button));
    window.addEventListener('mouseup', (e) => this.buttons.delete(e.button));

    document.addEventListener('mousemove', (e) => {
      // Only rotate if locked AND enabled
      if (document.pointerLockElement && this.isInteractionEnabled) {
        const sensitivity = 0.002;
        this.yaw -= e.movementX * sensitivity;
        this.pitch -= e.movementY * sensitivity;
        this.pitch = Math.max(-this.MAX_PITCH, Math.min(this.MAX_PITCH, this.pitch));
      }
    });

    document.addEventListener('click', (e) => {
      // === 2. CHECK STATE BEFORE LOCKING ===
      if (!this.isInteractionEnabled) return; 

      // Prevent locking if we clicked a button/UI (extra safety)
      const target = e.target as HTMLElement;
      if (target.closest('button') || target.closest('.spawn-point')) return;

      if (!document.pointerLockElement) {
        document.body.requestPointerLock(); 
      }
    });
  }

  // === 3. EXPOSE CONTROL METHOD ===
  public setInteraction(enabled: boolean) {
      this.isInteractionEnabled = enabled;
  }

  getCommand(tick: number): ClientInput {
    // If in menu, return empty input
    if (!this.isInteractionEnabled) {
        return {
            type: 'input',
            tick,
            axes: { forward:0, right:0, jump:false, shoot:false, reload:false, yaw: this.yaw, pitch: this.pitch }
        };
    }

    let forward = 0;
    let right = 0;
    
    if (this.keys.has('KeyW')) forward += 1;
    if (this.keys.has('KeyS')) forward -= 1;
    if (this.keys.has('KeyD')) right += 1;
    if (this.keys.has('KeyA')) right -= 1;

    return {
      type: 'input',
      tick,
      axes: {
        forward,
        right,
        jump: this.keys.has('Space'),
        shoot: this.buttons.has(0),
        reload: this.keys.has('KeyR'),
        yaw: this.yaw,
        pitch: this.pitch
      }
    };
  }
}


## FILE: apps\client-tauri\src\core\Renderer.ts
---------------------------
import * as THREE from 'three';
import { InputState } from '@bf42lite/engine-core';

export class Renderer {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  // We map entity IDs to ThreeJS objects (Mesh or Group)
  private entities = new Map<number, THREE.Object3D>();

  constructor() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x87CEEB); // Sky Blue
    this.scene.fog = new THREE.Fog(0x87CEEB, 20, 120);

    // 1. Map Setup (The Arena)
    // A large dark green floor (100m x 100m)
    const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.MeshStandardMaterial({ color: 0x2a3b2a, roughness: 0.8 })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    this.scene.add(plane);

    // 2. Grid Helper (Visual Ruler)
    const gridHelper = new THREE.GridHelper(100, 100, 0x555555, 0x333333);
    gridHelper.position.y = 0.05; // Slightly above ground
    this.scene.add(gridHelper);

    // 3. Lighting
    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(20, 50, 20);
    light.castShadow = true;
    light.shadow.mapSize.width = 2048;
    light.shadow.mapSize.height = 2048;
    light.shadow.camera.left = -50;
    light.shadow.camera.right = 50;
    light.shadow.camera.top = 50;
    light.shadow.camera.bottom = -50;
    
    this.scene.add(light);
    this.scene.add(new THREE.AmbientLight(0x505050)); // Soft fill light

    // 4. Camera Setup
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // 5. Renderer Setup
    const canvas = document.getElementById('game') as HTMLCanvasElement;
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    window.addEventListener('resize', () => {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  public getScene(): THREE.Scene {
    return this.scene;
}

  public updateEntity(id: number, state: any, isMe: boolean) {
    let object = this.entities.get(id);

    // --- INITIALIZATION ---
    if (!object) {
        if (state.type === 'flag') {
            console.log(`[Renderer] Creating Flag Visuals for Entity ${id}`);
            const group = new THREE.Group();
            
            // A. The Pole
            const poleGeom = new THREE.BoxGeometry(0.4, 6, 0.4);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 3; // Sit on ground
            pole.castShadow = true;
            pole.receiveShadow = true;
            pole.name = 'pole';
            group.add(pole);

            // B. The Banner (The Rectangle)
            const bannerGeom = new THREE.BoxGeometry(1.2, 0.8, 0.1);
            const bannerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
            const banner = new THREE.Mesh(bannerGeom, bannerMat);
            banner.position.set(0.6, 5.5, 0);
            banner.castShadow = true;
            banner.name = 'banner';
            group.add(banner);

            // C. The Zone Boundary (Ring)
            const radius = 8.0;
            const ringGeom = new THREE.RingGeometry(radius - 0.3, radius, 64);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.6 
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            group.add(ring);

            // D. Progress Disc
            const progGeom = new THREE.CircleGeometry(radius - 0.4, 64);
            const progMat = new THREE.MeshBasicMaterial({ 
                color: 0xcccccc, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.4 
            });
            const progress = new THREE.Mesh(progGeom, progMat);
            progress.rotation.x = -Math.PI / 2;
            progress.position.y = 0.15;
            progress.scale.set(0, 0, 0);
            progress.name = 'progress';
            group.add(progress);

            object = group;
        } else {
            // Standard Soldier (Capsule)
            const geometry = new THREE.CapsuleGeometry(0.4, 1.8, 4, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            object = new THREE.Mesh(geometry, material);
            object.castShadow = true;
            object.receiveShadow = true;
        }

        this.scene.add(object);
        this.entities.set(id, object);
    }

    // --- STATE UPDATES ---
    object.position.set(state.pos.x, state.pos.y, state.pos.z);

    // === FLAG LOGIC ===
    if (state.type === 'flag') {
        const group = object as THREE.Group;
        
        // Hot Reload Safety: Ensure banner exists
        let banner = group.getObjectByName('banner') as THREE.Mesh;
        if (!banner) {
             const bannerGeom = new THREE.BoxGeometry(1.2, 0.8, 0.1);
             const bannerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
             banner = new THREE.Mesh(bannerGeom, bannerMat);
             banner.position.set(0.6, 5.5, 0);
             banner.castShadow = true;
             banner.name = 'banner';
             group.add(banner);
        }

        const pole = group.getObjectByName('pole') as THREE.Mesh;
        const progressDisc = group.getObjectByName('progress') as THREE.Mesh;
        
        const poleMat = pole.material as THREE.MeshStandardMaterial;
        const bannerMat = banner.material as THREE.MeshStandardMaterial;
        const progMat = progressDisc.material as THREE.MeshBasicMaterial;

        // 1. Color Logic (Ownership)
        // 1=Axis(Red), 2=Allies(Blue), 0=Neutral(Grey)
        let color = 0xcccccc;
        if (state.team === 1) color = 0xff0000;
        else if (state.team === 2) color = 0x0000ff;

        poleMat.color.setHex(color);
        bannerMat.color.setHex(color);

        // 2. Progress Disc (Animation)
        const rawProgress = state.progress || 0;
        const scale = Math.abs(rawProgress);
        progressDisc.scale.set(scale, scale, scale);

        if (rawProgress > 0) {
            progMat.color.setHex(0xff0000);
        } else if (rawProgress < 0) {
            progMat.color.setHex(0x0000ff);
        } else {
            progMat.color.setHex(0xffffff);
        }
        
        return;
    }

    // === SOLDIER LOGIC ===
    if (object instanceof THREE.Mesh) {
        object.position.y += 0.9; // Adjust capsule pivot
        object.rotation.set(0, state.rot, 0);
        
        const mat = object.material as THREE.MeshStandardMaterial;

        if (isMe) {
            // FPS Camera placement
            this.camera.position.set(state.pos.x, state.pos.y + 1.6, state.pos.z);
            this.camera.rotation.set(state.pitch || InputState.viewY[id] || 0, state.rot, 0, 'YXZ');
            object.visible = false; // Hide own body
        } else {
            object.visible = true;
            // Team Colors
            if (state.team === 1) mat.color.setHex(0xff0000);
            else if (state.team === 2) mat.color.setHex(0x0000ff);
            else mat.color.setHex(0xffffff);
        }
    }
  }

  public removeEntity(id: number) {
    const obj = this.entities.get(id);
    if (obj) {
        this.scene.remove(obj);
        // Cleanup geometry/materials
        if (obj instanceof THREE.Mesh) {
            if (obj.geometry) obj.geometry.dispose();
            if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
            } else {
                (obj.material as THREE.Material).dispose();
            }
        } else if (obj instanceof THREE.Group) {
            // Cleanup children if it's a group (like the flag)
            obj.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.geometry.dispose();
                    (child.material as THREE.Material).dispose();
                }
            });
        }
        this.entities.delete(id);
    }
  }

  public render() {
    this.renderer.render(this.scene, this.camera);
  }

  public getCamera() {
      return this.camera;
  }

  public drawTracer(start: THREE.Vector3, end: THREE.Vector3) {
      const material = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
      const points = [start, end];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);
      
      this.scene.add(line);

      setTimeout(() => {
          this.scene.remove(line);
          geometry.dispose();
          material.dispose();
      }, 100);
  }
}

## FILE: apps\client-tauri\src\core\WeaponSystem.ts
---------------------------
import * as THREE from 'three';
import { Renderer } from './Renderer';
import { NetworkManager } from '../managers/NetworkManager';
import { InputState } from '@bf42lite/engine-core';

// Mirror of Server Config
const WEAPONS = {
  0: { rate: 0.12 }, // Assault
  1: { rate: 0.15 }, // Medic
  2: { rate: 1.50 }, // Scout (Slow!)
};

export class WeaponSystem {
  private lastFireTime = 0;
  // Remove fixed constant: private readonly FIRE_RATE = 0.15; 
  private readonly RANGE = 100;     

  private raycaster = new THREE.Raycaster();
  
  // [ADD THIS] To track what we are holding
  public currentClassId = 0;

  constructor(
      private renderer: Renderer,
      private net: NetworkManager
  ) {}

  public setClass(classId: number) {
      this.currentClassId = classId;
  }

  public update(_dt: number, myEntityId: number, currentTick: number) {
    if (myEntityId < 0) return;

    // Get Fire Rate for current class
    const stats = WEAPONS[this.currentClassId as keyof typeof WEAPONS] || WEAPONS[0];

    const isShooting = (InputState.buttons[myEntityId] & 2) !== 0;

    if (isShooting) {
      const now = performance.now() / 1000; 
      
      // [UPDATED] Use stats.rate
      if (now - this.lastFireTime > stats.rate) {
        this.fire(currentTick);
        this.lastFireTime = now;
      }
    }
  }

  // ... rest of fire() is fine ...
  private fire(tick: number) {
    const camera = this.renderer.getCamera();
    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const start = camera.position.clone();
    const direction = this.raycaster.ray.direction.clone();
    const end = start.clone().add(direction.clone().multiplyScalar(this.RANGE));

    this.net.sendFire(
        { x: start.x, y: start.y, z: start.z },
        { x: direction.x, y: direction.y, z: direction.z },
        tick
    );

    const visualOffset = new THREE.Vector3(0.2, -0.2, 0.5);
    visualOffset.applyQuaternion(camera.quaternion);
    const visualStart = start.clone().add(visualOffset);

    this.renderer.drawTracer(visualStart, end);
  }
}


## FILE: apps\client-tauri\src\managers\NetworkManager.ts
---------------------------
// apps/client-tauri/src/managers/NetworkManager.ts

import { WebSocketAdapter, NetworkAdapter } from '@bf42lite/net';
import { ClientInput, ClientFire } from '@bf42lite/protocol';
import {
  SimWorld,
  addEntity,
  addComponent,
  removeEntity,
  Transform,
} from '@bf42lite/engine-core';
import {
  Health,
  Soldier,
  CapturePoint,
  Team,
  Loadout,
} from '@bf42lite/games-bf42';
import { Renderer } from '../core/Renderer';

interface InterpolationSnapshot {
  tick: number;
  pos: { x: number; y: number; z: number };
  rot: number;
  timestamp: number;
}

interface InterpolationBuffer {
  snapshots: InterpolationSnapshot[];
}

export class NetworkManager {
  private net: NetworkAdapter;

  private myServerId = -1;
  private serverToLocal = new Map<number, number>();
  private flagEntityById = new Map<number, number>();

  private remoteBuffers = new Map<number, InterpolationBuffer>();
  private snapshotTick = 0;
  private hasLoggedSnapshot = false;

  public onConnected?: () => void;
  public onDisconnected?: () => void;
  public onWelcome?: (serverId: number) => void;
  public onSnapshot?: (msg: any) => void;
  public onHitConfirmed?: (damage: number) => void;

  constructor() {
    this.net = new WebSocketAdapter();

    this.net.onConnect(() => {
      console.log('[Net] WebSocket Connected');
      this.onConnected?.();
    });

    this.net.onDisconnect(() => {
      console.log('[Net] WebSocket Disconnected');
      this.onDisconnected?.();
    });

    this.net.onMessage((raw: any) => {
      console.log('[NET] Incoming message:', raw);

      // 1) Array-based messages (current Rust host)
      if (Array.isArray(raw)) {
        const arr = raw as any[];

        if (arr.length !== 2) {
          console.log('[NET] Unhandled array message (len != 2):', arr);
          return;
        }

        const [kindId, payload] = arr;
        console.log(
          '[NET] Decoding array message. kindId =',
          kindId,
          'payload =',
          payload,
        );

        // kindId === 1 â‡’ snapshot
        if (kindId === 1 && Array.isArray(payload)) {
          const [entitiesRaw, flagsRaw, gameStateRaw] = payload as [
            any[],
            any[],
            any,
          ];

          const snap = {
            type: 'snapshot' as const,
            tick: ++this.snapshotTick,
            entities: entitiesRaw ?? [],
            flags: flagsRaw ?? [],
            game_state: Array.isArray(gameStateRaw)
              ? {
                  team_a_tickets: gameStateRaw[0] ?? 0,
                  team_b_tickets: gameStateRaw[1] ?? 0,
                  match_ended: !!gameStateRaw[2],
                }
              : gameStateRaw,
          };

          console.log('[NET] Snapshot from array envelope:', snap);
          this.onSnapshot?.(snap);
          return;
        }

        console.log('[NET] Unhandled array message (unknown kindId):', arr);
        return;
      }

      // 2) Object-based messages (older / JSON style)
      const msg = raw as any;

      if (msg.type === 'welcome') {
        console.log(`[Net] Joined match. Server ID: ${msg.yourId}`);
        this.myServerId = msg.yourId;
        this.onWelcome?.(msg.yourId);
        return;
      }

      if (msg.type === 'snapshot') {
        this.onSnapshot?.(msg);
        return;
      }

      if (msg.type === 'hit-confirmed') {
        this.onHitConfirmed?.(msg.damage);
        return;
      }

      // Tauri Rust envelope: { your_id, snapshot: { ... } }
      if (msg.snapshot) {
        if (this.myServerId === -1 && typeof msg.your_id === 'number') {
          this.myServerId = msg.your_id;
          console.log(
            `[Net] Joined match. Server ID: ${this.myServerId}`,
          );
          this.onWelcome?.(this.myServerId);
        }

        this.snapshotTick++;

        if (!this.hasLoggedSnapshot) {
          console.log(
            '[NET] FULL SNAPSHOT (object envelope):',
            JSON.stringify(msg.snapshot),
          );
          console.log(
            '[NET] Snapshot keys:',
            Object.keys(msg.snapshot),
          );
          this.hasLoggedSnapshot = true;
        }

        const snap = {
          type: 'snapshot' as const,
          tick: this.snapshotTick,
          entities: msg.snapshot.entities ?? [],
          flags: msg.snapshot.flags || msg.snapshot.flag_snapshots || [],
          game_state: msg.snapshot.game_state,
        };

        this.onSnapshot?.(snap);
        return;
      }

      console.log('[NET] Unhandled message from server (object):', msg);
    });
  }

  // Public API

  public connect(url: string) {
    this.net.connect(url);
  }

  public sendSpawnRequest(classId: number) {
    this.net.send({ type: 'spawn_request', classId });
  }

  public send(cmd: ClientInput) {
    this.net.send(cmd);
  }

  public sendFire(
    origin: { x: number; y: number; z: number },
    direction: { x: number; y: number; z: number },
    tick: number,
  ) {
    const msg: ClientFire = {
      type: 'fire',
      tick,
      origin,
      direction,
      weaponId: 1,
    };
    this.net.send(msg);
  }

  public registerLocalPlayer(serverId: number, localId: number) {
    this.serverToLocal.set(serverId, localId);
  }

  public getLocalId(serverId: number): number | undefined {
    return this.serverToLocal.get(serverId);
  }

  // Flags (Conquest)

  public processFlags(msg: any, world: SimWorld) {
    const flags = msg.flags ?? msg.flag_snapshots ?? [];
    if (!flags.length) return;

    for (const f of flags) {
      let id: number;
      let x: number;
      let y: number;
      let z: number;
      let ownerStr: string | null = null;
      let capture = 0;

      if (Array.isArray(f)) {
        // Server layout: [id, x, y, z, radius, ownerStr, capture]
        id = f[0];
        x = f[1];
        y = f[2];
        z = f[3];
        ownerStr = (f[5] as string) ?? null;
        capture = typeof f[6] === 'number' ? f[6] : 0;
      } else {
        // Backwards-compatible object layout
        id = f.id;
        x = f.pos?.x ?? 0;
        y = f.pos?.y ?? 0;
        z = f.pos?.z ?? 0;
        ownerStr = f.owner ?? null;
        capture = typeof f.capture === 'number' ? f.capture : 0;
      }

      if (typeof id !== 'number') {
        console.warn('[NET] Flag snapshot without valid id:', f);
        continue;
      }

      let eid = this.flagEntityById.get(id);
      if (eid === undefined) {
        eid = addEntity(world);
        addComponent(world, Transform, eid);
        addComponent(world, CapturePoint, eid);
        addComponent(world, Team, eid);

        this.flagEntityById.set(id, eid);
        console.log('[NET] Spawning Flag ID:', id, 'at', x, y, z);
      }

      Transform.x[eid] = x;
      Transform.y[eid] = y;
      Transform.z[eid] = z;

      CapturePoint.progress[eid] = capture;

      let teamId = 0;
      switch (ownerStr) {
        case 'Axis':
        case 'TeamA':
        case 'Team A':
          teamId = 1;
          break;
        case 'Allies':
        case 'TeamB':
        case 'Team B':
          teamId = 2;
          break;
        default:
          teamId = 0; // neutral / none
          break;
      }
      Team.id[eid] = teamId;
    }
  }

  // Remote entities / players

  public processRemoteEntities(msg: any, world: SimWorld, renderer: Renderer) {
    const activeServerIds = new Set<number>();
    const now = performance.now();
    const entities = msg.entities || [];

    entities.forEach((serverEnt: any) => {
      const sId = serverEnt.id;
      if (typeof sId !== 'number') return;

      activeServerIds.add(sId);

      let localId = this.serverToLocal.get(sId);
      if (localId === undefined) {
        localId = addEntity(world);
        addComponent(world, Transform, localId);
        addComponent(world, Soldier, localId);
        addComponent(world, Health, localId);
        addComponent(world, Team, localId);
        addComponent(world, Loadout, localId);

        this.serverToLocal.set(sId, localId);
        this.remoteBuffers.set(localId, { snapshots: [] });

        console.log('[NET] Created local entity for server id', sId);
      }

      const pos = serverEnt.pos ?? serverEnt.position ?? {
        x: 0,
        y: 0,
        z: 0,
      };
      const rot = serverEnt.rot ?? serverEnt.rotation ?? 0;

      const buffer = this.remoteBuffers.get(localId)!;
      buffer.snapshots.push({
        tick: msg.tick ?? 0,
        pos: { x: pos.x, y: pos.y, z: pos.z },
        rot,
        timestamp: now,
      });
      if (buffer.snapshots.length > 20) buffer.snapshots.shift();

      if (serverEnt.health) {
        Health.current[localId] = serverEnt.health.current ?? 0;
        Health.isDead[localId] = serverEnt.is_dead ? 1 : 0;
      }

      if (serverEnt.team) {
        let t = 0;
        if (serverEnt.team.id === 'TeamA') t = 1;
        if (serverEnt.team.id === 'TeamB') t = 2;
        Team.id[localId] = t;
      }

      // Sync loadout (single classId field)
      if (serverEnt.loadout) {
        const classId = serverEnt.loadout.classId ?? 0;
        Loadout.classId[localId] = classId;
      }
    });

    // Despawn entities that disappeared from the snapshot
    for (const [sId, lId] of this.serverToLocal.entries()) {
      if (!activeServerIds.has(sId)) {
        console.log('[NET] Despawning entity for server id', sId);
        removeEntity(world, lId);
        this.serverToLocal.delete(sId);
        this.remoteBuffers.delete(lId);
        renderer.removeEntity(lId);
      }
    }
  }

  public interpolateRemotePlayers(renderTime: number) {
    for (const [lid, buffer] of this.remoteBuffers) {
      if (buffer.snapshots.length < 2) continue;

      let t0 = buffer.snapshots[0];
      let t1 = buffer.snapshots[buffer.snapshots.length - 1];

      for (let i = 0; i < buffer.snapshots.length - 1; i++) {
        const a = buffer.snapshots[i];
        const b = buffer.snapshots[i + 1];
        if (a.timestamp <= renderTime && b.timestamp >= renderTime) {
          t0 = a;
          t1 = b;
          break;
        }
      }

      const total = t1.timestamp - t0.timestamp;
      const alpha = total > 0 ? (renderTime - t0.timestamp) / total : 0;
      const clamped = Math.max(0, Math.min(1, alpha));

      Transform.x[lid] = t0.pos.x + (t1.pos.x - t0.pos.x) * clamped;
      Transform.y[lid] = t0.pos.y + (t1.pos.y - t0.pos.y) * clamped;
      Transform.z[lid] = t0.pos.z + (t1.pos.z - t0.pos.z) * clamped;
      Transform.rotation[lid] =
        t0.rot + (t1.rot - t0.rot) * clamped;
    }
  }
}


## FILE: apps\client-tauri\src\managers\UIManager.ts
---------------------------
export class UIManager {
    private ui: {
        deployScreen: HTMLElement | null;
        hudLayer: HTMLElement | null;
        healthVal: HTMLElement | null;
        healthFill: HTMLElement | null;
        spawnBtn: HTMLElement | null;
        ticketsAxis: HTMLElement | null;
        ticketsAllies: HTMLElement | null;
        fps: HTMLElement | null;
        rtt: HTMLElement | null;
        hitmarker: HTMLElement | null;
        gameOverScreen: HTMLElement | null;
        endTitle: HTMLElement | null;
        ammoCurr: HTMLElement | null;
        ammoRes: HTMLElement | null;
        weaponName: HTMLElement | null;
    };
    private selectedSpawnId = -1;
    private hitTimeout: number | null = null;
    
    // FIX: Update signature to accept classId
    private onSpawnRequest: (classId: number) => void;
    private selectedClassId = 0; // Default to Assault

    constructor(onSpawnRequest: (classId: number) => void) {
        this.onSpawnRequest = onSpawnRequest;
        
        this.ui = {
            deployScreen: document.getElementById('deploy-screen'),
            hudLayer: document.getElementById('hud-layer'),
            healthVal: document.getElementById('health-val'),
            healthFill: document.getElementById('health-fill'),
            spawnBtn: document.getElementById('btn-spawn'),
            ticketsAxis: document.getElementById('tickets-axis'),
            ticketsAllies: document.getElementById('tickets-allies'),
            fps: document.getElementById('fps'),
            rtt: document.getElementById('rtt'),
            hitmarker: document.getElementById('hitmarker'),
            gameOverScreen: document.getElementById('game-over-screen'),
            endTitle: document.getElementById('end-title'),
            ammoCurr: document.getElementById('ammo-curr'),
            ammoRes: document.getElementById('ammo-res'),
            weaponName: document.getElementById('weapon-name')
        };

        this.initListeners();
    }

    private initListeners() {
        // 1. Class Selection Listeners (NEW)
        const classBtns = document.querySelectorAll('.class-btn');
        classBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Update Visuals
                classBtns.forEach(b => b.classList.remove('selected'));
                const target = e.target as HTMLElement;
                target.classList.add('selected');
                
                // Update Logic
                const id = target.getAttribute('data-id');
                if (id) this.selectedClassId = parseInt(id);
            });
        });

        // 2. Map / Spawn Point Click Listener
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
            mapContainer.addEventListener('click', (e: Event) => {
                const target = (e.target as HTMLElement).closest('.spawn-point') as HTMLElement;
                if (!target) return;
                
                document.querySelectorAll('.spawn-point').forEach(el => el.classList.remove('selected'));
                target.classList.add('selected');
                
                this.selectedSpawnId = parseInt(target.dataset.id || "-1");
            });
        }

        // 3. Spawn Button Click Listener
        if (this.ui.spawnBtn) {
            this.ui.spawnBtn.addEventListener('click', () => {
                // Note: We can relax the spawn point requirement if we are just doing random spawns for now
                // if (this.selectedSpawnId === -1) { ... } 

                this.setDeployMode(false);
                
                // Pass the selected class ID to the game loop
                this.onSpawnRequest(this.selectedClassId);
            });
        }
    }

    public setDeployMode(isDeploying: boolean) {
        if (isDeploying) {
            this.ui.deployScreen?.classList.remove('hidden');
            this.ui.hudLayer?.classList.add('hidden');
            document.exitPointerLock();
        } else {
            this.ui.deployScreen?.classList.add('hidden');
            this.ui.hudLayer?.classList.remove('hidden');
            document.body.requestPointerLock();
        }
    }

    public updateStats(fps: number, rtt: number) {
        if (this.ui.fps) this.ui.fps.innerText = fps.toString();
        if (this.ui.rtt) this.ui.rtt.innerText = rtt.toString();
    }

    public updateHealth(current: number) {
        if (this.ui.healthVal) this.ui.healthVal.innerText = current.toString();
        if (this.ui.healthFill) this.ui.healthFill.style.width = `${current}%`;
    }

    public updateTickets(axis: number, allies: number) {
        if (this.ui.ticketsAxis) this.ui.ticketsAxis.innerText = axis.toString();
        if (this.ui.ticketsAllies) this.ui.ticketsAllies.innerText = allies.toString();
    }

    public showHitMarker() {
        if (!this.ui.hitmarker) return;
        this.ui.hitmarker.classList.remove('hit-active');
        void this.ui.hitmarker.offsetWidth; 
        this.ui.hitmarker.classList.add('hit-active');
        if (this.hitTimeout) clearTimeout(this.hitTimeout);
        this.hitTimeout = window.setTimeout(() => {
            this.ui.hitmarker?.classList.remove('hit-active');
        }, 200);
    }

    public setGameOver(isGameOver: boolean, winningTeam: string) {
        if (!this.ui.gameOverScreen || !this.ui.endTitle) return;
        if (isGameOver) {
            this.ui.gameOverScreen.classList.add('visible');
            this.ui.endTitle.innerText = winningTeam;
            document.exitPointerLock();
        } else {
            this.ui.gameOverScreen.classList.remove('visible');
        }
    }

    public updateAmmo(current: number, reserve: number, weaponName?: string) {
    if (this.ui.ammoCurr) this.ui.ammoCurr.innerText = current.toString();
    if (this.ui.ammoRes) this.ui.ammoRes.innerText = reserve.toString();
    if (this.ui.weaponName && weaponName) this.ui.weaponName.innerText = weaponName;
}

    public updateRespawn(isDead: boolean, timer: number) {
        if (!this.ui.deployScreen || !this.ui.spawnBtn) return;

        if (isDead) {
            this.ui.deployScreen.style.display = 'flex'; 
            
            if (timer > 0) {
                this.ui.spawnBtn.innerText = `Deploy in ${timer.toFixed(1)}s`;
                this.ui.spawnBtn.setAttribute('disabled', 'true');
                this.ui.spawnBtn.style.pointerEvents = 'none';
                this.ui.spawnBtn.style.opacity = '0.5';
            } else {
                this.ui.spawnBtn.innerText = "DEPLOY (Press SPACE)";
                this.ui.spawnBtn.removeAttribute('disabled');
                this.ui.spawnBtn.style.pointerEvents = 'auto';
                this.ui.spawnBtn.style.opacity = '1.0';
            }
        } else {
            this.ui.deployScreen.style.display = 'none';
        }
    }
}


## FILE: apps\client-tauri\src\systems\handleSnapshot.ts
---------------------------
// src/systems/handleSnapshot.ts

import type { SimWorld } from '@bf42lite/engine-core';
import type { Renderer } from '../core/Renderer';
import type { NetworkManager } from '../managers/NetworkManager';
import type { UIManager } from '../managers/UIManager';

// Shape that NetworkManager.onSnapshot() gives us
interface SnapshotMessage {
  type: 'snapshot';
  tick?: number;
  entities?: any[];
  flags?: any[];
  game_state?: {
    team_a_tickets?: number;
    team_b_tickets?: number;
    match_ended?: boolean;
  };
}

export function handleSnapshot(
  msg: SnapshotMessage,
  simWorld: SimWorld,
  renderer: Renderer,
  net: NetworkManager,
  ui: UIManager
): void {
  // Critical debug: do we see ANY flags at all?
  console.log('[SNAPSHOT] Flags in snapshot:', msg.flags);

  //
  // 1. FLAGS â†’ ECS
  //
  net.processFlags(msg, simWorld);

  //
  // 2. REMOTE ENTITIES â†’ ECS + Renderer
  //
  net.processRemoteEntities(msg, simWorld, renderer);

  //
  // 3. TICKETS â†’ UI
  //
  const ticketsAxis = msg.game_state?.team_a_tickets ?? 0;
  const ticketsAllies = msg.game_state?.team_b_tickets ?? 0;
  ui.updateTickets(ticketsAxis, ticketsAllies);

  //
  // 4. GAME OVER â†’ UI
  //
  const isGameOver = msg.game_state?.match_ended === true;
  if (isGameOver) {
    let winner = 'DRAW';

    if (ticketsAxis <= 0 && ticketsAllies > 0) winner = 'ALLIES VICTORY';
    else if (ticketsAllies <= 0 && ticketsAxis > 0) winner = 'AXIS VICTORY';

    ui.setGameOver(true, winner);
  } else {
    ui.setGameOver(false, '');
  }
}


## FILE: apps\client-tauri\src\systems\Reconciler.ts
---------------------------
import { Transform, Velocity, SimWorld } from '@bf42lite/engine-core';
import { ClientInput, EntityState } from '@bf42lite/protocol';

export interface InputHistory {
    tick: number;
    input: ClientInput;
    pos: { x: number; y: number; z: number };
    timestamp: number;
}

/**
 * Client-side reconciler for predicted movement.
 * ... (rest of comment) ...
 */
export class Reconciler {
    private history: InputHistory[] = [];

    // Normal correction threshold (â‰ˆ1m).
    private readonly ERROR_THRESHOLD_SQ = 1.0;

    // Teleport/spawn threshold (â‰ˆ10m).
    private readonly TELEPORT_THRESHOLD_SQ = 100.0;

    /**
     * Record the current predicted state.
     *
     * Call this once per local simulation step, after applying inputs.
     */
    public pushHistory(
        tick: number,
        input: ClientInput,
        x: number,
        y: number,
        z: number
    ) {
        this.history.push({
            tick,
            input,
            pos: { x, y, z },
            timestamp: performance.now(),
        });
    }

    public clearHistory() {
        this.history.length = 0;
    }

    /**
     * Compare a server snapshot to the local history and correct if needed.
     */
    public reconcile(
        serverTick: number,
        serverState: EntityState,
        eid: number,
        world: SimWorld,
        movementSystem: (w: SimWorld) => void
    ): number {
        // --- PATCH 2: Start ---
        if (!serverState.pos || this.history.length === 0) {
            return 0;
        }
    
        // 1. Prefer exact match
        let historyIndex = this.history.findIndex(h => h.tick === serverTick);
    
        // 2. If no exact match, fall back to closest tick we have
        if (historyIndex === -1) {
            console.warn(`[Reconciler] No history found for server tick ${serverTick}. Client history size: ${this.history.length}.`);
            let closestIndex = -1;
            let closestDiff = Number.POSITIVE_INFINITY;
    
            for (let i = 0; i < this.history.length; i++) {
                const diff = Math.abs(this.history[i].tick - serverTick);
                if (diff < closestDiff) {
                    closestDiff = diff;
                    closestIndex = i;
                }
            }
    
            if (closestIndex === -1) {
                return 0;
            }
    
            historyIndex = closestIndex;
    
            // Optional: inspect how far off the ticks are
            const picked = this.history[historyIndex];
            console.debug(
                `[Reconciler] No exact history for serverTick=${serverTick}, ` +
                `using closest tick=${picked.tick} (Î”=${closestDiff})`
            );
        }
    
        const historyState = this.history[historyIndex];
    
        // RTT is time since we originally simulated that tick
        const rtt = Math.round(performance.now() - historyState.timestamp);
    
        // 3. Compute spatial error
        const dx = historyState.pos.x - serverState.pos.x;
        const dy = historyState.pos.y - serverState.pos.y;
        const dz = historyState.pos.z - serverState.pos.z;
        const distSq = dx * dx + dy * dy + dz * dz;
        // --- PATCH 2: End ---

        // --- Existing Error Handling Logic ---

        // 1) Teleport: error is massive, probably a respawn.
        // --- Optional: Log successful reconciliation ---
    // if (distSq <= this.ERROR_THRESHOLD_SQ) {
    //   console.log(`[Reconciler] Tick ${serverTick} reconciled successfully. ErrorSq: ${distSq.toFixed(4)}`);
    // }
    // --- End Optional ---

    // --- Existing Error Handling Logic ---
    // 1) Teleport: error is massive, probably a respawn.
        if (distSq > this.TELEPORT_THRESHOLD_SQ) {
            console.warn(`[Reconciler] Teleport detected (ErrorSq=${distSq.toFixed(2)})`);
            
            Transform.x[eid] = serverState.pos.x;
            Transform.y[eid] = serverState.pos.y;
            Transform.z[eid] = serverState.pos.z;

            if (serverState.vel) {
                Velocity.x[eid] = serverState.vel.x;
                Velocity.y[eid] = serverState.vel.y;
                Velocity.z[eid] = serverState.vel.z;
            }

            // Start fresh.
            this.clearHistory();
            return rtt;
        }

        // 2) Normal correction: small but noticeable mismatch.
        if (distSq > this.ERROR_THRESHOLD_SQ) {
            console.warn(
                `[Reconciler] Correction\n` +
                `  Tick=${serverTick} ErrorSq=${distSq.toFixed(2)}\n` +
                `  ClientPos=(${historyState.pos.x.toFixed(2)}, ${historyState.pos.y.toFixed(2)}, ${historyState.pos.z.toFixed(2)})\n` +
                `  ServerPos=(${serverState.pos.x.toFixed(2)}, ${serverState.pos.y.toFixed(2)}, ${serverState.pos.z.toFixed(2)})`,
            );

            // For now we simply trust the server fully.
            Transform.x[eid] = serverState.pos.x;
            Transform.y[eid] = serverState.pos.y;
            Transform.z[eid] = serverState.pos.z;

            if (serverState.vel) {
                Velocity.x[eid] = serverState.vel.x;
                Velocity.y[eid] = serverState.vel.y;
                Velocity.z[eid] = serverState.vel.z;
            }

            // NOTE: Full replay logic would go here.
            // For now, snapping is fine, but we *must* clear old history
            // to prevent compounding errors.
            this.history.splice(0, historyIndex + 1);
            return rtt;
        }

        // 3) No correction: server and client agree.
        
        // Clear processed history
        this.history.splice(0, historyIndex + 1);

        // Return RTT (was computed at the top)
        return rtt;
    }
}


## FILE: apps\client-tauri\src\systems\updateGameFrame.ts
---------------------------
// src/systems/updateGameFrame.ts

import { InputState, type SimWorld } from '@bf42lite/engine-core';
import type { InputManager } from '../core/InputManager';

/**
 * One per-frame client update:
 * - Read input
 * - Write into InputState for the local entity
 * - Run the movement system
 * - Return the input command so the caller can push history / send to server
 */
export function updateGameFrame(
  dt: number,
  currentTick: number,
  localEntityId: number,
  simWorld: SimWorld,
  input: InputManager,
  movementSystem: (world: SimWorld) => void,
) {
  // 1. Read input for this tick
  const cmd = input.getCommand(currentTick);

  // 2. Write into ECS input components for the local entity
  if (localEntityId >= 0) {
    InputState.moveY[localEntityId] = cmd.axes.forward;
    InputState.moveX[localEntityId] = cmd.axes.right;
    InputState.viewX[localEntityId] = cmd.axes.yaw;
    InputState.viewY[localEntityId] = cmd.axes.pitch;

    // Button bitmask:
    // bit 0: jump
    // bit 1: shoot  (used by WeaponSystem via InputState.buttons & 2)
    // bit 2: reload
    let buttons = 0;
    if (cmd.axes.jump)   buttons |= 1;
    if (cmd.axes.shoot)  buttons |= 2;
    if (cmd.axes.reload) buttons |= 4;

    InputState.buttons[localEntityId] = buttons;
  }

  // 3. Run movement (local prediction)
  movementSystem(simWorld);

  // 4. Hand the command back to ClientGame
  return cmd;
}


