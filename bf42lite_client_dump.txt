====================================
FILE: \apps\client-tauri\src\main.ts
====================================

import { ClientGame } from './core/ClientGame';

// Prevent context menu
document.addEventListener('contextmenu', event => event.preventDefault());

console.log("Starting bf42lite Client...");
const game = new ClientGame();
game.start();


====================================
FILE: \apps\client-tauri\src\core\ClassConfigLoader.ts
====================================

export interface ClassConfig {
  id: number;
  key: string;
  name: string;
  max_health: number;
  primary_weapon_id: number;
}

export async function loadClassConfig(): Promise<ClassConfig[]> {
  const res = await fetch("classes.json");
  if (!res.ok) {
    console.error("[CLASSES] Failed to load classes.json");
    return [];
  }
  return await res.json();
}


====================================
FILE: \apps\client-tauri\src\core\ClientGame.ts
====================================

// apps/client-tauri/src/core/ClientGame.ts

import {
  createSimulation,
  Transform,
  createMovementSystem,
  type SimWorld,
} from '@bf42lite/engine-core';

import type { Snapshot } from '@bf42lite/protocol';

import { Renderer } from './Renderer';
import { InputManager } from './InputManager';
import { WeaponSystem } from './WeaponSystem';
import { GameLoop } from './GameLoop';
import { createLocalPlayer } from './local-player';

import { NetworkManager } from '../managers/NetworkManager';
import { UIManager } from '../managers/UIManager';
import { Reconciler } from '../systems/Reconciler';
import { updateGameFrame } from '../systems/updateGameFrame';
import { updateWorldRender } from '../world/worldRender';
import { CommandSender } from '../net/CommandSender';
import { SnapshotHandler } from '../systems/SnapshotHandler';
import { syncLocalPlayerFromSnapshot } from '../systems/syncLocalPlayer';
import { HUDUpdater } from '../ui/HUDUpdater';

export class ClientGame {
  private movementSystem = createMovementSystem();
  public sim = createSimulation(); // public so other modules can inspect if needed

  public renderer: Renderer;
  public net: NetworkManager;

  private input: InputManager;
  private ui: UIManager;
  private hud: HUDUpdater;
  public reconciler: Reconciler;
  private weaponSystem: WeaponSystem;
  private commandSender: CommandSender;
  private snapshotHandler: SnapshotHandler;

  private localEntityId: number = -1;
  private lastRtt = 0;

  private readonly SEND_INTERVAL = 1 / 30; // 30 Hz input send
  private readonly INTERPOLATION_DELAY_MS = 100;

  private loop: GameLoop;

  constructor() {
    const world: SimWorld = this.sim.world;

    this.renderer = new Renderer();
    this.reconciler = new Reconciler();
    this.net = new NetworkManager(world, this.renderer, this.reconciler);
    this.commandSender = new CommandSender(this.net, this.SEND_INTERVAL);
    this.input = new InputManager();
    this.ui = new UIManager((classId: number) => {
      console.log(`Spawn requested with Class ID: ${classId}`);
      this.net.sendSpawnRequest(classId);
      this.weaponSystem.setClass(classId);
    });

    // New HUD faÃ§ade
    this.hud = new HUDUpdater(this.ui);

    // Start in deploy mode until the server respawns us
    this.ui.setDeployMode(true);
    this.hud.updateCenterStatus('Select a class and spawn point to deploy.');

    this.weaponSystem = new WeaponSystem(this.renderer, this.net, this.hud);

    // Snapshot handler (HUD / flags routed through HUDUpdater)
    this.snapshotHandler = new SnapshotHandler(this.hud);

    // Pointer lock + UI interaction toggles
    this.input.setInteraction(true);

    this.initNetworkCallbacks();
    this.net.connect('ws://localhost:8080');

    // Local player ECS entity (all components are set up in one place)
    this.localEntityId = createLocalPlayer(world);

    // Game loop wrapper
    this.loop = new GameLoop({
      onFrame: (dt, tick, now) => this.onFrame(dt, tick, now),
    });
  }

  private initNetworkCallbacks() {
    this.net.onConnected = () => {
      console.log('Connected to server');
    };

    this.net.onDisconnected = () => {
      console.log('Disconnected from server');
    };

    // Hit marker now goes through HUD faÃ§ade
    this.net.onHitConfirmed = (damage: number) => {
      this.hud.showHitMarker(damage);
    };

    this.net.onSnapshot = (msg: Snapshot) => {
      // 1) Global snapshot handling (tickets, flags HUD, game over, etc.)
      this.snapshotHandler.process(msg);

      // 2) Local player sync + reconciliation + per-player HUD
      this.lastRtt = syncLocalPlayerFromSnapshot(
        msg,
        this.sim.world,
        this.localEntityId,
        this.net,
        this.hud,
        this.reconciler,
        this.movementSystem,
        this.lastRtt,
      );
    };
  }

  // Public lifecycle

  public start() {
    this.loop.start();
  }

  public stop() {
    this.loop.stop();
  }

  // Per-frame hook driven by GameLoop

  private onFrame(dt: number, tick: number, now: number) {
    const world = this.sim.world;

    // Per-frame input + sim + movement
    const cmd = updateGameFrame(
      dt,
      tick,
      this.localEntityId,
      world,
      this.input,
      this.movementSystem,
    );

    // Prediction history (for reconciliation)
    if (this.localEntityId >= 0 && cmd) {
      this.reconciler.pushHistory(
        tick,
        cmd,
        Transform.x[this.localEntityId],
        Transform.y[this.localEntityId],
        Transform.z[this.localEntityId],
      );
    }

    // Throttled input send (via CommandSender)
    this.commandSender.update(dt, cmd || null);

    // Weapons + fire logic
    this.weaponSystem.update(dt, this.localEntityId, tick);

    // Interpolate remote players using buffered snapshots
    this.net.interpolateRemotePlayers(now - this.INTERPOLATION_DELAY_MS);

    // Render + HUD
    const fps = this.loop.getCurrentFps();
    this.updateRenderAndUI(fps);
  }
  public updateCrosshair(spread: number): void {
    this.ui.setCrosshairSpread(spread);
  }
  
  private updateRenderAndUI(fps: number) {
    updateWorldRender(
      this.sim.world,
      this.renderer,
      this.hud,
      this.localEntityId,
      fps,
      this.lastRtt,
    );
  }
}


====================================
FILE: \apps\client-tauri\src\core\constants.ts
====================================

// apps/client-tauri/src/core/constants.ts

// --- TEAMS ---

export const TEAM_IDS = {
  NONE: 0,
  AXIS: 1,
  ALLIES: 2,
} as const;

export type TeamIdNumeric = (typeof TEAM_IDS)[keyof typeof TEAM_IDS];

export const TEAM_COLORS = {
  NEUTRAL: 0xcccccc,
  AXIS: 0xff0000,
  ALLIES: 0x0000ff,
} as const;

// --- CLASSES / LOADOUTS ---

export const CLASS_IDS = {
  ASSAULT: 0,
  MEDIC: 1,
  SCOUT: 2,
} as const;

// (no weapon names/stats here anymore â€“ those now come from JSON)


====================================
FILE: \apps\client-tauri\src\core\EntityMapper.ts
====================================

// apps/client-tauri/src/core/EntityMapper.ts
//
// Convert ECS components into clean, renderer-ready RenderState objects.
// This keeps rendering code 100% independent from ECS internals.

import {
  Transform,
  InputState,
} from '@bf42lite/engine-core';

import {
  Soldier,
  Team,
  CapturePoint,
} from '@bf42lite/games-bf42';

export type RenderStatePlayer = {
  type: 'player';
  id: number;
  pos: { x: number; y: number; z: number };
  rot: number;
  pitch: number;
  team: number;
};

export type RenderStateFlag = {
  type: 'flag';
  id: number;
  pos: { x: number; y: number; z: number };
  rot: number;
  team: number;
  progress: number; // normalized -1..1 (sign = which team is capturing)
};

export type RenderState = RenderStatePlayer | RenderStateFlag;

export class EntityMapper {
  /**
   * Convert a player ECS entity into a RenderStatePlayer.
   */
  public static mapPlayer(eid: number, world: any, isMe: boolean): RenderStatePlayer {
    return {
      type: 'player',
      id: eid,
      pos: {
        x: Transform.x[eid],
        y: Transform.y[eid],
        z: Transform.z[eid],
      },
      rot: Transform.rotation[eid],
      pitch: isMe ? InputState.viewY[eid] : 0,
      team: Team.id[eid],
    };
  }

  /**
   * Convert a flag ECS entity into a RenderStateFlag.
   *
   * CapturePoint schema (client ECS):
   * - radius: f32
   * - owner:  0 = none, 1 = TeamA, 2 = TeamB
   * - capture: f32 (server-side value, usually in [-1, 1])
   */
  public static mapFlag(eid: number, world: any): RenderStateFlag {
    // Raw capture from ECS (comes from Snapshot.flags[].capture)
    const raw =
      (CapturePoint as any).capture
        ? (CapturePoint as any).capture[eid] ?? 0
        : 0;

    // Normalize to -1..1, preserving sign.
    // If the server ever sends -100..100 again, this still works.
    let progress: number;
    if (Math.abs(raw) <= 1.001) {
      progress = raw;
    } else {
      progress = Math.max(-1, Math.min(1, raw / 100));
    }

    // Owner numeric team id (0/1/2)
    const team =
      (CapturePoint as any).owner
        ? (CapturePoint as any).owner[eid] ?? 0
        : 0;

    return {
      type: 'flag',
      id: eid,
      pos: {
        x: Transform.x[eid],
        y: Transform.y[eid],
        z: Transform.z[eid],
      },
      rot: 0,
      team,
      progress,
    };
  }
}


====================================
FILE: \apps\client-tauri\src\core\GameLoop.ts
====================================

// apps/client-tauri/src/core/GameLoop.ts

/**
 * Simple, reusable game loop wrapper around requestAnimationFrame.
 *
 * Responsibilities:
 * - Manage start/stop of the loop
 * - Track dt, tick, and FPS
 * - Call back into game code once per frame via onFrame
 *
 * It does NOT know about ECS, networking, or rendering.
 */
export interface GameLoopHooks {
  /**
   * Called once per animation frame.
   *
   * @param dt   Delta time in seconds since last frame.
   * @param tick Monotonic simulation tick counter (increments every frame).
   * @param now  High-resolution timestamp (ms) from performance.now().
   */
  onFrame: (dt: number, tick: number, now: number) => void;

  /**
   * Optional callback when the loop starts.
   */
  onStarted?: () => void;

  /**
   * Optional callback when the loop stops.
   */
  onStopped?: () => void;
}

export class GameLoop {
  private running = false;
  private lastFrameTime = 0;
  private tick = 0;
  private fps = 0;
  private rafId: number | null = null;

  private readonly hooks: GameLoopHooks;

  constructor(hooks: GameLoopHooks) {
    this.hooks = hooks;
  }

  /**
   * Start the game loop if it is not already running.
   */
  public start() {
    if (this.running) return;

    this.running = true;
    this.lastFrameTime = performance.now();
    this.tick = 0;

    if (this.hooks.onStarted) {
      this.hooks.onStarted();
    }

    this.rafId = requestAnimationFrame(this.loop);
  }

  /**
   * Stop the game loop. Does not reset tick or FPS.
   */
  public stop() {
    if (!this.running) return;

    this.running = false;

    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }

    if (this.hooks.onStopped) {
      this.hooks.onStopped();
    }
  }

  /**
   * Current frames per second based on the last frame.
   */
  public getCurrentFps(): number {
    return this.fps;
  }

  /**
   * Current tick counter (increments once per frame while running).
   */
  public getCurrentTick(): number {
    return this.tick;
  }

  /**
   * Whether the loop is currently running.
   */
  public isRunning(): boolean {
    return this.running;
  }

  // Internal rAF callback
  private loop = (now: number) => {
    if (!this.running) {
      return;
    }

    // Schedule next frame first to avoid losing it if onFrame throws.
    this.rafId = requestAnimationFrame(this.loop);

    const dtMs = now - this.lastFrameTime;
    this.lastFrameTime = now;

    // Convert to seconds; protect against extremely small/large dt.
    const dt = Math.max(0, dtMs / 1000);

    if (dt > 0) {
      this.fps = Math.round(1 / dt);
    }

    const currentTick = this.tick;
    this.tick = currentTick + 1;

    // Delegate to caller
    this.hooks.onFrame(dt, currentTick, now);
  };
}


====================================
FILE: \apps\client-tauri\src\core\InputManager.ts
====================================

import { ClientInput } from '@bf42lite/protocol';

// Helper: Convert degrees to radians
const toRad = (deg: number) => deg * (Math.PI / 180);

export class InputManager {
  private keys = new Set<string>();
  private buttons = new Set<number>();
  
  private yaw = 0;
  private pitch = 0; 
  private readonly MAX_PITCH = toRad(85);

  // === 1. ADD STATE FLAGG ===
  private isInteractionEnabled = false; 

  constructor() {
    window.addEventListener('keydown', (e) => this.keys.add(e.code));
    window.addEventListener('keyup', (e) => this.keys.delete(e.code));
    window.addEventListener('mousedown', (e) => this.buttons.add(e.button));
    window.addEventListener('mouseup', (e) => this.buttons.delete(e.button));

    document.addEventListener('mousemove', (e) => {
      // Only rotate if locked AND enabled
      if (document.pointerLockElement && this.isInteractionEnabled) {
        const sensitivity = 0.002;
        this.yaw -= e.movementX * sensitivity;
        this.pitch -= e.movementY * sensitivity;
        this.pitch = Math.max(-this.MAX_PITCH, Math.min(this.MAX_PITCH, this.pitch));
      }
    });

    document.addEventListener('click', (e) => {
      // === 2. CHECK STATE BEFORE LOCKING ===
      if (!this.isInteractionEnabled) return; 

      // Prevent locking if we clicked a button/UI (extra safety)
      const target = e.target as HTMLElement;
      if (target.closest('button') || target.closest('.spawn-point')) return;

      if (!document.pointerLockElement) {
        document.body.requestPointerLock(); 
      }
    });
  }

  // === 3. EXPOSE CONTROL METHOD ===
  public setInteraction(enabled: boolean) {
      this.isInteractionEnabled = enabled;
  }

  getCommand(tick: number): ClientInput {
    // If in menu, return empty input
    if (!this.isInteractionEnabled) {
        return {
            type: 'input',
            tick,
            axes: { forward:0, right:0, jump:false, shoot:false, reload:false, yaw: this.yaw, pitch: this.pitch }
        };
    }

    let forward = 0;
    let right = 0;
    
    if (this.keys.has('KeyW')) forward += 1;
    if (this.keys.has('KeyS')) forward -= 1;
    if (this.keys.has('KeyD')) right += 1;
    if (this.keys.has('KeyA')) right -= 1;

    return {
      type: 'input',
      tick,
      axes: {
        forward,
        right,
        jump: this.keys.has('Space'),
        shoot: this.buttons.has(0),
        reload: this.keys.has('KeyR'),
        yaw: this.yaw,
        pitch: this.pitch
      }
    };
  }
}


====================================
FILE: \apps\client-tauri\src\core\local-player.ts
====================================

// apps/client-tauri/src/core/local-player.ts
import {
    addEntity,
    addComponent,
    Transform,
    Velocity,
    InputState,
    Me,
  } from '@bf42lite/engine-core';
  
  import { Health, Ammo, Soldier, Team, Loadout } from '@bf42lite/games-bf42';
  
  export function createLocalPlayer(world: any): number {
    const id = addEntity(world);
  
    addComponent(world, Transform, id);
    addComponent(world, Velocity, id);
    addComponent(world, InputState, id);
    addComponent(world, Me, id);
  
    addComponent(world, Health, id);
    addComponent(world, Ammo, id);
    addComponent(world, Soldier, id);
    addComponent(world, Team, id);
    addComponent(world, Loadout, id);
  
    return id;
  }
  

====================================
FILE: \apps\client-tauri\src\core\Renderer.ts
====================================

// apps/client-tauri/src/core/Renderer.ts

import * as THREE from 'three';
import { TEAM_COLORS, TEAM_IDS } from './constants';
import { log } from '../utils/log';
import { ModelFactory } from '../render/ModelFactory';
import { FlagVisual } from '../render/FlagVisual';

type RenderStatePlayer = {
  type: 'player';
  pos: { x: number; y: number; z: number };
  rot: number;   // yaw in radians
  pitch: number; // pitch in radians
  team: number;  // TEAM_IDS.*
};

type RenderStateFlag = {
  type: 'flag';
  pos: { x: number; y: number; z: number };
  team: number;      // TEAM_IDS.*
  progress: number;  // capture progress (-1..1 or 0..1)
};

export type RenderState = RenderStatePlayer | RenderStateFlag;

/**
 * Thin 3D renderer for bf42lite.
 *
 * Responsibilities:
 * - Own Three.js Scene / Camera / WebGLRenderer
 * - Maintain a map of ECS entity id -> THREE.Object3D
 * - Provide utility hooks (getCamera, drawTracer, updateEntity, render)
 *
 * It does NOT know about ECS directly; it only consumes RenderState.
 */
export class Renderer {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;

  // Map ECS entity IDs -> ThreeJS objects (Mesh or Group)
  private entities = new Map<number, THREE.Object3D>();

  // Optional hooks used by RemoteEntitySync
  public onEntityCreated?: (id: number) => void;
  public onEntityUpdated?: (id: number) => void;

  constructor() {
    // --- Scene ---
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x87ceeb); // sky blue
    this.scene.fog = new THREE.Fog(0x87ceeb, 20, 150);

    // --- Ground plane (simple arena) ---
    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshPhongMaterial({ color: 0x558855 }),
    );
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    this.scene.add(plane);

    // --- Camera ---
    const aspect = window.innerWidth / window.innerHeight;
    this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 500);
    this.camera.position.set(0, 10, 20);
    this.camera.lookAt(0, 0, 0);

    // --- Lights ---
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(20, 40, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.left = -80;
    dirLight.shadow.camera.right = 80;
    dirLight.shadow.camera.top = 80;
    dirLight.shadow.camera.bottom = -80;
    this.scene.add(dirLight);

    const ambient = new THREE.AmbientLight(0x505050);
    this.scene.add(ambient);

    // --- WebGLRenderer ---
    const canvas = document.getElementById('game') as HTMLCanvasElement | null;
    if (!canvas) {
      throw new Error('Renderer: <canvas id="game"> not found in DOM');
    }

    this.renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
    });
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.setSize(window.innerWidth, window.innerHeight);

    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      this.camera.aspect = w / h;
      this.camera.updateProjectionMatrix();
      this.setSize(w, h);
    });

    log.info('RENDER', 'Renderer initialized');
  }

  // ---------------------------------------------------------------------------
  // Public API
  // ---------------------------------------------------------------------------

  public getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  public setSize(width: number, height: number): void {
    this.renderer.setSize(width, height);
  }

  /**
   * Main entry point from worldRender / RemoteEntitySync.
   *
   * If the entity does not exist, it is created; otherwise its transform
   * and visuals are updated in-place.
   */
  public updateEntity(
    id: number,
    state: RenderState,
    isLocalPlayer: boolean,
  ): void {
    let object = this.entities.get(id);

    if (!object) {
      object = this.createObjectForState(state, isLocalPlayer);
      this.scene.add(object);
      this.entities.set(id, object);

      if (this.onEntityCreated) {
        this.onEntityCreated(id);
      }
    }

    this.applyStateToObject(object, state, isLocalPlayer);

    if (this.onEntityUpdated) {
      this.onEntityUpdated(id);
    }
  }

  /**
   * Debug / cosmetic tracer used by WeaponSystem.
   */
  public drawTracer(start: THREE.Vector3, end: THREE.Vector3): void {
    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    const material = new THREE.LineBasicMaterial({ color: 0xffdd33 });
    const line = new THREE.Line(geometry, material);
    this.scene.add(line);

    // Remove shortly after
    window.setTimeout(() => {
      this.scene.remove(line);
      geometry.dispose();
      material.dispose();
    }, 100);
  }

  /**
   * Render one frame.
   */
  public render(): void {
    this.renderer.render(this.scene, this.camera);
  }

  // ---------------------------------------------------------------------------
  // Object creation helpers
  // ---------------------------------------------------------------------------

  private createObjectForState(
    state: RenderState,
    _isLocalPlayer: boolean,
  ): THREE.Object3D {
    if (state.type === 'player') {
      return ModelFactory.createPlayer();
    } else {
      // Flags currently use a fixed radius (8m) on the client side.
      return ModelFactory.createFlag(8.0);
    }
  }

  // ---------------------------------------------------------------------------
  // State application helpers
  // ---------------------------------------------------------------------------

  private applyStateToObject(
    object: THREE.Object3D,
    state: RenderState,
    isLocalPlayer: boolean,
  ): void {
    if (state.type === 'player') {
      const playerState = state as RenderStatePlayer;
      const group = object as THREE.Group;

      // Position + rotation for the soldier mesh
      group.position.set(
        playerState.pos.x,
        playerState.pos.y,
        playerState.pos.z,
      );
      group.rotation.y = playerState.rot;
      group.userData.team = playerState.team;

      // Team tint on body, if present
      const body = group.getObjectByName('body') as THREE.Mesh | null;
      if (body) {
        const bodyMat = body.material as THREE.MeshPhongMaterial;
        bodyMat.color.setHex(this.getTeamColor(playerState.team));
      }

      if (isLocalPlayer) {
        // First-person camera placement
        this.camera.position.set(
          playerState.pos.x,
          playerState.pos.y + 1.6, // eye height
          playerState.pos.z,
        );

        this.camera.rotation.set(
          playerState.pitch || 0,
          playerState.rot,
          0,
          'YXZ',
        );

        // Hide own body in first person
        group.visible = false;
      } else {
        group.visible = true;
      }

      return;
    }

    // === FLAG LOGIC ===
    const flagState = state as RenderStateFlag;
    const group = object as THREE.Group;

    // Position
    group.position.set(
      flagState.pos.x,
      flagState.pos.y,
      flagState.pos.z,
    );

    // Normalize progress from [-1,1] or [0,1] into [0,1]
    const raw = flagState.progress ?? 0;
    const normalized = THREE.MathUtils.clamp((raw + 1) / 2, 0, 1);

    if (Math.abs(raw) > 0.01) {
      log.debug(
        'RENDER',
        `Flag progress raw=${raw.toFixed(2)} norm=${normalized.toFixed(2)}`,
      );
    }

    // Delegate all visual details (colors, pulses, arrow) to FlagVisual
    FlagVisual.applyState(group, flagState.team, normalized);
  }

  private getTeamColor(team: number): number {
    if (team === TEAM_IDS.AXIS) return TEAM_COLORS.AXIS as number;
    if (team === TEAM_IDS.ALLIES) return TEAM_COLORS.ALLIES as number;
    return TEAM_COLORS.NEUTRAL as number;
  }
}


====================================
FILE: \apps\client-tauri\src\core\WeaponConfigLoader.ts
====================================

export interface WeaponConfig {
  id: number;
  key: string;
  name: string;
  damage_per_hit: number;
  fire_rate: number;
  mag_size: number;
  reserve_ammo: number;
  recoil: number;
}

export async function loadWeaponConfig(): Promise<WeaponConfig[]> {
  const res = await fetch("weapons.json");
  if (!res.ok) {
    console.error("[WEAPONS] Failed to load weapons.json");
    return [];
  }
  return await res.json();
}


====================================
FILE: \apps\client-tauri\src\core\WeaponSystem.ts
====================================

//D:\bf42lite\apps\client-tauri\src\core\WeaponSystem.ts

import * as THREE from 'three';
import { Renderer } from './Renderer';
import { NetworkManager } from '../managers/NetworkManager';
import { InputState } from '@bf42lite/engine-core';

import type { WeaponConfig } from './WeaponConfigLoader';
import { loadWeaponConfig } from './WeaponConfigLoader';
import type { ClassConfig } from './ClassConfigLoader';
import { loadClassConfig } from './ClassConfigLoader';
import type { HUDUpdater } from '../ui/HUDUpdater';

/**
 * Data-driven WeaponSystem:
 * - Loads weapons.json / classes.json (same data as server)
 * - Tracks current class and its primary weapon
 * - Enforces client-side fire cadence using weapon.fire_rate
 * - Sends fire commands; server does hitscan + damage
 * - Drives a purely visual crosshair spread effect
 */
export class WeaponSystem {
  private lastFireTime = 0;          // seconds
  private readonly RANGE = 100;

  private raycaster = new THREE.Raycaster();

  // Current class (numeric ID coming from UI / snapshot)
  public currentClassId: number = 0;

  private weaponsById = new Map<number, WeaponConfig>();
  private classesById = new Map<number, ClassConfig>();

  private isLoaded = false;

// Crosshair â€œpulseâ€ state
private crosshairSpread = 0;
private lastShootTick: number | null = null;

  constructor(
    private renderer: Renderer,
    private net: NetworkManager,
    private hud: HUDUpdater,
  ) {
    // Fire-and-forget config load; if not ready yet, update() is a no-op.
    void this.loadConfigs();
  }

  /**
   * Called by UI / snapshot when local player selects a class.
   * Safe to call even before JSON is loaded.
   */
  public setClass(classId: number) {
    this.currentClassId = classId;

    if (!this.isLoaded) {
      // Will be resolved once configs are loaded
      return;
    }

    const classCfg = this.classesById.get(classId);
    if (!classCfg) {
      console.warn('[WeaponSystem] setClass: unknown class id', classId);
    }
  }

  /**
   * Per-frame update:
   * - Decays crosshair spread and pushes it to HUD.
   * - Checks if current weapon exists.
   * - Reads InputState for myEntityId.
   * - Enforces fire_rate from weapon config.
   * - Sends fire command to server.
   * - Bumps crosshair spread on each successful shot.
   */
  public update(dt: number, myEntityId: number, currentTick: number) {
    // Only animate when we are actually alive / rendered.
    const isAlive = myEntityId >= 0 && this.renderer.hasEntity(myEntityId);
    if (!isAlive) {
      this.crosshairSpread = 0;
      this.hud.updateCrosshair(0);
      return;
    }
  
    const btns = InputState.buttons[myEntityId] || 0;
    const shooting = !!(btns & this.BUTTON_SHOOT);
  
    // Treat â€œshootingâ€ simply as: mouse is down.
    // Or keep lastShootTick if you want only 1 pulse per tick:
    const isFiringThisFrame = shooting;
  
    // Update spread
    this.updateCrosshairDecay(dt, isFiringThisFrame);
  
    // Push to HUD every frame
    this.hud.updateCrosshair(this.crosshairSpread);
  }  

  // === Internal helpers ===

  private getCurrentWeapon(): WeaponConfig | null {
    const classCfg = this.classesById.get(this.currentClassId);
    if (!classCfg) {
      // Optional: fallback to class 0 if present
      const fallback = this.classesById.get(0);
      if (!fallback) return null;
      return this.weaponsById.get(fallback.primary_weapon_id) ?? null;
    }

    return this.weaponsById.get(classCfg.primary_weapon_id) ?? null;
  }

  private fire(tick: number) {
    const camera = this.renderer.getCamera();
    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    const start = camera.position.clone();
    const direction = this.raycaster.ray.direction.clone();
    const end = start.clone().add(direction.clone().multiplyScalar(this.RANGE));

    // Server-authoritative fire command
    this.net.sendFire(
      { x: start.x, y: start.y, z: start.z },
      { x: direction.x, y: direction.y, z: direction.z },
      tick,
    );

    // Visual tracer slightly offset from camera
    const visualOffset = new THREE.Vector3(0.2, -0.2, 0.5);
    visualOffset.applyQuaternion(camera.quaternion);
    const visualStart = start.clone().add(visualOffset);

    this.renderer.drawTracer(visualStart, end);
  }

  // --- Crosshair helpers (visual only) ---

  private updateCrosshairDecay(dt: number, isFiringThisFrame: boolean) {
    // If we fired this frame, kick spread to 1.0 (max visual).
    if (isFiringThisFrame) {
      this.crosshairSpread = 1.0;
    } else {
      // Otherwise, decay quickly back to 0.
      const DECAY_PER_SECOND = 6.0; // tweak for feel
      this.crosshairSpread -= DECAY_PER_SECOND * dt;
      if (this.crosshairSpread < 0) this.crosshairSpread = 0;
    }
  }

  private async loadConfigs() {
    try {
      const [weapons, classes] = await Promise.all([
        loadWeaponConfig(),
        loadClassConfig(),
      ]);

      this.weaponsById.clear();
      for (const w of weapons) {
        this.weaponsById.set(w.id, w);
      }

      this.classesById.clear();
      for (const c of classes) {
        this.classesById.set(c.id, c);
      }

      this.isLoaded = true;

      console.log('[WeaponSystem] Loaded weapons:', weapons);
      console.log('[WeaponSystem] Loaded classes:', classes);

      // If currentClassId has a valid class, we are ready;
      // otherwise, try default class 0.
      if (!this.classesById.has(this.currentClassId) && this.classesById.has(0)) {
        this.currentClassId = 0;
      }
    } catch (err) {
      console.error('[WeaponSystem] Failed to load weapon/class config:', err);
      this.isLoaded = false;
    }
  }
}


====================================
FILE: \apps\client-tauri\src\managers\NetworkManager.ts
====================================

// apps/client-tauri/src/managers/NetworkManager.ts

import { WebSocketAdapter, type NetworkAdapter } from '@bf42lite/net';
import type {
  ClientInput,
  ClientFire,
  ClientMessage,
  Snapshot,
} from '@bf42lite/protocol';
import type { SimWorld } from '@bf42lite/engine-core';
import { log } from '../utils/log';

import type { Renderer } from '../core/Renderer';
import type { Reconciler } from '../systems/Reconciler';

import { decodeServerMessage } from '../net/SnapshotDecoder';
// after previous step:
import { RemoteEntitiesSystem } from '../systems/RemoteEntitiesSystem';
import { FlagSystem } from '../systems/FlagSystem';
import { interpolateRemotePlayers as interpRemote } from '../systems/interpolationHelpers';

// Local wire type for spawn request â€“ must match Rust/zod schema
type SpawnRequestWire = {
  type: 'spawn_request';
  classId: number;
};

export class NetworkManager {
  // --- Callbacks exposed to ClientGame / UI ---

  onConnected: () => void = () => {};
  onDisconnected: () => void = () => {};
  onWelcome: (serverId: number) => void = () => {};
  onSnapshot: (snap: Snapshot) => void = () => {};
  onHitConfirmed: (damage: number) => void = () => {};

  // --- Internal state ---

  private net: NetworkAdapter;
  private world: SimWorld;
  private renderer: Renderer;
  private reconciler: Reconciler;

  private myServerId = -1;
  private serverToLocal = new Map<number, number>();

  // Monotonic counter used by decodeServerMessage (for timestamps/ticks)
  private nextTick = 0;

  constructor(world: SimWorld, renderer: Renderer, reconciler: Reconciler) {
    this.world = world;
    this.renderer = renderer;
    this.reconciler = reconciler;

    this.net = new WebSocketAdapter();

    this.net.onConnect(() => {
      log.info('NET', 'Connected');
      this.onConnected();
    });

    this.net.onDisconnect(() => {
      log.warn('NET', 'Disconnected');
      this.onDisconnected();
    });

    this.net.onMessage((raw) => this.handleMessage(raw));
  }

  // --- Connection ---

  connect(url: string): void {
    this.net.connect(url);
  }

  // --- Incoming messages ---

  private handleMessage(raw: unknown): void {
    const decoded = decodeServerMessage(raw, this.nextTick++);
    const nowTs = performance.now();

    switch (decoded.type) {
      case 'welcome': {
        this.myServerId = decoded.yourId;
        log.info('NET', 'Welcome', { serverId: this.myServerId });
        this.onWelcome(this.myServerId);
        return;
      }

      case 'hit-confirmed': {
        log.debug('NET', 'Hit confirmed', { dmg: decoded.damage });
        this.onHitConfirmed(decoded.damage);
        return;
      }

case 'snapshot': {
  const snapshot = decoded.snapshot;

  // Remote entities (ECS + interpolation buffers)
  RemoteEntitiesSystem.apply(
    snapshot,
    this.world,
    this.renderer,
    this,
    this.reconciler,
    nowTs,
  );

  // Conquest / flags ECS state
  FlagSystem.applySnapshotFlags(snapshot, this.world);

  // Forward to ClientGame (sync local player, UI, etc.)
  this.onSnapshot(snapshot);

  return;
}

      case 'unknown':
      default: {
        // Keep in console for debugging â€“ raw is preserved
        console.warn('[NET] Unhandled server message:', decoded.raw);
        return;
      }
    }
  }

  // --- Entity registry (server â†” local ECS ids) ---

  registerEntity(serverId: number, localId: number): void {
    this.serverToLocal.set(serverId, localId);
  }

  getLocalId(serverId: number): number | undefined {
    return this.serverToLocal.get(serverId);
  }

  // --- Outgoing: input / fire / spawn ---

  /** Alias kept for existing code: client uses `net.send(cmd)` */
  send(cmd: ClientInput): void {
    this.sendInput(cmd);
  }

  sendInput(cmd: ClientInput): void {
    this.net.send(cmd);
  }

  sendFire(
    origin: { x: number; y: number; z: number },
    direction: { x: number; y: number; z: number },
    tick: number,
  ): void {
    const msg: ClientFire = {
      type: 'fire',
      tick,
      origin,
      direction,
      // Mirror of current WeaponSystem config â€“ adjust when you add more weapons
      weaponId: 1,
    };
    this.net.send(msg);
  }

  sendSpawnRequest(classId: number): void {
    const msg: SpawnRequestWire = {
      type: 'spawn_request',
      classId,
    };
    this.net.send(msg as ClientMessage);
  }

  // --- Interpolation hook used by ClientGame / InterpolationSystem ---

  interpolateRemotePlayers(renderTimeMs: number): void {
    interpRemote(this.world, this.reconciler.remoteBuffers, renderTimeMs);
  }
}


====================================
FILE: \apps\client-tauri\src\managers\UIManager.ts
====================================

// apps/client-tauri/src/managers/UIManager.ts

export class UIManager {
    private ui: {
        deployScreen: HTMLElement | null;
        hudLayer: HTMLElement | null;
        healthVal: HTMLElement | null;
        healthFill: HTMLElement | null;
        spawnBtn: HTMLElement | null;
        ticketsAxis: HTMLElement | null;
        ticketsAllies: HTMLElement | null;
        fps: HTMLElement | null;
        rtt: HTMLElement | null;
        hitmarker: HTMLElement | null;
        gameOverScreen: HTMLElement | null;
        endTitle: HTMLElement | null;
        ammoCurr: HTMLElement | null;
        ammoRes: HTMLElement | null;
        weaponName: HTMLElement | null;

        objectiveText: HTMLElement | null;
        flagStrip: HTMLElement | null;
        centerStatus: HTMLElement | null;
        flagList: HTMLElement | null;
        killFeed: HTMLElement | null;
        crosshair: HTMLElement | null;

    };

    private selectedSpawnId = -1;
    private hitTimeout: number | null = null;

    private onSpawnRequest: (classId: number) => void;
    private selectedClassId = 0; // Default to Assault

    constructor(onSpawnRequest: (classId: number) => void) {
        this.onSpawnRequest = onSpawnRequest;

        this.ui = {
            deployScreen: document.getElementById('deploy-screen'),
            hudLayer: document.getElementById('hud-layer'),
            healthVal: document.getElementById('health-val'),
            healthFill: document.getElementById('health-fill'),
            spawnBtn: document.getElementById('btn-spawn'),
            ticketsAxis: document.getElementById('tickets-axis'),
            ticketsAllies: document.getElementById('tickets-allies'),
            fps: document.getElementById('fps'),
            rtt: document.getElementById('rtt'),
            hitmarker: document.getElementById('hitmarker'),
            gameOverScreen: document.getElementById('game-over-screen'),
            endTitle: document.getElementById('end-title'),
            ammoCurr: document.getElementById('ammo-curr'),
            ammoRes: document.getElementById('ammo-res'),
            weaponName: document.getElementById('weapon-name'),

            objectiveText: document.getElementById('objective-text'),
            flagStrip: document.getElementById('flag-strip'),
            centerStatus: document.getElementById('center-status'),
            flagList: document.getElementById('flag-list'),
            killFeed: document.getElementById('kill-feed'),

            crosshair: document.getElementById('crosshair'),

        };
        this.initListeners();
    }
    /**
     * Crosshair spread animation (0 = tight, >0 = expanded).
     * We simply bump the font size for a simple â€œbreathingâ€ effect.
     */
    public setCrosshairSpread(spread: number) {
        if (!this.ui.crosshair) return;
      
        // Expect 0..1 from WeaponSystem and clamp it
        const clamped = Math.max(0, Math.min(spread, 1));
        const px = clamped * 10; // max +10px
      
        const top = this.ui.crosshair.querySelector('.ch-top') as HTMLElement | null;
        const bottom = this.ui.crosshair.querySelector('.ch-bottom') as HTMLElement | null;
        const left = this.ui.crosshair.querySelector('.ch-left') as HTMLElement | null;
        const right = this.ui.crosshair.querySelector('.ch-right') as HTMLElement | null;
      
        if (top) top.style.marginTop = `-${20 + px}px`;
        if (bottom) bottom.style.marginTop = `${8 + px}px`;
        if (left) left.style.marginLeft = `-${20 + px}px`;
        if (right) right.style.marginLeft = `${8 + px}px`;
      }      
   
    private initListeners() {
        // 1. Class Selection Listeners
        const classBtns = document.querySelectorAll('.class-btn');
        classBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                classBtns.forEach(b => b.classList.remove('selected'));
                const target = e.currentTarget as HTMLElement;
                target.classList.add('selected');

                const id = target.getAttribute('data-id');
                if (id) this.selectedClassId = parseInt(id, 10) || 0;
            });
        });

        // 2. Map / Spawn Point Click Listener
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
            mapContainer.addEventListener('click', (e: Event) => {
                const target = (e.target as HTMLElement).closest('.spawn-point') as HTMLElement | null;
                if (!target) return;

                document
                    .querySelectorAll('.spawn-point')
                    .forEach(el => el.classList.remove('selected'));
                target.classList.add('selected');

                this.selectedSpawnId = parseInt(target.dataset.id || '-1', 10);
            });
        }

// 3. Spawn Button Click Listener
if (this.ui.spawnBtn) {
    this.ui.spawnBtn.addEventListener('click', () => {
        // Require a spawn point selection
        if (this.selectedSpawnId < 0) {
            this.setCenterStatus('Select a spawn point first.');
            console.warn('[UI] Deploy clicked but no spawn point selected');
            return;
        }

        // Optimistic deploy: hide deploy screen immediately.
        this.setDeployMode(false);
        this.setCenterStatus('Spawning...');
        setTimeout(() => this.setCenterStatus(''), 800);

        // Let the server know which class we chose.
        this.onSpawnRequest(this.selectedClassId);
    });
}
    }

    // Show / hide deploy vs in-game HUD
    public setDeployMode(isDeploying: boolean) {
        if (isDeploying) {
            this.ui.deployScreen?.classList.remove('hidden');
            this.ui.hudLayer?.classList.add('hidden');
            document.exitPointerLock();
            if (this.ui.centerStatus) this.ui.centerStatus.innerText = '';
        } else {
            this.ui.deployScreen?.classList.add('hidden');
            this.ui.hudLayer?.classList.remove('hidden');

            const canvas = document.getElementById('game') as HTMLCanvasElement | null;
            if (canvas && document.pointerLockElement !== canvas) {
                canvas.requestPointerLock?.();
            }
        }
    }

    // Debug overlay stats
    public updateStats(fps: number, rtt: number) {
        if (this.ui.fps) this.ui.fps.innerText = fps.toFixed(0);
        if (this.ui.rtt) this.ui.rtt.innerText = rtt.toFixed(0);
    }

    public updateHealth(current: number) {
        if (this.ui.healthVal) this.ui.healthVal.innerText = current.toString();
        if (this.ui.healthFill) this.ui.healthFill.style.width = `${current}%`;
    }

    // Tickets + objective text
    public updateTickets(axis: number, allies: number) {
        // Round for display but keep logic using original floats
        const axisRounded = Math.max(0, Math.round(axis));
        const alliesRounded = Math.max(0, Math.round(allies));

        // AXIS
        if (this.ui.ticketsAxis) {
            this.ui.ticketsAxis.innerText = axisRounded.toString();

            if (axisRounded <= 20) this.ui.ticketsAxis.classList.add('low');
            else this.ui.ticketsAxis.classList.remove('low');
        }

        // ALLIES
        if (this.ui.ticketsAllies) {
            this.ui.ticketsAllies.innerText = alliesRounded.toString();

            if (alliesRounded <= 20) this.ui.ticketsAllies.classList.add('low');
            else this.ui.ticketsAllies.classList.remove('low');
        }

        // OBJECTIVE TEXT (still uses float logic, works fine)
        if (this.ui.objectiveText) {
            if (axis <= 0 && allies > 0) {
                this.ui.objectiveText.innerText = 'ALLIES ARE WINNING â€“ HOLD YOUR FLAGS';
            } else if (allies <= 0 && axis > 0) {
                this.ui.objectiveText.innerText = 'AXIS ARE WINNING â€“ HOLD YOUR FLAGS';
            } else {
                this.ui.objectiveText.innerText = 'CAPTURE AND HOLD THE FLAGS';
            }
        }
    }

    // Center status line (respawn / capturing hints)
    public setCenterStatus(text: string) {
        if (this.ui.centerStatus) {
            this.ui.centerStatus.innerText = text;
        }
    }

    /**
     * High-level entry point for all flag HUD elements.
     *
     * - Clears both strip + list if there are no flags.
     * - Uses raw snapshot objects for the mini strip.
     * - Normalizes data for the detailed list.
     */
    public updateFlagsHUD(rawFlags: any[] | undefined | null) {
        const flags = rawFlags ?? [];

        // No flags: clear both HUD elements and bail.
        if (!flags.length) {
            if (this.ui.flagStrip) {
                this.ui.flagStrip.innerHTML = '';
            }
            if (this.ui.flagList) {
                this.ui.flagList.innerHTML = '';
            }
            return;
        }

        // Mini strip uses the raw snapshot objects (id + owner).
        this.updateFlagStrip(flags as { id: number; owner: any }[]);

        // Detailed list uses a small normalized DTO.
        this.updateFlagList(
            flags.map((f: any) => ({
                id: f.id,
                owner: f.owner,
                capture: typeof f.capture === 'number' ? f.capture : 0,
            })),
        );
    }

    // Mini flag-strip at top center
    public updateFlagStrip(flags: { id: number; owner: any }[]) {
        if (!this.ui.flagStrip) return;
        const root = this.ui.flagStrip;
        root.innerHTML = '';

        flags.forEach((f) => {
            const div = document.createElement('div');
            div.classList.add('flag-mini');

            let cls = 'neutral';
            if (f.owner === 'TeamA' || f.owner === 1) cls = 'axis';
            else if (f.owner === 'TeamB' || f.owner === 2) cls = 'allies';

            div.classList.add(cls);
            root.appendChild(div);
        });
    }

    // Detailed flag list bottom-left
    public updateFlagList(flags: { id: number; owner: any; capture: number }[]) {
        if (!this.ui.flagList) return;
        const root = this.ui.flagList;
        root.innerHTML = '';

        flags.forEach((f) => {
            const row = document.createElement('div');
            row.classList.add('flag-row');

            const name = document.createElement('span');
            name.classList.add('flag-name');
            name.innerText = `Flag ${f.id}`;

            const owner = document.createElement('span');
            owner.classList.add('flag-owner');

            let ownerCls = 'neutral';
            let label = 'NEUTRAL';

            if (f.owner === 'TeamA' || f.owner === 1) {
                ownerCls = 'axis';
                label = 'AXIS';
            } else if (f.owner === 'TeamB' || f.owner === 2) {
                ownerCls = 'allies';
                label = 'ALLIES';
            }

            owner.classList.add(ownerCls);
            owner.innerText = label;

            const bar = document.createElement('div');
            bar.classList.add('flag-progress');

            const fill = document.createElement('div');
            fill.classList.add('flag-progress-fill');

            const t = Math.min(1, Math.abs(f.capture || 0));
            fill.style.width = `${t * 100}%`;

            bar.appendChild(fill);
            row.appendChild(name);
            row.appendChild(owner);
            row.appendChild(bar);

            root.appendChild(row);
        });
    }

    // Kill feed on the right side
    public pushKillFeed(killer: string, victim: string, weapon?: string) {
        if (!this.ui.killFeed) return;

        const entry = document.createElement('div');
        entry.classList.add('kill-entry');

        const weaponText = weapon ? ` [${weapon}]` : '';
        entry.innerText = `${killer} âžœ ${victim}${weaponText}`;

        this.ui.killFeed.prepend(entry);

        while (this.ui.killFeed.children.length > 5) {
            this.ui.killFeed.removeChild(this.ui.killFeed.lastChild as Node);
        }

        setTimeout(() => {
            entry.classList.add('fade-out');
            setTimeout(() => entry.remove(), 500);
        }, 3000);
    }

    public showHitMarker(_damage?: number) {
        if (!this.ui.hitmarker) return;
        this.ui.hitmarker.classList.remove('hit-active');
        void this.ui.hitmarker.offsetWidth;
        this.ui.hitmarker.classList.add('hit-active');

        if (this.hitTimeout) clearTimeout(this.hitTimeout);
        this.hitTimeout = window.setTimeout(() => {
            if (this.ui.hitmarker) {
                this.ui.hitmarker.classList.remove('hit-active');
            }
        }, 200);
    }

    public setGameOver(isGameOver: boolean, winningTeam: string) {
        if (!this.ui.gameOverScreen || !this.ui.endTitle) return;
    
        if (isGameOver) {
            this.ui.gameOverScreen.classList.add('visible');
            this.ui.endTitle.innerText = winningTeam;
            document.exitPointerLock?.();
        } else {
            this.ui.gameOverScreen.classList.remove('visible');
            this.ui.endTitle.innerText = '';
        }
    }    

    public updateAmmo(current: number, reserve: number, weaponName?: string) {
        if (this.ui.ammoCurr) this.ui.ammoCurr.innerText = current.toString();
        if (this.ui.ammoRes) this.ui.ammoRes.innerText = reserve.toString();
        if (this.ui.weaponName && weaponName) this.ui.weaponName.innerText = weaponName;
    }

    // Respawn timer â†’ center status and spawn button text
    public updateRespawn(isDead: boolean, timer: number) {
        const t = Math.max(0, timer); // extra safety clamp
    
        if (isDead) {
            // Spawn button state (if present)
            if (this.ui.spawnBtn) {
                if (t > 0) {
                    this.ui.spawnBtn.innerText = `Deploy in ${t.toFixed(1)}s`;
                    this.ui.spawnBtn.setAttribute('disabled', 'true');
                    this.ui.spawnBtn.style.pointerEvents = 'none';
                    this.ui.spawnBtn.style.opacity = '0.5';
                } else {
                    this.ui.spawnBtn.innerText = 'DEPLOY (Press SPACE)';
                    this.ui.spawnBtn.removeAttribute('disabled');
                    this.ui.spawnBtn.style.pointerEvents = 'auto';
                    this.ui.spawnBtn.style.opacity = '1.0';
                }
            }
    
            // Center status â€“ independent of whether the button exists
            if (t > 0) {
                this.setCenterStatus(`Respawning in ${t.toFixed(1)}s`);
            } else {
                this.setCenterStatus('Press SPACE or click DEPLOY to respawn');
            }
        } else {
            // Alive: clear center status and reset button visuals (even though deploy UI is hidden)
            if (this.ui.spawnBtn) {
                this.ui.spawnBtn.innerText = 'DEPLOY';
                this.ui.spawnBtn.removeAttribute('disabled');
                this.ui.spawnBtn.style.pointerEvents = 'auto';
                this.ui.spawnBtn.style.opacity = '1.0';
            }
            this.setCenterStatus('');
        }
    }    
}


====================================
FILE: \apps\client-tauri\src\net\CommandSender.ts
====================================

// apps/client-tauri/src/net/CommandSender.ts

import type { ClientInput } from '@bf42lite/protocol';
import type { NetworkManager } from '../managers/NetworkManager';

/**
 * CommandSender is responsible for:
 * - Accumulating frame time (dt)
 * - Throttling client input sends to a fixed interval
 * - Forwarding commands to NetworkManager
 *
 * It does NOT know about ECS, prediction, or rendering.
 */
export class CommandSender {
  private accumulator = 0;
  private readonly sendInterval: number;
  private readonly net: NetworkManager;

  /**
   * @param net          NetworkManager instance used to actually send commands.
   * @param sendInterval Interval in seconds between input sends (default 1/30 â‰ˆ 33 ms).
   */
  constructor(net: NetworkManager, sendInterval: number = 1 / 30) {
    this.net = net;
    this.sendInterval = sendInterval;
  }

  /**
   * Advance the internal timer and send the given command when the
   * accumulated time exceeds the configured interval.
   *
   * You should call this once per frame from the main game loop.
   *
   * @param dt   Delta time in seconds since last frame.
   * @param cmd  The current frame's input command (or null/undefined if none).
   */
  public update(dt: number, cmd: ClientInput | null | undefined): void {
    this.accumulator += dt;

    while (this.accumulator >= this.sendInterval) {
      if (cmd) {
        this.net.send(cmd);
      }
      this.accumulator -= this.sendInterval;
    }
  }

  /**
   * Reset the accumulator. Useful when pausing/unpausing or on major
   * time jumps (e.g. after a long tab-out).
   */
  public reset(): void {
    this.accumulator = 0;
  }
}


====================================
FILE: \apps\client-tauri\src\net\SnapshotDecoder.ts
====================================

// apps/client-tauri/src/net/SnapshotDecoder.ts

import type {
  Snapshot,
  FlagSnapshot,
  GameModeState,
} from '@bf42lite/protocol';
import type { DecodedServerMessage } from './types';

/**
 * Normalize flag snapshots coming from Rust/host into uniform object form.
 * Supports both:
 *   - Array layout: [id, x, y, z, radius, ownerStr, capture]
 *   - Object layout: { id, pos: {x,y,z}, radius, owner, capture }
 */
export function normalizeFlags(raw: any[] | undefined | null): FlagSnapshot[] {
  const src = raw ?? [];

  return src.map((f: any): FlagSnapshot => {
    if (Array.isArray(f)) {
      const id = f[0];
      const x = f[1];
      const y = f[2];
      const z = f[3];
      const radius = f[4] ?? 0;
      const owner = f[5] ?? null;
      const capture = typeof f[6] === 'number' ? f[6] : 0;

      return {
        id: id ?? 0,
        x: x ?? 0,
        y: y ?? 0,
        z: z ?? 0,
        radius,
        owner,
        capture,
      };
    }

    const pos = f.pos ?? {};
    const x = f.x ?? pos.x ?? 0;
    const y = f.y ?? pos.y ?? 0;
    const z = f.z ?? pos.z ?? 0;
    const radius = f.radius ?? f.r ?? 0;
    const owner = f.owner ?? null;
    const capture = typeof f.capture === 'number' ? f.capture : 0;

    return {
      id: f.id ?? 0,
      x,
      y,
      z,
      radius,
      owner,
      capture,
    };
  });
}

/**
 * Centralized decoder for all server â†’ client messages.
 *
 * `nextTick` should be provided by the caller (NetworkManager) and is used
 * to assign a monotonically increasing tick to snapshots that do not
 * already have a tick number (array / Rust envelopes).
 */
export function decodeServerMessage(
  raw: any,
  nextTick: number,
): DecodedServerMessage {
  // 1) Array-based messages (older/alternate host): [kindId, payload]
  if (Array.isArray(raw)) {
    const arr = raw as any[];

    if (arr.length === 2) {
      const [kindId, payload] = arr;

      // kindId === 1 => snapshot
      if (kindId === 1 && Array.isArray(payload)) {
        const [entitiesRaw, flagsRaw, gameStateRaw] = payload as [
          any[],
          any[],
          any,
        ];

        const flags = normalizeFlags(flagsRaw);

        const game_state: GameModeState | undefined = Array.isArray(
          gameStateRaw,
        )
          ? {
              team_a_tickets: gameStateRaw[0] ?? 0,
              team_b_tickets: gameStateRaw[1] ?? 0,
              match_ended: !!gameStateRaw[2],
              winner: null,
            }
          : gameStateRaw;

        const snapshot: Snapshot = {
          type: 'snapshot',
          tick: nextTick,
          entities: entitiesRaw ?? [],
          flags,
          game_state,
        };

        return { type: 'snapshot', snapshot };
      }
    }

    return { type: 'unknown', raw };
  }

  // 2) Object-style messages (current Rust host + legacy JSON)
  const msg = raw as any;

  // Explicit "welcome" style: { type: 'welcome', yourId }
  if (msg.type === 'welcome' && typeof msg.yourId === 'number') {
    return {
      type: 'welcome',
      yourId: msg.yourId,
    };
  }

  // Legacy JSON snapshot already matching the Snapshot interface
  if (msg.type === 'snapshot') {
    return {
      type: 'snapshot',
      snapshot: msg as Snapshot,
    };
  }

  // Hit confirm notification
  if (msg.type === 'hit-confirmed') {
    return {
      type: 'hit-confirmed',
      damage: msg.damage ?? 0,
    };
  }

  // Rust/Tauri envelope: { your_id, snapshot: { ... } }
  if (msg.snapshot) {
    const rawFlags =
      msg.snapshot.flags || msg.snapshot.flag_snapshots || [];

    const flags = normalizeFlags(rawFlags);

    const snapshot: Snapshot = {
      type: 'snapshot',
      tick: nextTick,
      entities: msg.snapshot.entities ?? [],
      flags,
      game_state: msg.snapshot.game_state,
      game: msg.snapshot.game, // keep for backward compatibility, if present
    };

    const decoded: any = {
      type: 'snapshot' as const,
      snapshot,
    };

    if (typeof msg.your_id === 'number') {
      decoded.yourId = msg.your_id;
    }

    return decoded;
  }

  // Fallback: unknown/unhandled message
  return {
    type: 'unknown',
    raw,
  };
}


====================================
FILE: \apps\client-tauri\src\net\types.ts
====================================

// apps/client-tauri/src/net/types.ts

import type { Snapshot, FlagSnapshot } from '@bf42lite/protocol';

// Normalized flag is already identical to the protocol FlagSnapshot.
// This alias is mainly for readability on the client side.
export type NormalizedFlag = FlagSnapshot;

// Interpolation types for remote entities
export interface InterpolationSnapshot {
  tick: number;
  pos: { x: number; y: number; z: number };
  rot: number;
  timestamp: number;
}

export interface InterpolationBuffer {
  snapshots: InterpolationSnapshot[];
}

// Decoded server messages after passing through the network decoder
export interface DecodedSnapshotMessage {
  type: 'snapshot';
  snapshot: Snapshot;
  // Present when coming from Rust envelope { your_id, snapshot }
  yourId?: number;
}

export interface DecodedWelcomeMessage {
  type: 'welcome';
  yourId: number;
}

export interface DecodedHitMessage {
  type: 'hit-confirmed';
  damage: number;
}

export interface DecodedUnknownMessage {
  type: 'unknown';
  raw: any;
}

export type DecodedServerMessage =
  | DecodedSnapshotMessage
  | DecodedWelcomeMessage
  | DecodedHitMessage
  | DecodedUnknownMessage;


====================================
FILE: \apps\client-tauri\src\render\FlagVisual.ts
====================================

// apps/client-tauri/src/render/FlagVisual.ts
//
// Encapsulates all visual updates for flag objects created by ModelFactory.
// Renderer calls these methods when receiving a RenderStateFlag.

import * as THREE from 'three';
import { TEAM_COLORS, TEAM_IDS } from '../core/constants';

export class FlagVisual {
  /**
   * Apply ECS flag state to a THREE.Group flag instance.
   *
   * @param group    THREE.Group created by ModelFactory.createFlag()
   * @param team     current owning team (numeric ECS ID)
   * @param progress capture progress from -1 â†’ 1
   */
  public static applyState(
    group: THREE.Group,
    team: number,
    progress: number,
  ) {
    const banner = group.getObjectByName('banner') as THREE.Mesh | null;
    const ring = group.getObjectByName('ring') as THREE.Mesh | null;
    const progressDisc = group.getObjectByName('progress') as THREE.Mesh | null;
    const direction = group.getObjectByName('direction') as THREE.Mesh | null;

    if (!banner || !ring || !progressDisc) {
      console.warn('[FlagVisual] Missing banner/ring/progress in flag model');
      return;
    }

    const bannerMat = banner.material as THREE.MeshBasicMaterial;
    const ringMat = ring.material as THREE.MeshBasicMaterial;
    const progMat = progressDisc.material as THREE.MeshBasicMaterial;
    const dirMat = direction
      ? (direction.material as THREE.MeshBasicMaterial)
      : null;

    // Base ownership color from team
    let baseColor = TEAM_COLORS.NEUTRAL as number;
    if (team === TEAM_IDS.AXIS) baseColor = TEAM_COLORS.AXIS as number;
    else if (team === TEAM_IDS.ALLIES) baseColor = TEAM_COLORS.ALLIES as number;

    // Clamp capture progress [-1, 1]
    const raw = typeof progress === 'number' ? progress : 0;
    const clamped = Math.max(-1, Math.min(1, raw));
    const t = Math.abs(clamped); // 0..1

    // Scale progress disc
    progressDisc.scale.set(t, t, t);

    // Time-based pulse for contested / capturing effects
    const time = performance.now() / 1000;
    const pulse = 0.75 + 0.25 * Math.sin(time * 4); // ~0.5..1.0

    // Which team is currently capturing?
    let capturingColor = 0xffffff;
    let capturingTeam: number | null = null;
    if (clamped > 0) {
      capturingColor = TEAM_COLORS.AXIS as number;
      capturingTeam = TEAM_IDS.AXIS;
    } else if (clamped < 0) {
      capturingColor = TEAM_COLORS.ALLIES as number;
      capturingTeam = TEAM_IDS.ALLIES;
    }

    // Lerp white â†’ capturingColor by |progress|
    const white = new THREE.Color(0xffffff);
    const teamCol = new THREE.Color(capturingColor);
    white.lerp(teamCol, t); // â€œwhitishâ€ when low, pure team color when full

    const isCapturing = clamped !== 0;
    const isContested = isCapturing && t < 0.4; // near-neutral but non-zero

    if (!isCapturing) {
      // Idle: banner is owner color, ring is subtle, arrow hidden
      bannerMat.color.setHex(baseColor);
      progMat.color.setHex(0xffffff);
      ringMat.opacity = 0.3;

      if (direction && dirMat) {
        direction.visible = false;
        dirMat.opacity = 0.0;
      }
    } else {
      // Actively being captured: banner + progress use capture color
      bannerMat.color.copy(white);
      progMat.color.copy(white);

      // Ring opacity increases with progress; pulses when â€œcontestedâ€
      const baseOpacity = 0.25 + 0.5 * t; // 0.25 .. 0.75
      ringMat.opacity = baseOpacity * (isContested ? pulse : 1.0);

      if (direction && dirMat && capturingTeam !== null) {
        direction.visible = true;

        // Direction arrow color = capturing team
        dirMat.color.setHex(capturingColor);
        dirMat.opacity = 0.5 + 0.4 * pulse; // subtle pulse

        // Spin direction based on capturing team (A vs B)
        const dirSign = capturingTeam === TEAM_IDS.AXIS ? 1 : -1;
        direction.rotation.z = time * 2.0 * dirSign;
      }
    }
  }
}


====================================
FILE: \apps\client-tauri\src\render\ModelFactory.ts
====================================

// apps/client-tauri/src/render/ModelFactory.ts
//
// Central factory for all Three.js models used by the client.
// This keeps geometry/material creation out of Renderer and makes
// it easier to evolve visuals later (LOD, different styles, etc.).

import * as THREE from 'three';
import { TEAM_COLORS } from '../core/constants';

export class ModelFactory {
  /**
   * Create the standard infantry soldier object.
   *
   * We return a THREE.Group so we can name parts (body/head) and
   * recolor the body later based on team.
   */
  public static createPlayer(): THREE.Group {
    const group = new THREE.Group();
    group.name = 'player';

    // Body
    const bodyGeom = new THREE.BoxGeometry(0.6, 1.6, 0.4);
    const bodyMat = new THREE.MeshPhongMaterial({
      color: TEAM_COLORS.NEUTRAL,
    });
    const body = new THREE.Mesh(bodyGeom, bodyMat);
    body.castShadow = true;
    body.name = 'body';
    group.add(body);

    // Head
    const headGeom = new THREE.SphereGeometry(0.3, 16, 16);
    const headMat = new THREE.MeshPhongMaterial({ color: 0xffe0bd });
    const head = new THREE.Mesh(headGeom, headMat);
    head.position.y = 1.1;
    head.castShadow = true;
    head.name = 'head';
    group.add(head);

    return group;
  }

  /**
   * Create a complete flag group:
   * - Base cylinder
   * - Pole (named "pole")
   * - Banner (Plane, named "banner")
   * - Capture ring (named "ring")
   * - Progress disc (Circle, named "progress")
   * - Capture direction arrow (Plane, named "direction")
   *
   * All color logic (team/ownership/progress) is handled in FlagVisual;
   * this factory only creates neutral-colored geometry.
   *
   * @param radius Capture radius for the ring and disc (default 8.0)
   */
  public static createFlag(radius: number = 8.0): THREE.Group {
    const group = new THREE.Group();
    group.name = 'flag';

    // A. Base
    const baseGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
    const baseMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
    const base = new THREE.Mesh(baseGeom, baseMat);
    base.castShadow = true;
    base.receiveShadow = true;
    base.name = 'base';
    group.add(base);

    // B. Pole
    const poleGeom = new THREE.CylinderGeometry(0.1, 0.1, 4, 8);
    const poleMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const pole = new THREE.Mesh(poleGeom, poleMat);
    pole.position.y = 2.2;
    pole.castShadow = true;
    pole.name = 'pole';
    group.add(pole);

    // C. Banner
    const bannerGeom = new THREE.PlaneGeometry(1.8, 1.2);
    const bannerMat = new THREE.MeshBasicMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
    });
    const banner = new THREE.Mesh(bannerGeom, bannerMat);
    banner.position.set(0.9, 2.8, 0);
    banner.rotation.y = Math.PI / 2;
    banner.name = 'banner';
    group.add(banner);

    // D. Capture radius ring
    const ringGeom = new THREE.RingGeometry(radius - 0.3, radius, 64);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.6,
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.01;
    ring.name = 'ring';
    group.add(ring);

    // E. Progress disc (fills as the point is being captured)
    const progGeom = new THREE.CircleGeometry(radius, 64);
    const progMat = new THREE.MeshBasicMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.4,
    });
    const progress = new THREE.Mesh(progGeom, progMat);
    progress.rotation.x = -Math.PI / 2;
    progress.position.y = 0.02;
    progress.scale.set(0, 0, 0); // no capture at start
    progress.name = 'progress';
    group.add(progress);

    // F. Direction arrow: shows capture direction / team color
    const arrowGeom = new THREE.PlaneGeometry(radius * 0.5, radius * 0.12);
    const arrowMat = new THREE.MeshBasicMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.0, // hidden until capture starts
    });
    const arrow = new THREE.Mesh(arrowGeom, arrowMat);
    arrow.position.set(radius * 0.75, 0.03, 0);
    arrow.rotation.x = -Math.PI / 2;
    arrow.name = 'direction';
    group.add(arrow);

    return group;
  }
}


====================================
FILE: \apps\client-tauri\src\systems\FlagSystem.ts
====================================

// apps/client-tauri/src/systems/FlagSystem.ts
//
// ECS-side management of Conquest flags on the client.
// - Ensures each server flag has a corresponding ECS entity.
// - Writes Transform + CapturePoint data from Snapshot.flags.
//
// This is functionally equivalent to the earlier FlagSync helper,
// but lives under /systems to match the modular client architecture.

import {
  Transform,
  addComponent,
  addEntity,
} from '@bf42lite/engine-core';

import { CapturePoint } from '@bf42lite/games-bf42';

import type { Snapshot } from '@bf42lite/protocol';

export class FlagSystem {
  // Map from protocol flag id â†’ ECS entity id
  private static flagMap = new Map<number, number>();

  /**
   * Ensure that a flag ECS entity exists for the given protocol flag id.
   * If it does not exist yet, create it and register components.
   */
  private static ensureFlag(world: any, id: number): number {
    const existing = FlagSystem.flagMap.get(id);
    if (existing !== undefined) {
      return existing;
    }

    const eid = addEntity(world);
    addComponent(world, CapturePoint, eid);
    addComponent(world, Transform, eid);
    FlagSystem.flagMap.set(id, eid);
    return eid;
  }

  /**
   * Apply all flags from a Snapshot into the ECS world.
   *
   * - Positions: Transform.(x,y,z)
   * - Radius: CapturePoint.radius
   * - Owner team: CapturePoint.owner (1 = TeamA, 2 = TeamB, 0 = none)
   * - Capture progress: CapturePoint.capture (server-side value)
   */
  public static applySnapshotFlags(snapshot: Snapshot, world: any): void {
    if (!snapshot.flags || snapshot.flags.length === 0) return;

    for (const f of snapshot.flags) {
      const eid = FlagSystem.ensureFlag(world, f.id);

      // Position
      Transform.x[eid] = f.x;
      Transform.y[eid] = f.y;
      Transform.z[eid] = f.z;

      // Radius (fallback to 8 if not provided)
      CapturePoint.radius[eid] = f.radius ?? 8;

      // Owner mapping: server string â†’ numeric ECS id
      CapturePoint.owner[eid] =
        f.owner === 'TeamA' ? 1 :
        f.owner === 'TeamB' ? 2 : 0;

      // Raw capture value from server (-1 â†’ 1 or similar)
      CapturePoint.capture[eid] = f.capture ?? 0;
    }
  }

  /**
   * Optional: clear all known flags (e.g. when changing maps).
   * This only clears the mapping; caller is responsible for
   * actually removing ECS entities if desired.
   */
  public static reset(): void {
    FlagSystem.flagMap.clear();
  }
}


====================================
FILE: \apps\client-tauri\src\systems\interpolationHelpers.ts
====================================

// apps/client-tauri/src/systems/interpolationHelpers.ts

import {
  Transform,
  type SimWorld,
} from '@bf42lite/engine-core';

import type {
  InterpolationBuffer,
  InterpolationSnapshot,
} from '../net/types';

/**
 * Push a new interpolation snapshot into the buffer for a given entity.
 * Keeps history capped to `maxSnapshots`.
 */
export function pushInterpolationSnapshot(
  buffers: Map<number, InterpolationBuffer>,
  localId: number,
  tick: number,
  pos: { x: number; y: number; z: number },
  rot: number,
  timestamp: number,
  maxSnapshots = 20,
): void {
  let buffer = buffers.get(localId);
  if (!buffer) {
    buffer = { snapshots: [] };
    buffers.set(localId, buffer);
  }

  const snap: InterpolationSnapshot = {
    tick,
    pos: { x: pos.x, y: pos.y, z: pos.z },
    rot,
    timestamp,
  };

  buffer.snapshots.push(snap);
  if (buffer.snapshots.length > maxSnapshots) {
    buffer.snapshots.shift();
  }
}

/**
 * Simple time-based interpolation for remote player positions.
 *
 * `renderTimeMs` should be something like `performance.now() - INTERPOLATION_DELAY_MS`
 * to introduce a small delay and ensure you almost always have at least
 * two snapshots to interpolate between.
 */
export function interpolateRemotePlayers(
  world: SimWorld,
  buffers: Map<number, InterpolationBuffer>,
  renderTimeMs: number,
): void {
  for (const [eid, buffer] of buffers.entries()) {
    const snaps = buffer.snapshots;
    if (snaps.length < 2) continue;

    // Find the two snapshots that bracket renderTimeMs
    let prev: InterpolationSnapshot | undefined;
    let next: InterpolationSnapshot | undefined;

    for (let i = snaps.length - 1; i >= 0; i--) {
      const s = snaps[i];
      if (s.timestamp <= renderTimeMs) {
        prev = s;
        next = snaps[i + 1];
        break;
      }
    }

    // Fallback to last two if we didn't find a proper bracket
    if (!prev || !next) {
      prev = snaps[snaps.length - 2];
      next = snaps[snaps.length - 1];
    }

    if (!prev || !next) continue;

    const span = next.timestamp - prev.timestamp;
    const tRaw = span > 0 ? (renderTimeMs - prev.timestamp) / span : 0;
    const t = Math.max(0, Math.min(1, tRaw));

    const lerp = (a: number, b: number) => a + (b - a) * t;

    Transform.x[eid] = lerp(prev.pos.x, next.pos.x);
    Transform.y[eid] = lerp(prev.pos.y, next.pos.y);
    Transform.z[eid] = lerp(prev.pos.z, next.pos.z);
    Transform.rotation[eid] = lerp(prev.rot, next.rot);
  }

  // Currently no need to touch `world` fields; transform changes are enough.
}


====================================
FILE: \apps\client-tauri\src\systems\InterpolationSystem.ts
====================================

// apps/client-tauri/src/systems/InterpolationSystem.ts

import {
  Transform,
  Velocity,
} from '@bf42lite/engine-core';

import type { NetworkManager } from '../managers/NetworkManager';

/**
 * InterpolationSystem pulls historical remote-player snapshots stored
 * in NetworkManager and smooths them into predicted ECS Transform data.
 *
 * This isolates interpolation behavior from NetworkManager.
 */
export class InterpolationSystem {
  private readonly net: NetworkManager;

  constructor(net: NetworkManager) {
    this.net = net;
  }

  /**
   * Apply interpolation to all remote entities based on interpolationTimeMs.
   *
   * @param world                ECS world
   * @param interpolationTimeMs  Target timestamp to sample state from
   */
  public update(world: any, interpolationTimeMs: number): void {
    const remoteStates = this.net.getRemoteHistory(interpolationTimeMs);
    // Expected format: array of { eid, pos:{x,y,z}, rot, vx, vy, vz }

    for (const state of remoteStates) {
      const eid = state.eid;

      // Set position directly (remote players only)
      Transform.x[eid] = state.pos.x;
      Transform.y[eid] = state.pos.y;
      Transform.z[eid] = state.pos.z;

      // Rotation smoothing
      Transform.rotation[eid] = state.rot;

      // Optional velocity smoothing
      if (Velocity.x && Velocity.y && Velocity.z) {
        Velocity.x[eid] = state.vx ?? 0;
        Velocity.y[eid] = state.vy ?? 0;
        Velocity.z[eid] = state.vz ?? 0;
      }
    }
  }
}


====================================
FILE: \apps\client-tauri\src\systems\MovementSystem.ts
====================================

// apps/client-tauri/src/systems/MovementSystem.ts
//
// Thin wrapper around the core movement system from @bf42lite/engine-core.
// This gives the client its own named MovementSystem module, while still
// using exactly the same underlying ECS movement logic as the server.

import {
  createMovementSystem,
  type SimWorld,
  type System,
} from '@bf42lite/engine-core';

// Alias for clarity in the client layer
export type MovementSystem = System;

/**
 * Create the client movement system.
 *
 * Under the hood this is the same createMovementSystem() that the
 * engine uses for the simulation pipeline.
 */
export function createClientMovementSystem(): MovementSystem {
  return createMovementSystem();
}

/**
 * Optional helper if you prefer an object-style API.
 * Not required for your existing code; provided for future use.
 */
export class MovementSystemRunner {
  private readonly system: MovementSystem;

  constructor() {
    this.system = createMovementSystem();
  }

  /**
   * Step movement once for the given world.
   */
  public update(world: SimWorld): void {
    this.system(world);
  }
}


====================================
FILE: \apps\client-tauri\src\systems\PredictionSystem.ts
====================================

// apps/client-tauri/src/systems/PredictionSystem.ts
//
// Encapsulates client-side movement prediction:
//
// - Reads input for the current tick
// - Writes InputState for the local entity
// - Runs the movement system (local prediction)
// - Pushes the predicted state into Reconciler history
// - Returns the ClientInput so caller can send it to the server

import { Transform, type SimWorld } from '@bf42lite/engine-core';
import type { ClientInput } from '@bf42lite/protocol';

import type { InputManager } from '../core/InputManager';
import type { Reconciler } from './Reconciler';
import { updateGameFrame } from './updateGameFrame';

export class PredictionSystem {
  private world: SimWorld;
  private input: InputManager;
  private movementSystem: (world: SimWorld) => void;
  private reconciler: Reconciler;
  private getLocalEntityId: () => number;

  /**
   * @param world           ECS world used by the simulation.
   * @param input           Input manager providing per-tick commands.
   * @param movementSystem  Movement system function (e.g. createMovementSystem()).
   * @param reconciler      Reconciler used to store prediction history.
   * @param getLocalEntityId Function returning the current local player entity id.
   */
  constructor(
    world: SimWorld,
    input: InputManager,
    movementSystem: (world: SimWorld) => void,
    reconciler: Reconciler,
    getLocalEntityId: () => number,
  ) {
    this.world = world;
    this.input = input;
    this.movementSystem = movementSystem;
    this.reconciler = reconciler;
    this.getLocalEntityId = getLocalEntityId;
  }

  /**
   * Run one prediction step.
   *
   * - Applies local input to InputState
   * - Steps the movement system
   * - Records the predicted position into Reconciler history
   *
   * Returns the ClientInput so the caller can send it over the network.
   */
  public update(dt: number, tick: number): ClientInput | null {
    const localEntityId = this.getLocalEntityId();

    // 1) Per-frame input + movement prediction
    const cmd = updateGameFrame(
      dt,
      tick,
      localEntityId,
      this.world,
      this.input,
      this.movementSystem,
    ) as ClientInput | null;

    // 2) Store prediction history for reconciliation
    if (localEntityId >= 0 && cmd) {
      this.reconciler.pushHistory(
        tick,
        cmd,
        Transform.x[localEntityId],
        Transform.y[localEntityId],
        Transform.z[localEntityId],
      );
    }

    return cmd;
  }
}


====================================
FILE: \apps\client-tauri\src\systems\Reconciler.ts
====================================

// apps/client-tauri/src/systems/Reconciler.ts

import { Transform, Velocity, SimWorld } from '@bf42lite/engine-core';
import { ClientInput, EntityState } from '@bf42lite/protocol';
import type { InterpolationBuffer } from '../net/types';
import { log } from '../utils/log';

export interface InputHistory {
  tick: number;
  input: ClientInput;
  pos: { x: number; y: number; z: number };
  timestamp: number;
}

/**
 * Client-side reconciler for predicted movement.
 * Stores a small history of client inputs and positions and compares them
 * to authoritative server snapshots to correct drift.
 */
export class Reconciler {
  private history: InputHistory[] = [];

  // Interpolation buffers for remote entities (used by interpolation.ts)
  public remoteBuffers: Map<number, InterpolationBuffer> = new Map();

  // Normal correction threshold (â‰ˆ1m).
  private readonly ERROR_THRESHOLD_SQ = 1.0;

  // Teleport/spawn threshold (â‰ˆ10m).
  private readonly TELEPORT_THRESHOLD_SQ = 100.0;

  /**
   * Record the current predicted state.
   *
   * Call this once per local simulation step, after applying inputs.
   */
  public pushHistory(
    tick: number,
    input: ClientInput,
    x: number,
    y: number,
    z: number,
  ) {
    this.history.push({
      tick,
      input,
      pos: { x, y, z },
      timestamp: performance.now(),
    });
  }

  public clearHistory() {
    this.history.length = 0;
  }

  /**
   * Compare a server snapshot to the local history and correct if needed.
   *
   * Returns an RTT estimate in milliseconds based on the stored timestamp,
   * or 0 if no matching history was found.
   */
  public reconcile(
    serverTick: number,
    serverState: EntityState,
    eid: number,
    world: SimWorld,
    movementSystem: (w: SimWorld) => void,
  ): number {
    if (!serverState.pos || this.history.length === 0) {
      return 0;
    }

    // 1. Prefer exact history match for this tick.
    let historyIndex = this.history.findIndex(
      (h) => h.tick === serverTick,
    );

    // 2. If no exact match, fall back to closest tick we have.
    if (historyIndex === -1) {
      log.warn('RECON', 'No history for server tick', {
        serverTick,
        historySize: this.history.length,
      });

      let closestIndex = -1;
      let closestDiff = Number.POSITIVE_INFINITY;

      for (let i = 0; i < this.history.length; i++) {
        const diff = Math.abs(this.history[i].tick - serverTick);
        if (diff < closestDiff) {
          closestDiff = diff;
          closestIndex = i;
        }
      }

      if (closestIndex === -1) {
        return 0;
      }

      historyIndex = closestIndex;

      const picked = this.history[historyIndex];
      log.debug('RECON', 'Using closest history tick', {
        serverTick,
        pickedTick: picked.tick,
        delta: closestDiff,
      });
    }

    const historyState = this.history[historyIndex];

    // RTT is time since we originally simulated that tick.
    const rtt = Math.round(
      performance.now() - historyState.timestamp,
    );

    // 3. Compute spatial error between predicted and authoritative positions.
    const dx = historyState.pos.x - serverState.pos.x;
    const dy = historyState.pos.y - serverState.pos.y;
    const dz = historyState.pos.z - serverState.pos.z;
    const distSq = dx * dx + dy * dy + dz * dz;

    // 4. Teleport: error is massive, probably a respawn or big correction.
    if (distSq > this.TELEPORT_THRESHOLD_SQ) {
      log.warn('RECON', 'Teleport correction', {
        serverTick,
        eid,
        distSq: Number(distSq.toFixed(2)),
      });

      Transform.x[eid] = serverState.pos.x;
      Transform.y[eid] = serverState.pos.y;
      Transform.z[eid] = serverState.pos.z;

      if (serverState.vel) {
        Velocity.x[eid] = serverState.vel.x;
        Velocity.y[eid] = serverState.vel.y;
        Velocity.z[eid] = serverState.vel.z;
      }

      this.clearHistory();
      return rtt;
    }

    // 5. Normal correction: small but noticeable mismatch.
    if (distSq > this.ERROR_THRESHOLD_SQ) {
      log.warn('RECON', 'Soft correction', {
        serverTick,
        eid,
        distSq: Number(distSq.toFixed(2)),
        clientPos: {
          x: Number(historyState.pos.x.toFixed(2)),
          y: Number(historyState.pos.y.toFixed(2)),
          z: Number(historyState.pos.z.toFixed(2)),
        },
        serverPos: {
          x: Number(serverState.pos.x.toFixed(2)),
          y: Number(serverState.pos.y.toFixed(2)),
          z: Number(serverState.pos.z.toFixed(2)),
        },
      });

      // For now we fully trust the server.
      Transform.x[eid] = serverState.pos.x;
      Transform.y[eid] = serverState.pos.y;
      Transform.z[eid] = serverState.pos.z;

      if (serverState.vel) {
        Velocity.x[eid] = serverState.vel.x;
        Velocity.y[eid] = serverState.vel.y;
        Velocity.z[eid] = serverState.vel.z;
      }

      // Drop history up to and including the corrected tick.
      this.history.splice(0, historyIndex + 1);
      return rtt;
    }

    // 6. No correction needed: server and client agree closely enough.
    this.history.splice(0, historyIndex + 1);

    log.trace('RECON', 'No correction needed', {
      serverTick,
      eid,
      distSq: Number(distSq.toFixed(3)),
    });

    return rtt;
  }
}


====================================
FILE: \apps\client-tauri\src\systems\RemoteEntitiesSystem.ts
====================================

// apps/client-tauri/src/systems/RemoteEntitiesSystem.ts
//
// System for synchronizing *remote* entities from server Snapshots into ECS.
//
// Responsibilities:
// - Ensure a local ECS entity exists for each remote server entity id.
// - Update Transform / components from snapshot data.
// - Push interpolation samples for remote smoothing.
// - Does NOT touch HUD; local-player HUD is handled elsewhere.

import {
  Transform,
  Velocity,
  addComponent,
  addEntity,
  type SimWorld,
} from '@bf42lite/engine-core';

import {
  Health,
  Ammo,
  Soldier,
  Team,
  Loadout,
} from '@bf42lite/games-bf42';

import type { Snapshot } from '@bf42lite/protocol';
import type { NetworkManager } from '../managers/NetworkManager';
import type { Renderer } from '../core/Renderer';
import type { Reconciler } from './Reconciler';

// We will migrate this later; for now we still reuse the old helper.
import { pushInterpolationSnapshot } from './interpolationHelpers';

export class RemoteEntitiesSystem {
  private static ensureEntity(
    world: SimWorld,
    net: NetworkManager,
    renderer: Renderer,
    serverId: number,
  ): number {
    const existing = net.getLocalId(serverId);
    if (existing !== undefined) return existing;

    const eid = addEntity(world);

    addComponent(world, Transform, eid);
    addComponent(world, Velocity, eid);
    addComponent(world, Soldier, eid);
    addComponent(world, Health, eid);
    addComponent(world, Ammo, eid);
    addComponent(world, Team, eid);
    addComponent(world, Loadout, eid);

    net.registerEntity(serverId, eid);
    if (renderer.onEntityCreated) {
      renderer.onEntityCreated(eid);
    }

    return eid;
  }

  public static apply(
    snapshot: Snapshot,
    world: SimWorld,
    renderer: Renderer,
    net: NetworkManager,
    reconciler: Reconciler,
    nowTs: number,
  ): void {
    if (!snapshot.entities) return;

    for (const ent of snapshot.entities) {
      const serverId = ent.id;
      if (serverId == null) continue;

      const eid = this.ensureEntity(world, net, renderer, serverId);

      // Transform / rotation
      if (ent.pos) {
        const { x, y, z } = ent.pos;
        Transform.x[eid] = x;
        Transform.y[eid] = y;
        Transform.z[eid] = z;

        if (typeof ent.rot === 'number') {
          Transform.rotation[eid] = ent.rot;
        }

        // Interpolation history
        pushInterpolationSnapshot(
          reconciler.remoteBuffers,
          eid,
          snapshot.tick,
          { x, y, z },
          ent.rot ?? 0,
          nowTs,
        );
      }

      // Health / death
      if (ent.health != null) {
        Health.current[eid] = ent.health;
        Health.isDead[eid] = ent.isDead ? 1 : 0;
      }

      // Team
      if (ent.team) {
        Team.id[eid] = ent.team.id === 'TeamA' ? 1 : 2;
      }

      // Loadout / class
      if (ent.loadout) {
        Loadout.classId[eid] = ent.loadout.classId ?? 0;
      }

      // Ammo
      if (ent.ammo) {
        Ammo.current[eid] = ent.ammo.current ?? 0;
        Ammo.reserve[eid] = ent.ammo.reserve ?? 0;
      }

      if (renderer.onEntityUpdated) {
        renderer.onEntityUpdated(eid);
      }
    }
  }
}


====================================
FILE: \apps\client-tauri\src\systems\SnapshotHandler.ts
====================================

// apps/client-tauri/src/systems/SnapshotHandler.ts
//
// Thin wrapper around Snapshot â†’ HUD effects.
// Keeps ClientGame free from protocol / HUD wiring.

import type { Snapshot, FlagSnapshot } from '@bf42lite/protocol';
import type { HUDUpdater } from '../ui/HUDUpdater';

export interface SnapshotResult {
  flags: FlagSnapshot[];
  lastServerTick: number;
}

export class SnapshotHandler {
  private hud: HUDUpdater;

  constructor(hud: HUDUpdater) {
    this.hud = hud;
  }

  /**
   * Process the snapshot sent by the server and return
   * a small result object for ClientGame.
   */
  public process(msg: Snapshot): SnapshotResult {
    // HUD (tickets, flags list, game-over) is handled via HUDUpdater.
    this.hud.applySnapshotHUD(msg);

    const flags = (msg.flags ?? []) as FlagSnapshot[];
    const lastServerTick = msg.tick ?? 0;

    return {
      flags,
      lastServerTick,
    };
  }
}


====================================
FILE: \apps\client-tauri\src\systems\syncLocalPlayer.ts
====================================

// apps/client-tauri/src/systems/syncLocalPlayer.ts

import { Transform, type SimWorld } from '@bf42lite/engine-core';
import {
  Health,
  Team,
  Loadout,
} from '@bf42lite/games-bf42';

import type { Snapshot } from '@bf42lite/protocol';
import type { NetworkManager } from '../managers/NetworkManager';
import type { HUDUpdater } from '../ui/HUDUpdater';
import type { Reconciler } from './Reconciler';

import { TEAM_IDS } from '../core/constants';
import type { ClassConfig } from '../core/ClassConfigLoader';
import { loadClassConfig } from '../core/ClassConfigLoader';
import type { WeaponConfig } from '../core/WeaponConfigLoader';
import { loadWeaponConfig } from '../core/WeaponConfigLoader';

type WeaponHudInfo = {
  weaponName: string;
  magSize?: number;
  reserveAmmo?: number;
};

let hudClassesById = new Map<number, ClassConfig>();
let hudWeaponsById = new Map<number, WeaponConfig>();
let hudConfigLoaded = false;
let hudConfigLoadingPromise: Promise<void> | null = null;

async function ensureHudConfigsLoaded(): Promise<void> {
  if (hudConfigLoaded || hudConfigLoadingPromise) {
    return hudConfigLoadingPromise ?? Promise.resolve();
  }

  hudConfigLoadingPromise = (async () => {
    try {
      const [weapons, classes] = await Promise.all([
        loadWeaponConfig(),
        loadClassConfig(),
      ]);

      hudWeaponsById.clear();
      for (const w of weapons) {
        hudWeaponsById.set(w.id, w);
      }

      hudClassesById.clear();
      for (const c of classes) {
        hudClassesById.set(c.id, c);
      }

      hudConfigLoaded = true;
      console.log('[HUDConfig] Loaded weapons/classes for HUD');
    } catch (err) {
      console.error('[HUDConfig] Failed to load HUD configs', err);
      hudConfigLoaded = false;
    }
  })();

  return hudConfigLoadingPromise;
}

function getWeaponHudInfoForClass(classId: number): WeaponHudInfo {
  if (!hudConfigLoaded) {
    // Fire-and-forget load on first call; we keep a safe fallback name until it finishes.
    void ensureHudConfigsLoaded();
    return { weaponName: 'THOMPSON' };
  }

  const classCfg = hudClassesById.get(classId);
  if (!classCfg) {
    return { weaponName: 'THOMPSON' };
  }

  const weaponCfg = hudWeaponsById.get(classCfg.primary_weapon_id);
  if (!weaponCfg) {
    return { weaponName: 'THOMPSON' };
  }

  return {
    weaponName: weaponCfg.name,
    magSize: weaponCfg.mag_size,
    reserveAmmo: weaponCfg.reserve_ammo,
  };
}


/**
 * Synchronize the local player ECS state + UI from a server Snapshot.
 *
 * Returns the updated last RTT (or the previous one if unchanged).
 */
export function syncLocalPlayerFromSnapshot(
  msg: Snapshot,
  world: SimWorld,
  localEntityId: number,
  net: NetworkManager,
  hud: HUDUpdater,
  reconciler: Reconciler,
  movementSystem: (world: SimWorld) => void,
  lastRtt: number,
): number {
  if (localEntityId < 0) {
    return lastRtt;
  }

  const myServerEntity = msg.entities?.find(
    (e: any) => net.getLocalId(e.id) === localEntityId,
  );

  if (!myServerEntity) {
    return lastRtt;
  }

  const wasDead = Health.isDead[localEntityId] === 1;
  const isNowDead = !!myServerEntity.isDead;

  // Teleport on respawn to avoid smoothing artifacts
  if (wasDead && !isNowDead && myServerEntity.pos) {
    reconciler.clearHistory();
    Transform.x[localEntityId] = myServerEntity.pos.x;
    Transform.y[localEntityId] = myServerEntity.pos.y;
    Transform.z[localEntityId] = myServerEntity.pos.z;
  }
  // Health + death state (protocol sends health as a number)
  const hp =
    typeof myServerEntity.health === 'number'
      ? myServerEntity.health
      : 100;

  Health.current[localEntityId] = hp;
  Health.isDead[localEntityId] = isNowDead ? 1 : 0;

  // --- Respawn timer handling ---
  // Ensure we never pass negative timers into the HUD.
  const rawRespawn = myServerEntity.respawnTimer ?? 0;
  const respawnTimer = rawRespawn > 0 ? rawRespawn : 0;

  // HUD: respawn timer (drives center status while dead)
  hud.updateRespawn(isNowDead, respawnTimer);

  // HUD: deploy vs live HUD toggle on state change
  if (!wasDead && isNowDead) {
    // Just died â†’ switch to deploy layout and briefly show a death message.
    hud.showDeployScreen();
    hud.updateCenterStatus('You died.');
  } else if (wasDead && !isNowDead) {
    // Just respawned â†’ back to game HUD and clear center text
    hud.showLiveHUD();
  }


  // Team mapping (Rust TeamId â†’ numeric ECS team)
  if (myServerEntity.team) {
    const protoId = myServerEntity.team.id;
    if (protoId === 'TeamA') {
      Team.id[localEntityId] = TEAM_IDS.AXIS;
    } else if (protoId === 'TeamB') {
      Team.id[localEntityId] = TEAM_IDS.ALLIES;
    } else {
      Team.id[localEntityId] = TEAM_IDS.NONE;
    }
  }

  // Loadout / class
  if (myServerEntity.loadout) {
    Loadout.classId[localEntityId] =
      myServerEntity.loadout.classId ?? 0;
  }

  // Ammo + weapon UI (JSON-driven: class -> primary_weapon_id -> weapon.name)
  const myClassId = Loadout.classId[localEntityId] ?? 0;
  const { weaponName } = getWeaponHudInfoForClass(myClassId);

  if (myServerEntity.ammo) {
    hud.updateAmmo(
      myServerEntity.ammo.current,
      myServerEntity.ammo.reserve,
      weaponName,
    );
  }

  // RTT (if provided by snapshot/game_state)
  const gs: any = msg.game_state;
  if (typeof gs?.rtt_ms === 'number') {
    lastRtt = gs.rtt_ms;
  }

  return lastRtt;
}


====================================
FILE: \apps\client-tauri\src\systems\updateGameFrame.ts
====================================

// src/systems/updateGameFrame.ts

import { InputState, type SimWorld } from '@bf42lite/engine-core';
import type { InputManager } from '../core/InputManager';

/**
 * One per-frame client update:
 * - Read input
 * - Write into InputState for the local entity
 * - Run the movement system
 * - Return the input command so the caller can push history / send to server
 */
export function updateGameFrame(
  dt: number,
  currentTick: number,
  localEntityId: number,
  simWorld: SimWorld,
  input: InputManager,
  movementSystem: (world: SimWorld) => void,
) {
  // 1. Read input for this tick
  const cmd = input.getCommand(currentTick);

  // 2. Write into ECS input components for the local entity
  if (localEntityId >= 0) {
    InputState.moveY[localEntityId] = cmd.axes.forward;
    InputState.moveX[localEntityId] = cmd.axes.right;
    InputState.viewX[localEntityId] = cmd.axes.yaw;
    InputState.viewY[localEntityId] = cmd.axes.pitch;

    // Button bitmask:
    // bit 0: jump
    // bit 1: shoot  (used by WeaponSystem via InputState.buttons & 2)
    // bit 2: reload
    let buttons = 0;
    if (cmd.axes.jump)   buttons |= 1;
    if (cmd.axes.shoot)  buttons |= 2;
    if (cmd.axes.reload) buttons |= 4;

    InputState.buttons[localEntityId] = buttons;
  }

  // 3. Run movement (local prediction)
  movementSystem(simWorld);

  // 4. Hand the command back to ClientGame
  return cmd;
}


====================================
FILE: \apps\client-tauri\src\ui\HUDUpdater.ts
====================================

// apps/client-tauri/src/ui/HUDUpdater.ts
//
// Centralized helper for updating HUD elements.
// The goal is to gradually move direct UIManager calls here so that
// snapshot handlers, systems, and ClientGame do not talk to the DOM/UI
// directly, only to this faÃ§ade.

import type { UIManager } from '../managers/UIManager';
import type { Snapshot } from '@bf42lite/protocol';

export class HUDUpdater {
  private ui: UIManager;

  constructor(ui: UIManager) {
    this.ui = ui;
  }

  /**
   * Toggle deploy screen vs in-game HUD.
   */
  public showDeployScreen(message?: string): void {
    this.ui.setDeployMode(true);
    if (message) {
      this.updateCenterStatus(message);
    }
  }

  public showLiveHUD(): void {
    this.ui.setDeployMode(false);
    // Clear center message when fully alive
    this.updateCenterStatus('');
  }

  /**
   * Update the center status text (e.g., spawn/death messages).
   */
  public updateCenterStatus(text: string): void {
    this.ui.setCenterStatus(text);
  }

  /**
   * Switch between deploy screen and in-game HUD.
   */
  public setDeployMode(isDeploy: boolean): void {
    this.ui.setDeployMode(isDeploy);
  }

  /**
   * Update FPS + RTT stats in the HUD.
   */
  public updateStats(fps: number, rttMs: number): void {
    this.ui.updateStats(fps, rttMs);
  }

  /**
   * Update local player's health in the HUD.
   */
  public updateHealth(health: number): void {
    this.ui.updateHealth(health);
  }

  /**
   * Update respawn timer and death state in the HUD.
   */
  public updateRespawn(isDead: boolean, respawnTimerSec: number): void {
    this.ui.updateRespawn(isDead, respawnTimerSec);
  }

  /**
   * Update ammo + weapon name in the HUD.
   */
  public updateAmmo(current: number, reserve: number, weaponName: string): void {
    this.ui.updateAmmo(current, reserve, weaponName);
  }

  /**
   * Update hit marker feedback (damage done).
   */
  public showHitMarker(damage: number): void {
    this.ui.showHitMarker(damage);
  }
    // crosshair spread
    public updateCrosshair(spread: number): void {
      this.ui.setCrosshairSpread(spread);
    }

  /**
   * Snapshot-driven HUD hook (tickets / flags / game-over).
   *
   * Called once per server snapshot from SnapshotHandler.
   * This keeps snapshot â†’ HUD wiring in a single place.
   */
  public applySnapshotHUD(msg: Snapshot): void {
    // --- Tickets ---
    const axis = msg.game_state?.team_a_tickets ?? 0;
    const allies = msg.game_state?.team_b_tickets ?? 0;
    this.ui.updateTickets(axis, allies);

    // --- Flags HUD (mini strip + list) ---
    this.ui.updateFlagsHUD(msg.flags);

    // --- Game over state ---
    const st: any = msg.game_state;
    const ended = !!st?.match_ended;

    if (ended) {
      let title = 'DRAW';
      const winner = st?.winner_team as number | string | null | undefined;

      if (winner === 1 || winner === 'TeamA') title = 'AXIS VICTORY';
      else if (winner === 2 || winner === 'TeamB') title = 'ALLIES VICTORY';

      this.ui.setGameOver(true, title);
    } else {
      this.ui.setGameOver(false, '');
    }
  }
}


====================================
FILE: \apps\client-tauri\src\utils\log.ts
====================================

// src/utils/log.ts

type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'trace';

interface LogConfig {
    level: LogLevel;
    enabledTags: Set<string>;
}

const LEVEL_ORDER: Record<LogLevel, number> = {
    error: 0,
    warn: 1,
    info: 2,
    debug: 3,
    trace: 4,
};

// Default config â€” switch here for "debug build"
const config: LogConfig = {
    level: 'info', // show: error, warn, info
    enabledTags: new Set(['NET', 'CONQUEST', 'SIM', 'RENDER', 'RECON']),
};

function shouldLog(level: LogLevel, tag: string): boolean {
    if (LEVEL_ORDER[level] > LEVEL_ORDER[config.level]) return false;
    if (!config.enabledTags.has(tag)) return false;
    return true;
}

export const log = {
    setLevel(level: LogLevel): void {
        config.level = level;
    },

    enable(tag: string): void {
        config.enabledTags.add(tag);
    },

    disable(tag: string): void {
        config.enabledTags.delete(tag);
    },

    error(tag: string, msg: string, data?: any): void {
        if (shouldLog('error', tag)) console.error(`[ERROR][${tag}] ${msg}`, data ?? '');
    },

    warn(tag: string, msg: string, data?: any): void {
        if (shouldLog('warn', tag)) console.warn(`[WARN][${tag}] ${msg}`, data ?? '');
    },

    info(tag: string, msg: string, data?: any): void {
        if (shouldLog('info', tag)) console.info(`[INFO][${tag}] ${msg}`, data ?? '');
    },

    debug(tag: string, msg: string, data?: any): void {
        if (shouldLog('debug', tag)) console.debug(`[DEBUG][${tag}] ${msg}`, data ?? '');
    },

    trace(tag: string, msg: string, data?: any): void {
        if (shouldLog('trace', tag)) console.log(`[TRACE][${tag}] ${msg}`, data ?? '');
    },
};


====================================
FILE: \apps\client-tauri\src\world\worldRender.ts
====================================

// apps/client-tauri/src/world/worldRender.ts

import { defineQuery } from '@bf42lite/engine-core';
import { Soldier, CapturePoint, Health } from '@bf42lite/games-bf42';

import { EntityMapper } from '../core/EntityMapper';
import type { Renderer } from '../core/Renderer';
import type { HUDUpdater } from '../ui/HUDUpdater';

// ECS queries for players and flags
const playerQuery = defineQuery([Soldier]);
const flagQuery = defineQuery([CapturePoint]);

/**
 * Build and send all render + HUD state for this frame.
 *
 * - Renders all players (local + remote).
 * - Renders all flags (Conquest points).
 * - Updates basic HUD stats (FPS / RTT / Health).
 */
export function updateWorldRender(
  world: any,
  renderer: Renderer,
  hud: HUDUpdater,
  localEntityId: number,
  fps: number,
  rttMs: number,
): void {
  // Basic HUD stats
  hud.updateStats(fps, rttMs);

  if (localEntityId >= 0) {
    const hp = Health.current[localEntityId] ?? 0;
    hud.updateHealth(hp);
  }

  // === PLAYERS ===
  const players = playerQuery(world);
  for (const eid of players) {
    const state = EntityMapper.mapPlayer(eid, world, eid === localEntityId);
    renderer.updateEntity(eid, state, eid === localEntityId);
  }

  // === FLAGS (CONQUEST POINTS) ===
  const flags = flagQuery(world);
  for (const eid of flags) {
    const state = EntityMapper.mapFlag(eid, world);

    // Optional debug:
    // console.log('[FLAG-RENDER]', eid, state.team, state.progress);

    renderer.updateEntity(eid, state, false);
  }

  // Final frame
  renderer.render();
}


