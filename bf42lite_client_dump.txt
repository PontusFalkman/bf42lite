===============================
 DUMP FOR: apps/client-tauri/src
===============================

---------- DIRECTORY TREE ----------

Folder PATH listing for volume New Volume
Volume serial number is BC16-B8E7
D:\BF42LITE\APPS\CLIENT-TAURI\SRC
ª   main.ts
ª   
+---core
ª       ClientGame.ts
ª       constants.ts
ª       EntityMapper.ts
ª       FlagRenderer.ts
ª       GameLoop.ts
ª       InputManager.ts
ª       local-player.ts
ª       render-update.ts
ª       Renderer.ts
ª       snapshot-handler.ts
ª       WeaponSystem.ts
ª       
+---managers
ª       NetworkManager.ts
ª       UIManager.ts
ª       
+---net
ª       CommandSender.ts
ª       
+---network
ª       FlagSync.ts
ª       index.ts
ª       interpolation.ts
ª       RemoteEntitySync.ts
ª       SnapshotDecoder.ts
ª       types.ts
ª       
+---render
ª       FlagVisual.ts
ª       ModelFactory.ts
ª       
+---systems
ª       FlagSystem.ts
ª       handleSnapshot.ts
ª       InterpolationSystem.ts
ª       MovementSystem.ts
ª       PredictionSystem.ts
ª       Reconciler.ts
ª       SnapshotHandler.ts
ª       syncLocalPlayer.ts
ª       updateGameFrame.ts
ª       
+---ui
ª       HUDUpdater.ts
ª       
+---utils
ª       log.ts
ª       
+---world
        worldRender.ts
        

---------- FILE CONTENTS ----------

## FILE: apps\client-tauri\src\main.ts
---------------------------
import { ClientGame } from './core/ClientGame';

// Prevent context menu
document.addEventListener('contextmenu', event => event.preventDefault());

console.log("Starting bf42lite Client...");
const game = new ClientGame();
game.start();


## FILE: apps\client-tauri\src\core\ClientGame.ts
---------------------------
// apps/client-tauri/src/core/ClientGame.ts

import {
  createSimulation,
  Transform,
  Velocity,
  InputState,
  Me,
  addComponent,
  addEntity,
  createMovementSystem,
} from '@bf42lite/engine-core';
import {
  Health,
  Ammo,
  Soldier,
  Team,
  Loadout,
} from '@bf42lite/games-bf42';

import type { Snapshot } from '@bf42lite/protocol';
import { TEAM_IDS, WEAPON_NAMES } from './constants';

import { Renderer } from './Renderer';
import { InputManager } from './InputManager';
import { WeaponSystem } from './WeaponSystem';

import { NetworkManager } from '../managers/NetworkManager';
import { UIManager } from '../managers/UIManager';
import { Reconciler } from '../systems/Reconciler';
import { handleSnapshot } from '../systems/handleSnapshot';
import { updateGameFrame } from '../systems/updateGameFrame';
import { updateWorldRender } from '../world/worldRender';
import { CommandSender } from '../net/CommandSender';

export class ClientGame {
  private movementSystem = createMovementSystem();
  public sim = createSimulation(); // keep public so other modules can peek if needed

  public renderer: Renderer;
  public net: NetworkManager;

  private input: InputManager;
  private ui: UIManager;
  public reconciler: Reconciler;
  private weaponSystem: WeaponSystem;
  private commandSender: CommandSender;

  private localEntityId: number = -1;
  private running = false;
  private lastFrameTime = 0;
  private currentTick = 0;
  private currentFps = 0;
  private lastRtt = 0;

  private readonly SEND_INTERVAL = 1 / 30; // 30 Hz input send
  private readonly INTERPOLATION_DELAY_MS = 100;

  constructor() {
    this.renderer = new Renderer();
    this.reconciler = new Reconciler();
    this.net = new NetworkManager(this.sim.world, this.renderer, this.reconciler);
    this.commandSender = new CommandSender(this.net, this.SEND_INTERVAL);
    this.input = new InputManager();

    // UI + class selection wiring
    this.input.setInteraction(false);
    this.weaponSystem = new WeaponSystem(this.renderer, this.net);
    this.ui = new UIManager((classId: number) => {
      console.log(`Spawn requested with Class ID: ${classId}`);
      this.net.sendSpawnRequest(classId);
      this.weaponSystem.setClass(classId);
    });
    this.input.setInteraction(true);

    this.initNetworkCallbacks();
    this.net.connect('ws://localhost:8080');

    this.createLocalPlayer();
  }

  private createLocalPlayer() {
    this.localEntityId = addEntity(this.sim.world);

    // Core ECS components
    addComponent(this.sim.world, Transform, this.localEntityId);
    addComponent(this.sim.world, Velocity, this.localEntityId);
    addComponent(this.sim.world, InputState, this.localEntityId);
    addComponent(this.sim.world, Me, this.localEntityId);

    // Gameplay components
    addComponent(this.sim.world, Health, this.localEntityId);
    addComponent(this.sim.world, Ammo, this.localEntityId);
    addComponent(this.sim.world, Soldier, this.localEntityId);
    addComponent(this.sim.world, Team, this.localEntityId);
    addComponent(this.sim.world, Loadout, this.localEntityId);
  }

  private initNetworkCallbacks() {
    this.net.onConnected = () => {
      console.log('Connected to server');
    };

    this.net.onDisconnected = () => {
      console.log('Disconnected from server');
    };

    this.net.onHitConfirmed = (damage: number) => {
      this.ui.showHitMarker(damage);
    };

    this.net.onSnapshot = (msg: Snapshot) => {
      // Centralized snapshot handling: entities, tickets, game over, HUD flags, killfeed, etc.
      handleSnapshot(msg, this.sim.world, this.renderer, this.net, this.ui);

      // --- Local player sync ---
      const myServerEntity = msg.entities?.find(
        (e: any) => this.net.getLocalId(e.id) === this.localEntityId,
      );

      if (myServerEntity) {
        const wasDead = Health.isDead[this.localEntityId] === 1;
        const isNowDead = !!myServerEntity.isDead;

        // Teleport on respawn to avoid smoothing artifacts
        if (wasDead && !isNowDead && myServerEntity.pos) {
          this.reconciler.clearHistory();
          Transform.x[this.localEntityId] = myServerEntity.pos.x;
          Transform.y[this.localEntityId] = myServerEntity.pos.y;
          Transform.z[this.localEntityId] = myServerEntity.pos.z;
        }

        // Health + death state (protocol now sends health as a number)
        const hp =
          typeof myServerEntity.health === 'number'
            ? myServerEntity.health
            : 100;

        Health.current[this.localEntityId] = hp;
        Health.isDead[this.localEntityId] = isNowDead ? 1 : 0;
        this.ui.updateRespawn(isNowDead, myServerEntity.respawnTimer || 0);

        // Team mapping (Rust TeamId â†’ numeric ECS team)
        if (myServerEntity.team) {
          const protoId = myServerEntity.team.id;
          if (protoId === 'TeamA') {
            Team.id[this.localEntityId] = TEAM_IDS.AXIS;
          } else if (protoId === 'TeamB') {
            Team.id[this.localEntityId] = TEAM_IDS.ALLIES;
          } else {
            Team.id[this.localEntityId] = TEAM_IDS.NONE;
          }
        }

        // Loadout / class
        if (myServerEntity.loadout) {
          Loadout.classId[this.localEntityId] =
            myServerEntity.loadout.classId ?? 0;
        }

        // Ammo + weapon UI
        const myClassId = Loadout.classId[this.localEntityId] || 0;
        const weaponName = WEAPON_NAMES[myClassId] ?? 'THOMPSON';

        if (myServerEntity.ammo) {
          this.ui.updateAmmo(
            myServerEntity.ammo.current,
            myServerEntity.ammo.reserve,
            weaponName,
          );
        }

        // Reconciliation (movement correction)
        if (myServerEntity.lastProcessedTick !== undefined) {
          const rtt = this.reconciler.reconcile(
            myServerEntity.lastProcessedTick,
            myServerEntity,
            this.localEntityId,
            this.sim.world,
            this.movementSystem,
          );
          if (rtt > 0) this.lastRtt = rtt;
        }
      }
    };
  }

  public start() {
    if (this.running) return;
    this.running = true;
    this.lastFrameTime = performance.now();
    requestAnimationFrame(this.loop);
  }

  public stop() {
    this.running = false;
  }

  private loop = (now: number) => {
    if (!this.running) return;
    requestAnimationFrame(this.loop);

    const dt = (now - this.lastFrameTime) / 1000;
    this.lastFrameTime = now;
    if (dt > 0) this.currentFps = Math.round(1 / dt);

    // Per-frame input + sim + movement
    const cmd = updateGameFrame(
      dt,
      this.currentTick,
      this.localEntityId,
      this.sim.world,
      this.input,
      this.movementSystem,
    );

    // Prediction history
    if (this.localEntityId >= 0 && cmd) {
      this.reconciler.pushHistory(
        this.currentTick,
        cmd,
        Transform.x[this.localEntityId],
        Transform.y[this.localEntityId],
        Transform.z[this.localEntityId],
      );
    }

    // Throttled input send (via CommandSender)
    this.commandSender.update(dt, cmd || null);

    // Weapons + interpolation
    this.weaponSystem.update(dt, this.localEntityId, this.currentTick);
    this.currentTick++;

    // Interpolate remote players using buffered snapshots
    this.net.interpolateRemotePlayers(now - this.INTERPOLATION_DELAY_MS);

    // Render + HUD
    this.updateRenderAndUI();
  };

  private updateRenderAndUI() {
    updateWorldRender(
      this.sim.world,
      this.renderer,
      this.ui,
      this.localEntityId,
      this.currentFps,
      this.lastRtt,
    );
  }
}


## FILE: apps\client-tauri\src\core\constants.ts
---------------------------
// apps/client-tauri/src/core/constants.ts

// --- TEAMS ---

export const TEAM_IDS = {
  NONE: 0,
  AXIS: 1,
  ALLIES: 2,
} as const;

export type TeamIdNumeric = (typeof TEAM_IDS)[keyof typeof TEAM_IDS];

export const TEAM_COLORS = {
  NEUTRAL: 0xcccccc,
  AXIS: 0xff0000,
  ALLIES: 0x0000ff,
} as const;

// --- CLASSES / LOADOUTS ---

export const CLASS_IDS = {
  ASSAULT: 0,
  MEDIC: 1,
  SCOUT: 2,
} as const;

// --- WEAPONS (NAMES + BASIC STATS) ---

export const WEAPON_NAMES: Record<number, string> = {
  [CLASS_IDS.ASSAULT]: 'THOMPSON',
  [CLASS_IDS.MEDIC]: 'MP40',
  [CLASS_IDS.SCOUT]: 'KAR98K',
};

export const WEAPON_STATS = {
  [CLASS_IDS.ASSAULT]: { rate: 0.12 }, // Assault
  [CLASS_IDS.MEDIC]: { rate: 0.15 },   // Medic
  [CLASS_IDS.SCOUT]: { rate: 1.5 },    // Scout (slow bolt-action)
} as const;


## FILE: apps\client-tauri\src\core\EntityMapper.ts
---------------------------
// apps/client-tauri/src/core/EntityMapper.ts
//
// Convert ECS components into clean, renderer-ready RenderState objects.
// This keeps rendering code 100% independent from ECS internals.

import {
  Transform,
  InputState,
} from '@bf42lite/engine-core';

import {
  Soldier,
  Team,
  CapturePoint,
} from '@bf42lite/games-bf42';

export type RenderStatePlayer = {
  type: 'player';
  id: number;
  pos: { x: number; y: number; z: number };
  rot: number;
  pitch: number;
  team: number;
};

export type RenderStateFlag = {
  type: 'flag';
  id: number;
  pos: { x: number; y: number; z: number };
  rot: number;
  team: number;
  progress: number;
};

export type RenderState = RenderStatePlayer | RenderStateFlag;

export class EntityMapper {
  /**
   * Convert a player ECS entity into a RenderStatePlayer.
   */
  public static mapPlayer(eid: number, world: any, isMe: boolean): RenderStatePlayer {
    return {
      type: 'player',
      id: eid,
      pos: {
        x: Transform.x[eid],
        y: Transform.y[eid],
        z: Transform.z[eid],
      },
      rot: Transform.rotation[eid],
      pitch: isMe ? InputState.viewY[eid] : 0,
      team: Team.id[eid],
    };
  }

  /**
   * Convert a flag ECS entity into a RenderStateFlag.
   */
  public static mapFlag(eid: number, world: any): RenderStateFlag {
    const raw = CapturePoint.progress[eid] || 0;
    const progress = Math.min(1, Math.abs(raw / 100)); // progress is i16 in old schema
  
    return {
      type: 'flag',
      id: eid,
      pos: {
        x: Transform.x[eid],
        y: Transform.y[eid],
        z: Transform.z[eid],
      },
      rot: 0,
      team: CapturePoint.team[eid],  // existing schema
      progress,
    };
  }  
}


## FILE: apps\client-tauri\src\core\FlagRenderer.ts
---------------------------
// apps/client-tauri/src/core/FlagRenderer.ts

import * as THREE from 'three';
import { FlagSnapshot } from '@bf42lite/protocol';
import { TEAM_COLORS } from './constants';

export class FlagRenderer {
  private scene: THREE.Scene;
  private flags = new Map<number, THREE.Object3D>();

  constructor(scene: THREE.Scene) {
    this.scene = scene;
  }

  updateFromSnapshot(flags: FlagSnapshot[]): void {
    const seen = new Set<number>();

    for (const f of flags) {
      let group = this.flags.get(f.id);
      if (!group) {
        group = this.createFlagMesh(f);
        this.scene.add(group);
        this.flags.set(f.id, group);
      }

      this.updateFlagTransform(group, f);
      this.updateFlagVisual(group, f);
      seen.add(f.id);
    }

    for (const [id, obj] of this.flags) {
      if (!seen.has(id)) {
        this.scene.remove(obj);
        this.flags.delete(id);
      }
    }
  }

  private createFlagMesh(flag: FlagSnapshot): THREE.Object3D {
    const group = new THREE.Group();
    group.name = `flag-${flag.id}`;

    const radius = flag.radius && flag.radius > 0 ? flag.radius : 8.0;

    const poleGeom = new THREE.BoxGeometry(0.4, 6, 0.4);
    const poleMat = new THREE.MeshStandardMaterial({ color: TEAM_COLORS.NEUTRAL });
    const pole = new THREE.Mesh(poleGeom, poleMat);
    pole.position.y = 3;
    pole.castShadow = true;
    pole.receiveShadow = true;
    pole.name = 'pole';
    group.add(pole);

    const bannerGeom = new THREE.BoxGeometry(1.2, 0.8, 0.1);
    const bannerMat = new THREE.MeshStandardMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
    });
    const banner = new THREE.Mesh(bannerGeom, bannerMat);
    banner.position.set(0.6, 5.5, 0);
    banner.castShadow = true;
    banner.name = 'banner';
    group.add(banner);

    const ringGeom = new THREE.RingGeometry(radius - 0.3, radius, 64);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.6,
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.1;
    ring.name = 'ring';
    group.add(ring);

    const progGeom = new THREE.CircleGeometry(radius, 64);
    const progMat = new THREE.MeshBasicMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.4,
    });
    const progress = new THREE.Mesh(progGeom, progMat);
    progress.rotation.x = -Math.PI / 2;
    progress.position.y = 0.15;
    progress.scale.set(0, 0, 0);
    progress.name = 'progress';
    group.add(progress);

    group.position.set(flag.x, flag.y, flag.z);

    return group;
  }

  private updateFlagTransform(group: THREE.Object3D, flag: FlagSnapshot): void {
    group.position.set(flag.x, flag.y, flag.z);
  }

  private updateFlagVisual(group: THREE.Object3D, flag: FlagSnapshot): void {
    const banner = group.getObjectByName('banner') as THREE.Mesh | null;
    const pole = group.getObjectByName('pole') as THREE.Mesh | null;
    const progressDisc = group.getObjectByName('progress') as THREE.Mesh | null;

    if (!banner || !pole || !progressDisc) return;

    const poleMat = pole.material as THREE.MeshStandardMaterial;
    const bannerMat = banner.material as THREE.MeshStandardMaterial;
    const progMat = progressDisc.material as THREE.MeshBasicMaterial;

    poleMat.color.setHex(TEAM_COLORS.NEUTRAL);

    let baseColor = TEAM_COLORS.NEUTRAL;
    if (flag.owner === 'TeamA') baseColor = TEAM_COLORS.AXIS;
    else if (flag.owner === 'TeamB') baseColor = TEAM_COLORS.ALLIES;

    const rawProgress =
      typeof flag.capture === 'number' ? flag.capture : 0;
    const clamped = Math.max(-1, Math.min(1, rawProgress));
    const t = Math.abs(clamped);

    progressDisc.scale.set(t, t, t);

    let teamColor = 0xffffff;
    if (clamped > 0) {
      teamColor = TEAM_COLORS.AXIS;
    } else if (clamped < 0) {
      teamColor = TEAM_COLORS.ALLIES;
    }

    const white = new THREE.Color(0xffffff);
    const teamCol = new THREE.Color(teamColor);
    white.lerp(teamCol, t);

    if (clamped === 0) {
      progMat.color.setHex(0xffffff);
      bannerMat.color.setHex(baseColor);
    } else {
      bannerMat.color.copy(white);
      progMat.color.copy(white);
    }
  }
}


## FILE: apps\client-tauri\src\core\GameLoop.ts
---------------------------
// apps/client-tauri/src/core/GameLoop.ts

/**
 * Simple, reusable game loop wrapper around requestAnimationFrame.
 *
 * Responsibilities:
 * - Manage start/stop of the loop
 * - Track dt, tick, and FPS
 * - Call back into game code once per frame via onFrame
 *
 * It does NOT know about ECS, networking, or rendering.
 */
export interface GameLoopHooks {
  /**
   * Called once per animation frame.
   *
   * @param dt   Delta time in seconds since last frame.
   * @param tick Monotonic simulation tick counter (increments every frame).
   * @param now  High-resolution timestamp (ms) from performance.now().
   */
  onFrame: (dt: number, tick: number, now: number) => void;

  /**
   * Optional callback when the loop starts.
   */
  onStarted?: () => void;

  /**
   * Optional callback when the loop stops.
   */
  onStopped?: () => void;
}

export class GameLoop {
  private running = false;
  private lastFrameTime = 0;
  private tick = 0;
  private fps = 0;
  private rafId: number | null = null;

  private readonly hooks: GameLoopHooks;

  constructor(hooks: GameLoopHooks) {
    this.hooks = hooks;
  }

  /**
   * Start the game loop if it is not already running.
   */
  public start() {
    if (this.running) return;

    this.running = true;
    this.lastFrameTime = performance.now();
    this.tick = 0;

    if (this.hooks.onStarted) {
      this.hooks.onStarted();
    }

    this.rafId = requestAnimationFrame(this.loop);
  }

  /**
   * Stop the game loop. Does not reset tick or FPS.
   */
  public stop() {
    if (!this.running) return;

    this.running = false;

    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }

    if (this.hooks.onStopped) {
      this.hooks.onStopped();
    }
  }

  /**
   * Current frames per second based on the last frame.
   */
  public getCurrentFps(): number {
    return this.fps;
  }

  /**
   * Current tick counter (increments once per frame while running).
   */
  public getCurrentTick(): number {
    return this.tick;
  }

  /**
   * Whether the loop is currently running.
   */
  public isRunning(): boolean {
    return this.running;
  }

  // Internal rAF callback
  private loop = (now: number) => {
    if (!this.running) {
      return;
    }

    // Schedule next frame first to avoid losing it if onFrame throws.
    this.rafId = requestAnimationFrame(this.loop);

    const dtMs = now - this.lastFrameTime;
    this.lastFrameTime = now;

    // Convert to seconds; protect against extremely small/large dt.
    const dt = Math.max(0, dtMs / 1000);

    if (dt > 0) {
      this.fps = Math.round(1 / dt);
    }

    const currentTick = this.tick;
    this.tick = currentTick + 1;

    // Delegate to caller
    this.hooks.onFrame(dt, currentTick, now);
  };
}


## FILE: apps\client-tauri\src\core\InputManager.ts
---------------------------
import { ClientInput } from '@bf42lite/protocol';

// Helper: Convert degrees to radians
const toRad = (deg: number) => deg * (Math.PI / 180);

export class InputManager {
  private keys = new Set<string>();
  private buttons = new Set<number>();
  
  private yaw = 0;
  private pitch = 0; 
  private readonly MAX_PITCH = toRad(85);

  // === 1. ADD STATE FLAGG ===
  private isInteractionEnabled = false; 

  constructor() {
    window.addEventListener('keydown', (e) => this.keys.add(e.code));
    window.addEventListener('keyup', (e) => this.keys.delete(e.code));
    window.addEventListener('mousedown', (e) => this.buttons.add(e.button));
    window.addEventListener('mouseup', (e) => this.buttons.delete(e.button));

    document.addEventListener('mousemove', (e) => {
      // Only rotate if locked AND enabled
      if (document.pointerLockElement && this.isInteractionEnabled) {
        const sensitivity = 0.002;
        this.yaw -= e.movementX * sensitivity;
        this.pitch -= e.movementY * sensitivity;
        this.pitch = Math.max(-this.MAX_PITCH, Math.min(this.MAX_PITCH, this.pitch));
      }
    });

    document.addEventListener('click', (e) => {
      // === 2. CHECK STATE BEFORE LOCKING ===
      if (!this.isInteractionEnabled) return; 

      // Prevent locking if we clicked a button/UI (extra safety)
      const target = e.target as HTMLElement;
      if (target.closest('button') || target.closest('.spawn-point')) return;

      if (!document.pointerLockElement) {
        document.body.requestPointerLock(); 
      }
    });
  }

  // === 3. EXPOSE CONTROL METHOD ===
  public setInteraction(enabled: boolean) {
      this.isInteractionEnabled = enabled;
  }

  getCommand(tick: number): ClientInput {
    // If in menu, return empty input
    if (!this.isInteractionEnabled) {
        return {
            type: 'input',
            tick,
            axes: { forward:0, right:0, jump:false, shoot:false, reload:false, yaw: this.yaw, pitch: this.pitch }
        };
    }

    let forward = 0;
    let right = 0;
    
    if (this.keys.has('KeyW')) forward += 1;
    if (this.keys.has('KeyS')) forward -= 1;
    if (this.keys.has('KeyD')) right += 1;
    if (this.keys.has('KeyA')) right -= 1;

    return {
      type: 'input',
      tick,
      axes: {
        forward,
        right,
        jump: this.keys.has('Space'),
        shoot: this.buttons.has(0),
        reload: this.keys.has('KeyR'),
        yaw: this.yaw,
        pitch: this.pitch
      }
    };
  }
}


## FILE: apps\client-tauri\src\core\local-player.ts
---------------------------
// apps/client-tauri/src/core/local-player.ts
import {
    addEntity,
    addComponent,
    Transform,
    Velocity,
    InputState,
    Me,
  } from '@bf42lite/engine-core';
  
  import { Health, Ammo, Soldier, Team, Loadout } from '@bf42lite/games-bf42';
  
  export function createLocalPlayer(world: any): number {
    const id = addEntity(world);
  
    addComponent(world, Transform, id);
    addComponent(world, Velocity, id);
    addComponent(world, InputState, id);
    addComponent(world, Me, id);
  
    addComponent(world, Health, id);
    addComponent(world, Ammo, id);
    addComponent(world, Soldier, id);
    addComponent(world, Team, id);
    addComponent(world, Loadout, id);
  
    return id;
  }
  

## FILE: apps\client-tauri\src\core\render-update.ts
---------------------------
// apps/client-tauri/src/core/render-update.ts
import { updateGameFrame } from '../systems/updateGameFrame';
import type { Renderer } from './Renderer';
import type { InputManager } from './InputManager';
import type { WeaponSystem } from './WeaponSystem';

export function updateRenderFrame(
  dt: number,
  renderer: Renderer,
  input: InputManager,
  weapon: WeaponSystem
) {
  updateGameFrame(dt, renderer, input, weapon);
}


## FILE: apps\client-tauri\src\core\Renderer.ts
---------------------------
// apps/client-tauri/src/core/Renderer.ts

import * as THREE from 'three';
import { TEAM_COLORS, TEAM_IDS } from './constants';
import { log } from '../utils/log';
import { ModelFactory } from '../render/ModelFactory';
import { FlagVisual } from '../render/FlagVisual';

type RenderStatePlayer = {
  type: 'player';
  pos: { x: number; y: number; z: number };
  rot: number;   // yaw in radians
  pitch: number; // pitch in radians
  team: number;  // TEAM_IDS.*
};

type RenderStateFlag = {
  type: 'flag';
  pos: { x: number; y: number; z: number };
  team: number;      // TEAM_IDS.*
  progress: number;  // capture progress (-1..1 or 0..1)
};

export type RenderState = RenderStatePlayer | RenderStateFlag;

/**
 * Thin 3D renderer for bf42lite.
 *
 * Responsibilities:
 * - Own Three.js Scene / Camera / WebGLRenderer
 * - Maintain a map of ECS entity id -> THREE.Object3D
 * - Provide utility hooks (getCamera, drawTracer, updateEntity, render)
 *
 * It does NOT know about ECS directly; it only consumes RenderState.
 */
export class Renderer {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;

  // Map ECS entity IDs -> ThreeJS objects (Mesh or Group)
  private entities = new Map<number, THREE.Object3D>();

  // Optional hooks used by RemoteEntitySync
  public onEntityCreated?: (id: number) => void;
  public onEntityUpdated?: (id: number) => void;

  constructor() {
    // --- Scene ---
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x87ceeb); // sky blue
    this.scene.fog = new THREE.Fog(0x87ceeb, 20, 150);

    // --- Ground plane (simple arena) ---
    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshPhongMaterial({ color: 0x558855 }),
    );
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    this.scene.add(plane);

    // --- Camera ---
    const aspect = window.innerWidth / window.innerHeight;
    this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 500);
    this.camera.position.set(0, 10, 20);
    this.camera.lookAt(0, 0, 0);

    // --- Lights ---
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(20, 40, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.left = -80;
    dirLight.shadow.camera.right = 80;
    dirLight.shadow.camera.top = 80;
    dirLight.shadow.camera.bottom = -80;
    this.scene.add(dirLight);

    const ambient = new THREE.AmbientLight(0x505050);
    this.scene.add(ambient);

    // --- WebGLRenderer ---
    const canvas = document.getElementById('game') as HTMLCanvasElement | null;
    if (!canvas) {
      throw new Error('Renderer: <canvas id="game"> not found in DOM');
    }

    this.renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
    });
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.setSize(window.innerWidth, window.innerHeight);

    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      this.camera.aspect = w / h;
      this.camera.updateProjectionMatrix();
      this.setSize(w, h);
    });

    log.info('RENDER', 'Renderer initialized');
  }

  // ---------------------------------------------------------------------------
  // Public API
  // ---------------------------------------------------------------------------

  public getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  public setSize(width: number, height: number): void {
    this.renderer.setSize(width, height);
  }

  /**
   * Main entry point from worldRender / RemoteEntitySync.
   *
   * If the entity does not exist, it is created; otherwise its transform
   * and visuals are updated in-place.
   */
  public updateEntity(
    id: number,
    state: RenderState,
    isLocalPlayer: boolean,
  ): void {
    let object = this.entities.get(id);

    if (!object) {
      object = this.createObjectForState(state, isLocalPlayer);
      this.scene.add(object);
      this.entities.set(id, object);

      if (this.onEntityCreated) {
        this.onEntityCreated(id);
      }
    }

    this.applyStateToObject(object, state, isLocalPlayer);

    if (this.onEntityUpdated) {
      this.onEntityUpdated(id);
    }
  }

  /**
   * Debug / cosmetic tracer used by WeaponSystem.
   */
  public drawTracer(start: THREE.Vector3, end: THREE.Vector3): void {
    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    const material = new THREE.LineBasicMaterial({ color: 0xffdd33 });
    const line = new THREE.Line(geometry, material);
    this.scene.add(line);

    // Remove shortly after
    window.setTimeout(() => {
      this.scene.remove(line);
      geometry.dispose();
      material.dispose();
    }, 100);
  }

  /**
   * Render one frame.
   */
  public render(): void {
    this.renderer.render(this.scene, this.camera);
  }

  // ---------------------------------------------------------------------------
  // Object creation helpers
  // ---------------------------------------------------------------------------

  private createObjectForState(
    state: RenderState,
    _isLocalPlayer: boolean,
  ): THREE.Object3D {
    if (state.type === 'player') {
      return ModelFactory.createPlayer();
    } else {
      // Flags currently use a fixed radius (8m) on the client side.
      return ModelFactory.createFlag(8.0);
    }
  }

  // ---------------------------------------------------------------------------
  // State application helpers
  // ---------------------------------------------------------------------------

  private applyStateToObject(
    object: THREE.Object3D,
    state: RenderState,
    isLocalPlayer: boolean,
  ): void {
    if (state.type === 'player') {
      const playerState = state as RenderStatePlayer;
      const group = object as THREE.Group;

      // Position + rotation for the soldier mesh
      group.position.set(
        playerState.pos.x,
        playerState.pos.y,
        playerState.pos.z,
      );
      group.rotation.y = playerState.rot;
      group.userData.team = playerState.team;

      // Team tint on body, if present
      const body = group.getObjectByName('body') as THREE.Mesh | null;
      if (body) {
        const bodyMat = body.material as THREE.MeshPhongMaterial;
        bodyMat.color.setHex(this.getTeamColor(playerState.team));
      }

      if (isLocalPlayer) {
        // First-person camera placement
        this.camera.position.set(
          playerState.pos.x,
          playerState.pos.y + 1.6, // eye height
          playerState.pos.z,
        );

        this.camera.rotation.set(
          playerState.pitch || 0,
          playerState.rot,
          0,
          'YXZ',
        );

        // Hide own body in first person
        group.visible = false;
      } else {
        group.visible = true;
      }

      return;
    }

    // === FLAG LOGIC ===
    const flagState = state as RenderStateFlag;
    const group = object as THREE.Group;

    // Position
    group.position.set(
      flagState.pos.x,
      flagState.pos.y,
      flagState.pos.z,
    );

    // Delegate all visual details (colors, pulses, arrow) to FlagVisual
    FlagVisual.applyState(group, flagState.team, flagState.progress);
  }

  private getTeamColor(team: number): number {
    if (team === TEAM_IDS.AXIS) return TEAM_COLORS.AXIS as number;
    if (team === TEAM_IDS.ALLIES) return TEAM_COLORS.ALLIES as number;
    return TEAM_COLORS.NEUTRAL as number;
  }
}


## FILE: apps\client-tauri\src\core\snapshot-handler.ts
---------------------------
// apps/client-tauri/src/core/snapshot-handler.ts
import { handleSnapshot, SnapshotMessage } from '../systems/handleSnapshot';
import type { FlagSnapshot } from '@bf42lite/protocol';
import type { Renderer } from './Renderer';
import type { NetworkManager } from '../managers/NetworkManager';
import type { UIManager } from '../managers/UIManager';

export interface SnapshotResult {
  flags: FlagSnapshot[];
}

export function processSnapshot(
  msg: SnapshotMessage,
  world: any,
  renderer: Renderer,
  net: NetworkManager,
  ui: UIManager
): SnapshotResult {
  handleSnapshot(msg, world, renderer, net, ui);

  return {
    flags: (msg.flags ?? []) as FlagSnapshot[],
  };
}


## FILE: apps\client-tauri\src\core\WeaponSystem.ts
---------------------------
// apps/client-tauri/src/core/WeaponSystem.ts

import * as THREE from 'three';
import { Renderer } from './Renderer';
import { NetworkManager } from '../managers/NetworkManager';
import { InputState } from '@bf42lite/engine-core';
import { WEAPON_STATS, CLASS_IDS } from './constants';

export class WeaponSystem {
  private lastFireTime = 0;
  private readonly RANGE = 100;

  private raycaster = new THREE.Raycaster();

  // Track current class
  public currentClassId = CLASS_IDS.ASSAULT;

  constructor(
    private renderer: Renderer,
    private net: NetworkManager,
  ) {}

  public setClass(classId: number) {
    // Clamp to known classes; fallback to Assault
    if (Object.prototype.hasOwnProperty.call(WEAPON_STATS, classId)) {
      this.currentClassId = classId;
    } else {
      this.currentClassId = CLASS_IDS.ASSAULT;
    }
  }

  public update(_dt: number, myEntityId: number, currentTick: number) {
    if (myEntityId < 0) return;

    const stats =
      WEAPON_STATS[
        this.currentClassId as keyof typeof WEAPON_STATS
      ] ?? WEAPON_STATS[CLASS_IDS.ASSAULT];

    const isShooting = (InputState.buttons[myEntityId] & 2) !== 0;

    if (isShooting) {
      const now = performance.now() / 1000;

      if (now - this.lastFireTime > stats.rate) {
        this.fire(currentTick);
        this.lastFireTime = now;
      }
    }
  }

  private fire(tick: number) {
    const camera = this.renderer.getCamera();
    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const start = camera.position.clone();
    const direction = this.raycaster.ray.direction.clone();
    const end = start.clone().add(direction.clone().multiplyScalar(this.RANGE));

    this.net.sendFire(
      { x: start.x, y: start.y, z: start.z },
      { x: direction.x, y: direction.y, z: direction.z },
      tick,
    );

    const visualOffset = new THREE.Vector3(0.2, -0.2, 0.5);
    visualOffset.applyQuaternion(camera.quaternion);
    const visualStart = start.clone().add(visualOffset);

    this.renderer.drawTracer(visualStart, end);
  }
}


## FILE: apps\client-tauri\src\managers\NetworkManager.ts
---------------------------
// apps/client-tauri/src/managers/NetworkManager.ts

import { WebSocketAdapter, type NetworkAdapter } from '@bf42lite/net';
import type {
  ClientInput,
  ClientFire,
  ClientMessage,
  Snapshot,
} from '@bf42lite/protocol';
import type { SimWorld } from '@bf42lite/engine-core';
import { log } from '../utils/log';

import type { Renderer } from '../core/Renderer';
import type { Reconciler } from '../systems/Reconciler';

import { decodeServerMessage } from '../network/SnapshotDecoder';
import { RemoteEntitySync } from '../network/RemoteEntitySync';
import { FlagSync } from '../network/FlagSync';
import { interpolateRemotePlayers as interpRemote } from '../network/interpolation';

// Local wire type for spawn request â€“ must match Rust/zod schema
type SpawnRequestWire = {
  type: 'spawn_request';
  classId: number;
};

export class NetworkManager {
  // --- Callbacks exposed to ClientGame / UI ---

  onConnected: () => void = () => {};
  onDisconnected: () => void = () => {};
  onWelcome: (serverId: number) => void = () => {};
  onSnapshot: (snap: Snapshot) => void = () => {};
  onHitConfirmed: (damage: number) => void = () => {};

  // --- Internal state ---

  private net: NetworkAdapter;
  private world: SimWorld;
  private renderer: Renderer;
  private reconciler: Reconciler;

  private myServerId = -1;
  private serverToLocal = new Map<number, number>();

  // Monotonic counter used by decodeServerMessage (for timestamps/ticks)
  private nextTick = 0;

  constructor(world: SimWorld, renderer: Renderer, reconciler: Reconciler) {
    this.world = world;
    this.renderer = renderer;
    this.reconciler = reconciler;

    this.net = new WebSocketAdapter();

    this.net.onConnect(() => {
      log.info('NET', 'Connected');
      this.onConnected();
    });

    this.net.onDisconnect(() => {
      log.warn('NET', 'Disconnected');
      this.onDisconnected();
    });

    this.net.onMessage((raw) => this.handleMessage(raw));
  }

  // --- Connection ---

  connect(url: string): void {
    this.net.connect(url);
  }

  // --- Incoming messages ---

  private handleMessage(raw: unknown): void {
    const decoded = decodeServerMessage(raw, this.nextTick++);
    const nowTs = performance.now();

    switch (decoded.type) {
      case 'welcome': {
        this.myServerId = decoded.yourId;
        log.info('NET', 'Welcome', { serverId: this.myServerId });
        this.onWelcome(this.myServerId);
        return;
      }

      case 'hit-confirmed': {
        log.debug('NET', 'Hit confirmed', { dmg: decoded.damage });
        this.onHitConfirmed(decoded.damage);
        return;
      }

      case 'snapshot': {
        const snapshot = decoded.snapshot;

        // Remote entities (ECS + interpolation buffers)
        RemoteEntitySync.apply(
          snapshot,
          this.world,
          this.renderer,
          this,
          this.reconciler,
          nowTs,
        );

        // Conquest / flags ECS state
        FlagSync.apply(snapshot, this.world);

        // Forward to ClientGame (sync local player, UI, etc.)
        this.onSnapshot(snapshot);

        return;
      }

      case 'unknown':
      default: {
        // Keep in console for debugging â€“ raw is preserved
        console.warn('[NET] Unhandled server message:', decoded.raw);
        return;
      }
    }
  }

  // --- Entity registry (server â†” local ECS ids) ---

  registerEntity(serverId: number, localId: number): void {
    this.serverToLocal.set(serverId, localId);
  }

  getLocalId(serverId: number): number | undefined {
    return this.serverToLocal.get(serverId);
  }

  // --- Outgoing: input / fire / spawn ---

  /** Alias kept for existing code: client uses `net.send(cmd)` */
  send(cmd: ClientInput): void {
    this.sendInput(cmd);
  }

  sendInput(cmd: ClientInput): void {
    this.net.send(cmd);
  }

  sendFire(
    origin: { x: number; y: number; z: number },
    direction: { x: number; y: number; z: number },
    tick: number,
  ): void {
    const msg: ClientFire = {
      type: 'fire',
      tick,
      origin,
      direction,
      // Mirror of current WeaponSystem config â€“ adjust when you add more weapons
      weaponId: 1,
    };
    this.net.send(msg);
  }

  sendSpawnRequest(classId: number): void {
    const msg: SpawnRequestWire = {
      type: 'spawn_request',
      classId,
    };
    this.net.send(msg as ClientMessage);
  }

  // --- Interpolation hook used by ClientGame / InterpolationSystem ---

  interpolateRemotePlayers(renderTimeMs: number): void {
    interpRemote(this.world, this.reconciler.remoteBuffers, renderTimeMs);
  }
}


## FILE: apps\client-tauri\src\managers\UIManager.ts
---------------------------
// apps/client-tauri/src/managers/UIManager.ts

export class UIManager {
    private ui: {
        deployScreen: HTMLElement | null;
        hudLayer: HTMLElement | null;
        healthVal: HTMLElement | null;
        healthFill: HTMLElement | null;
        spawnBtn: HTMLElement | null;
        ticketsAxis: HTMLElement | null;
        ticketsAllies: HTMLElement | null;
        fps: HTMLElement | null;
        rtt: HTMLElement | null;
        hitmarker: HTMLElement | null;
        gameOverScreen: HTMLElement | null;
        endTitle: HTMLElement | null;
        ammoCurr: HTMLElement | null;
        ammoRes: HTMLElement | null;
        weaponName: HTMLElement | null;

        // New HUD elements
        objectiveText: HTMLElement | null;
        flagStrip: HTMLElement | null;
        centerStatus: HTMLElement | null;
        flagList: HTMLElement | null;
        killFeed: HTMLElement | null;
    };

    private selectedSpawnId = -1;
    private hitTimeout: number | null = null;

    private onSpawnRequest: (classId: number) => void;
    private selectedClassId = 0; // Default to Assault

    constructor(onSpawnRequest: (classId: number) => void) {
        this.onSpawnRequest = onSpawnRequest;

        this.ui = {
            deployScreen: document.getElementById('deploy-screen'),
            hudLayer: document.getElementById('hud-layer'),
            healthVal: document.getElementById('health-val'),
            healthFill: document.getElementById('health-fill'),
            spawnBtn: document.getElementById('btn-spawn'),
            ticketsAxis: document.getElementById('tickets-axis'),
            ticketsAllies: document.getElementById('tickets-allies'),
            fps: document.getElementById('fps'),
            rtt: document.getElementById('rtt'),
            hitmarker: document.getElementById('hitmarker'),
            gameOverScreen: document.getElementById('game-over-screen'),
            endTitle: document.getElementById('end-title'),
            ammoCurr: document.getElementById('ammo-curr'),
            ammoRes: document.getElementById('ammo-res'),
            weaponName: document.getElementById('weapon-name'),

            objectiveText: document.getElementById('objective-text'),
            flagStrip: document.getElementById('flag-strip'),
            centerStatus: document.getElementById('center-status'),
            flagList: document.getElementById('flag-list'),
            killFeed: document.getElementById('kill-feed'),
        };

        this.initListeners();
    }

    private initListeners() {
        // 1. Class Selection Listeners
        const classBtns = document.querySelectorAll('.class-btn');
        classBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                classBtns.forEach(b => b.classList.remove('selected'));
                const target = e.currentTarget as HTMLElement;
                target.classList.add('selected');

                const id = target.getAttribute('data-id');
                if (id) this.selectedClassId = parseInt(id, 10) || 0;
            });
        });

        // 2. Map / Spawn Point Click Listener
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
            mapContainer.addEventListener('click', (e: Event) => {
                const target = (e.target as HTMLElement).closest('.spawn-point') as HTMLElement | null;
                if (!target) return;

                document
                    .querySelectorAll('.spawn-point')
                    .forEach(el => el.classList.remove('selected'));
                target.classList.add('selected');

                this.selectedSpawnId = parseInt(target.dataset.id || '-1', 10);
            });
        }

        // 3. Spawn Button Click Listener
        if (this.ui.spawnBtn) {
            this.ui.spawnBtn.addEventListener('click', () => {
                // Spawn point enforcement optional; currently we let server decide
                this.setDeployMode(false);
                this.onSpawnRequest(this.selectedClassId);
            });
        }
    }

    // Show / hide deploy vs in-game HUD
    public setDeployMode(isDeploying: boolean) {
        if (isDeploying) {
            this.ui.deployScreen?.classList.remove('hidden');
            this.ui.hudLayer?.classList.add('hidden');
            document.exitPointerLock();
            if (this.ui.centerStatus) this.ui.centerStatus.innerText = '';
        } else {
            this.ui.deployScreen?.classList.add('hidden');
            this.ui.hudLayer?.classList.remove('hidden');

            const canvas = document.getElementById('game') as HTMLCanvasElement | null;
            if (canvas && document.pointerLockElement !== canvas) {
                canvas.requestPointerLock?.();
            }
        }
    }

    // Debug overlay stats
    public updateStats(fps: number, rtt: number) {
        if (this.ui.fps) this.ui.fps.innerText = fps.toFixed(0);
        if (this.ui.rtt) this.ui.rtt.innerText = rtt.toFixed(0);
    }

    public updateHealth(current: number) {
        if (this.ui.healthVal) this.ui.healthVal.innerText = current.toString();
        if (this.ui.healthFill) this.ui.healthFill.style.width = `${current}%`;
    }

    // Tickets + objective text
    public updateTickets(axis: number, allies: number) {
        // Round for display but keep logic using original floats
        const axisRounded = Math.max(0, Math.round(axis));
        const alliesRounded = Math.max(0, Math.round(allies));

        // AXIS
        if (this.ui.ticketsAxis) {
            this.ui.ticketsAxis.innerText = axisRounded.toString();

            if (axisRounded <= 20) this.ui.ticketsAxis.classList.add('low');
            else this.ui.ticketsAxis.classList.remove('low');
        }

        // ALLIES
        if (this.ui.ticketsAllies) {
            this.ui.ticketsAllies.innerText = alliesRounded.toString();

            if (alliesRounded <= 20) this.ui.ticketsAllies.classList.add('low');
            else this.ui.ticketsAllies.classList.remove('low');
        }

        // OBJECTIVE TEXT (still uses float logic, works fine)
        if (this.ui.objectiveText) {
            if (axis <= 0 && allies > 0) {
                this.ui.objectiveText.innerText = 'ALLIES ARE WINNING â€“ HOLD YOUR FLAGS';
            } else if (allies <= 0 && axis > 0) {
                this.ui.objectiveText.innerText = 'AXIS ARE WINNING â€“ HOLD YOUR FLAGS';
            } else {
                this.ui.objectiveText.innerText = 'CAPTURE AND HOLD THE FLAGS';
            }
        }
    }

    // Center status line (respawn / capturing hints)
    public setCenterStatus(text: string) {
        if (this.ui.centerStatus) {
            this.ui.centerStatus.innerText = text;
        }
    }

    /**
     * High-level entry point for all flag HUD elements.
     *
     * - Clears both strip + list if there are no flags.
     * - Uses raw snapshot objects for the mini strip.
     * - Normalizes data for the detailed list.
     */
    public updateFlagsHUD(rawFlags: any[] | undefined | null) {
        const flags = rawFlags ?? [];

        // No flags: clear both HUD elements and bail.
        if (!flags.length) {
            if (this.ui.flagStrip) {
                this.ui.flagStrip.innerHTML = '';
            }
            if (this.ui.flagList) {
                this.ui.flagList.innerHTML = '';
            }
            return;
        }

        // Mini strip uses the raw snapshot objects (id + owner).
        this.updateFlagStrip(flags as { id: number; owner: any }[]);

        // Detailed list uses a small normalized DTO.
        this.updateFlagList(
            flags.map((f: any) => ({
                id: f.id,
                owner: f.owner,
                capture: typeof f.capture === 'number' ? f.capture : 0,
            })),
        );
    }

    // Mini flag-strip at top center
    public updateFlagStrip(flags: { id: number; owner: any }[]) {
        if (!this.ui.flagStrip) return;
        const root = this.ui.flagStrip;
        root.innerHTML = '';

        flags.forEach((f) => {
            const div = document.createElement('div');
            div.classList.add('flag-mini');

            let cls = 'neutral';
            if (f.owner === 'TeamA' || f.owner === 1) cls = 'axis';
            else if (f.owner === 'TeamB' || f.owner === 2) cls = 'allies';

            div.classList.add(cls);
            root.appendChild(div);
        });
    }

    // Detailed flag list bottom-left
    public updateFlagList(flags: { id: number; owner: any; capture: number }[]) {
        if (!this.ui.flagList) return;
        const root = this.ui.flagList;
        root.innerHTML = '';

        flags.forEach((f) => {
            const row = document.createElement('div');
            row.classList.add('flag-row');

            const name = document.createElement('span');
            name.classList.add('flag-name');
            name.innerText = `Flag ${f.id}`;

            const owner = document.createElement('span');
            owner.classList.add('flag-owner');

            let ownerCls = 'neutral';
            let label = 'NEUTRAL';

            if (f.owner === 'TeamA' || f.owner === 1) {
                ownerCls = 'axis';
                label = 'AXIS';
            } else if (f.owner === 'TeamB' || f.owner === 2) {
                ownerCls = 'allies';
                label = 'ALLIES';
            }

            owner.classList.add(ownerCls);
            owner.innerText = label;

            const bar = document.createElement('div');
            bar.classList.add('flag-progress');

            const fill = document.createElement('div');
            fill.classList.add('flag-progress-fill');

            const t = Math.min(1, Math.abs(f.capture || 0));
            fill.style.width = `${t * 100}%`;

            bar.appendChild(fill);
            row.appendChild(name);
            row.appendChild(owner);
            row.appendChild(bar);

            root.appendChild(row);
        });
    }

    // Kill feed on the right side
    public pushKillFeed(killer: string, victim: string, weapon?: string) {
        if (!this.ui.killFeed) return;

        const entry = document.createElement('div');
        entry.classList.add('kill-entry');

        const weaponText = weapon ? ` [${weapon}]` : '';
        entry.innerText = `${killer} âžœ ${victim}${weaponText}`;

        this.ui.killFeed.prepend(entry);

        while (this.ui.killFeed.children.length > 5) {
            this.ui.killFeed.removeChild(this.ui.killFeed.lastChild as Node);
        }

        setTimeout(() => {
            entry.classList.add('fade-out');
            setTimeout(() => entry.remove(), 500);
        }, 3000);
    }

    public showHitMarker(_damage?: number) {
        if (!this.ui.hitmarker) return;
        this.ui.hitmarker.classList.remove('hit-active');
        void this.ui.hitmarker.offsetWidth;
        this.ui.hitmarker.classList.add('hit-active');

        if (this.hitTimeout) clearTimeout(this.hitTimeout);
        this.hitTimeout = window.setTimeout(() => {
            if (this.ui.hitmarker) {
                this.ui.hitmarker.classList.remove('hit-active');
            }
        }, 200);
    }

    public setGameOver(isGameOver: boolean, winningTeam: string) {
        if (!this.ui.gameOverScreen || !this.ui.endTitle) return;
        if (isGameOver) {
            this.ui.gameOverScreen.classList.add('visible');
            this.ui.endTitle.innerText = winningTeam;
            document.exitPointerLock();
        } else {
            this.ui.gameOverScreen.classList.remove('visible');
        }
    }

    public updateAmmo(current: number, reserve: number, weaponName?: string) {
        if (this.ui.ammoCurr) this.ui.ammoCurr.innerText = current.toString();
        if (this.ui.ammoRes) this.ui.ammoRes.innerText = reserve.toString();
        if (this.ui.weaponName && weaponName) this.ui.weaponName.innerText = weaponName;
    }

    // Respawn timer â†’ center status and spawn button text
    public updateRespawn(isDead: boolean, timer: number) {
        if (!this.ui.spawnBtn) return;

        if (isDead) {
            if (timer > 0) {
                this.ui.spawnBtn.innerText = `Deploy in ${timer.toFixed(1)}s`;
                this.ui.spawnBtn.setAttribute('disabled', 'true');
                this.ui.spawnBtn.style.pointerEvents = 'none';
                this.ui.spawnBtn.style.opacity = '0.5';

                this.setCenterStatus(`Respawning in ${timer.toFixed(1)}s`);
            } else {
                this.ui.spawnBtn.innerText = 'DEPLOY (Press SPACE)';
                this.ui.spawnBtn.removeAttribute('disabled');
                this.ui.spawnBtn.style.pointerEvents = 'auto';
                this.ui.spawnBtn.style.opacity = '1.0';

                this.setCenterStatus('Press SPACE or click DEPLOY to respawn');
            }
        } else {
            this.setCenterStatus('');
        }
    }
}


## FILE: apps\client-tauri\src\net\CommandSender.ts
---------------------------
// apps/client-tauri/src/net/CommandSender.ts

import type { ClientInput } from '@bf42lite/protocol';
import type { NetworkManager } from '../managers/NetworkManager';

/**
 * CommandSender is responsible for:
 * - Accumulating frame time (dt)
 * - Throttling client input sends to a fixed interval
 * - Forwarding commands to NetworkManager
 *
 * It does NOT know about ECS, prediction, or rendering.
 */
export class CommandSender {
  private accumulator = 0;
  private readonly sendInterval: number;
  private readonly net: NetworkManager;

  /**
   * @param net          NetworkManager instance used to actually send commands.
   * @param sendInterval Interval in seconds between input sends (default 1/30 â‰ˆ 33 ms).
   */
  constructor(net: NetworkManager, sendInterval: number = 1 / 30) {
    this.net = net;
    this.sendInterval = sendInterval;
  }

  /**
   * Advance the internal timer and send the given command when the
   * accumulated time exceeds the configured interval.
   *
   * You should call this once per frame from the main game loop.
   *
   * @param dt   Delta time in seconds since last frame.
   * @param cmd  The current frame's input command (or null/undefined if none).
   */
  public update(dt: number, cmd: ClientInput | null | undefined): void {
    this.accumulator += dt;

    while (this.accumulator >= this.sendInterval) {
      if (cmd) {
        this.net.send(cmd);
      }
      this.accumulator -= this.sendInterval;
    }
  }

  /**
   * Reset the accumulator. Useful when pausing/unpausing or on major
   * time jumps (e.g. after a long tab-out).
   */
  public reset(): void {
    this.accumulator = 0;
  }
}


## FILE: apps\client-tauri\src\network\FlagSync.ts
---------------------------
// apps/client-tauri/src/network/FlagSync.ts

import {
  Transform,
  addComponent,
  addEntity,
} from '@bf42lite/engine-core';

import {
  CapturePoint,
} from '@bf42lite/games-bf42';

import type { Snapshot } from '@bf42lite/protocol';

export class FlagSync {
  private static flagMap = new Map<number, number>();

  private static ensureFlag(world: any, id: number): number {
    if (!FlagSync.flagMap.has(id)) {
      const eid = addEntity(world);
      addComponent(world, CapturePoint, eid);
      addComponent(world, Transform, eid);
      FlagSync.flagMap.set(id, eid);
      return eid;
    }

    // non-null assertion is safe here because we just checked
    return FlagSync.flagMap.get(id)!;
  }

  static apply(snapshot: Snapshot, world: any) {
    if (!snapshot.flags) return;

    for (const f of snapshot.flags) {
      const eid = this.ensureFlag(world, f.id);

      Transform.x[eid] = f.x;
      Transform.y[eid] = f.y;
      Transform.z[eid] = f.z;

      CapturePoint.radius[eid] = f.radius ?? 8;
      CapturePoint.owner[eid] =
        f.owner === 'TeamA' ? 1 :
        f.owner === 'TeamB' ? 2 : 0;
      CapturePoint.capture[eid] = f.capture ?? 0;
    }
  }
}


## FILE: apps\client-tauri\src\network\index.ts
---------------------------
// apps/client-tauri/src/network/index.ts

export * from './types';
export * from './SnapshotDecoder';
export * from './interpolation';


## FILE: apps\client-tauri\src\network\interpolation.ts
---------------------------
// apps/client-tauri/src/network/interpolation.ts

import {
    Transform,
    type SimWorld,
  } from '@bf42lite/engine-core';
  import type {
    InterpolationBuffer,
    InterpolationSnapshot,
  } from './types';
  
  /**
   * Push a new interpolation snapshot into the buffer for a given entity.
   * Keeps history capped to `maxSnapshots`.
   */
  export function pushInterpolationSnapshot(
    buffers: Map<number, InterpolationBuffer>,
    localId: number,
    tick: number,
    pos: { x: number; y: number; z: number },
    rot: number,
    timestamp: number,
    maxSnapshots = 20,
  ): void {
    let buffer = buffers.get(localId);
    if (!buffer) {
      buffer = { snapshots: [] };
      buffers.set(localId, buffer);
    }
  
    const snap: InterpolationSnapshot = {
      tick,
      pos: { x: pos.x, y: pos.y, z: pos.z },
      rot,
      timestamp,
    };
  
    buffer.snapshots.push(snap);
    if (buffer.snapshots.length > maxSnapshots) {
      buffer.snapshots.shift();
    }
  }
  
  /**
   * Simple time-based interpolation for remote player positions.
   *
   * `renderTimeMs` should be something like `performance.now() - INTERPOLATION_DELAY_MS`
   * to introduce a small delay and ensure you almost always have at least
   * two snapshots to interpolate between.
   */
  export function interpolateRemotePlayers(
    world: SimWorld,
    buffers: Map<number, InterpolationBuffer>,
    renderTimeMs: number,
  ): void {
    for (const [eid, buffer] of buffers.entries()) {
      const snaps = buffer.snapshots;
      if (snaps.length < 2) continue;
  
      // Find the two snapshots that bracket renderTimeMs
      let prev: InterpolationSnapshot | undefined;
      let next: InterpolationSnapshot | undefined;
  
      for (let i = snaps.length - 1; i >= 0; i--) {
        const s = snaps[i];
        if (s.timestamp <= renderTimeMs) {
          prev = s;
          next = snaps[i + 1];
          break;
        }
      }
  
      // Fallback to last two if we didn't find a proper bracket
      if (!prev || !next) {
        prev = snaps[snaps.length - 2];
        next = snaps[snaps.length - 1];
      }
  
      if (!prev || !next) continue;
  
      const span = next.timestamp - prev.timestamp;
      const tRaw =
        span > 0 ? (renderTimeMs - prev.timestamp) / span : 0;
      const t = Math.max(0, Math.min(1, tRaw));
  
      const lerp = (a: number, b: number) => a + (b - a) * t;
  
      Transform.x[eid] = lerp(prev.pos.x, next.pos.x);
      Transform.y[eid] = lerp(prev.pos.y, next.pos.y);
      Transform.z[eid] = lerp(prev.pos.z, next.pos.z);
      Transform.rotation[eid] = lerp(prev.rot, next.rot);
    }
  
    // Currently no need to touch `world` fields; transform changes are enough.
  }
  

## FILE: apps\client-tauri\src\network\RemoteEntitySync.ts
---------------------------
// apps/client-tauri/src/network/RemoteEntitySync.ts

import {
  Transform,
  Velocity,
  addComponent,
  addEntity,
} from '@bf42lite/engine-core';

import {
  Health,
  Ammo,
  Soldier,
  Team,
  Loadout,
} from '@bf42lite/games-bf42';

import type { Snapshot } from '@bf42lite/protocol';
import type { NetworkManager } from '../managers/NetworkManager';
import type { Renderer } from '../core/Renderer';
import type { Reconciler } from '../systems/Reconciler';
import {
  pushInterpolationSnapshot,
} from './interpolation';

/**
 * This module processes *remote* entities:
 * - ensures they exist in ECS
 * - updates their transform & components
 * - sends interpolation data to the reconciler buffer
 */
export class RemoteEntitySync {
  private static ensureEntity(
    world: any,
    net: NetworkManager,
    renderer: Renderer,
    serverId: number,
  ): number {
    const existing = net.getLocalId(serverId);
    if (existing !== undefined) return existing;

    const eid = addEntity(world);

    addComponent(world, Transform, eid);
    addComponent(world, Velocity, eid);
    addComponent(world, Soldier, eid);
    addComponent(world, Health, eid);
    addComponent(world, Ammo, eid);
    addComponent(world, Team, eid);
    addComponent(world, Loadout, eid);

    net.registerEntity(serverId, eid);
    if (renderer.onEntityCreated) {
      renderer.onEntityCreated(eid);
    }

    return eid;
  }

  static apply(
    snapshot: Snapshot,
    world: any,
    renderer: Renderer,
    net: NetworkManager,
    reconciler: Reconciler,
    nowTs: number,
  ) {
    if (!snapshot.entities) return;

    for (const ent of snapshot.entities) {
      const serverId = ent.id;
      if (serverId == null) continue;

      const eid = this.ensureEntity(world, net, renderer, serverId);

      // Transform / rotation
      if (ent.pos) {
        const { x, y, z } = ent.pos;
        Transform.x[eid] = x;
        Transform.y[eid] = y;
        Transform.z[eid] = z;

        if (typeof ent.rot === 'number') {
          Transform.rotation[eid] = ent.rot;
        }

        // Interpolation history
        pushInterpolationSnapshot(
          reconciler.remoteBuffers,
          eid,
          snapshot.tick,
          { x, y, z },
          ent.rot ?? 0,
          nowTs,
        );
      }

      // Health / death
      if (ent.health != null) {
        Health.current[eid] = ent.health;
        Health.isDead[eid] = ent.isDead ? 1 : 0;
      }

      // Team
      if (ent.team) {
        Team.id[eid] = ent.team.id === 'TeamA' ? 1 : 2;
      }

      // Loadout / class
      if (ent.loadout) {
        Loadout.classId[eid] = ent.loadout.classId ?? 0;
      }

      // Ammo
      if (ent.ammo) {
        Ammo.current[eid] = ent.ammo.current ?? 0;
        Ammo.reserve[eid] = ent.ammo.reserve ?? 0;
      }

      if (renderer.onEntityUpdated) {
        renderer.onEntityUpdated(eid);
      }
    }
  }
}


## FILE: apps\client-tauri\src\network\SnapshotDecoder.ts
---------------------------
// apps/client-tauri/src/network/SnapshotDecoder.ts

import type {
    Snapshot,
    FlagSnapshot,
    GameModeState,
  } from '@bf42lite/protocol';
  import type {
    DecodedServerMessage,
  } from './types';
  
  /**
   * Normalize flag snapshots coming from Rust/host into uniform object form.
   * Supports both:
   *   - Array layout: [id, x, y, z, radius, ownerStr, capture]
   *   - Object layout: { id, pos: {x,y,z}, radius, owner, capture }
   */
  export function normalizeFlags(raw: any[] | undefined | null): FlagSnapshot[] {
    const src = raw ?? [];
  
    return src.map((f: any): FlagSnapshot => {
      if (Array.isArray(f)) {
        const id = f[0];
        const x = f[1];
        const y = f[2];
        const z = f[3];
        const radius = f[4] ?? 0;
        const owner = f[5] ?? null;
        const capture = typeof f[6] === 'number' ? f[6] : 0;
  
        return {
          id: id ?? 0,
          x: x ?? 0,
          y: y ?? 0,
          z: z ?? 0,
          radius,
          owner,
          capture,
        };
      }
  
      const pos = f.pos ?? {};
      const x = f.x ?? pos.x ?? 0;
      const y = f.y ?? pos.y ?? 0;
      const z = f.z ?? pos.z ?? 0;
      const radius = f.radius ?? f.r ?? 0;
      const owner = f.owner ?? null;
      const capture = typeof f.capture === 'number' ? f.capture : 0;
  
      return {
        id: f.id ?? 0,
        x,
        y,
        z,
        radius,
        owner,
        capture,
      };
    });
  }
  
  /**
   * Centralized decoder for all server â†’ client messages.
   *
   * `nextTick` should be provided by the caller (NetworkManager) and is used
   * to assign a monotonically increasing tick to snapshots that do not
   * already have a tick number (array / Rust envelopes).
   */
  export function decodeServerMessage(
    raw: any,
    nextTick: number,
  ): DecodedServerMessage {
    // 1) Array-based messages (older/alternate host): [kindId, payload]
    if (Array.isArray(raw)) {
      const arr = raw as any[];
  
      if (arr.length === 2) {
        const [kindId, payload] = arr;
  
        // kindId === 1 => snapshot
        if (kindId === 1 && Array.isArray(payload)) {
          const [entitiesRaw, flagsRaw, gameStateRaw] = payload as [
            any[],
            any[],
            any,
          ];
  
          const flags = normalizeFlags(flagsRaw);
  
          const game_state: GameModeState | undefined = Array.isArray(
            gameStateRaw,
          )
            ? {
                team_a_tickets: gameStateRaw[0] ?? 0,
                team_b_tickets: gameStateRaw[1] ?? 0,
                match_ended: !!gameStateRaw[2],
                winner: null,
              }
            : gameStateRaw;
  
          const snapshot: Snapshot = {
            type: 'snapshot',
            tick: nextTick,
            entities: entitiesRaw ?? [],
            flags,
            game_state,
          };
  
          return { type: 'snapshot', snapshot };
        }
      }
  
      return { type: 'unknown', raw };
    }
  
    // 2) Object-style messages (current Rust host + legacy JSON)
    const msg = raw as any;
  
    // Explicit "welcome" style: { type: 'welcome', yourId }
    if (msg.type === 'welcome' && typeof msg.yourId === 'number') {
      return {
        type: 'welcome',
        yourId: msg.yourId,
      };
    }
  
    // Legacy JSON snapshot already matching the Snapshot interface
    if (msg.type === 'snapshot') {
      return {
        type: 'snapshot',
        snapshot: msg as Snapshot,
      };
    }
  
    // Hit confirm notification
    if (msg.type === 'hit-confirmed') {
      return {
        type: 'hit-confirmed',
        damage: msg.damage ?? 0,
      };
    }
  
    // Rust/Tauri envelope: { your_id, snapshot: { ... } }
    if (msg.snapshot) {
      const rawFlags =
        msg.snapshot.flags || msg.snapshot.flag_snapshots || [];
  
      const flags = normalizeFlags(rawFlags);
  
      const snapshot: Snapshot = {
        type: 'snapshot',
        tick: nextTick,
        entities: msg.snapshot.entities ?? [],
        flags,
        game_state: msg.snapshot.game_state,
        game: msg.snapshot.game, // keep for backward compatibility, if present
      };
  
      const decoded: any = {
        type: 'snapshot' as const,
        snapshot,
      };
  
      if (typeof msg.your_id === 'number') {
        decoded.yourId = msg.your_id;
      }
  
      return decoded;
    }
  
    // Fallback: unknown/unhandled message
    return {
      type: 'unknown',
      raw,
    };
  }
  

## FILE: apps\client-tauri\src\network\types.ts
---------------------------
// apps/client-tauri/src/network/types.ts
import type { Snapshot, FlagSnapshot } from '@bf42lite/protocol';

// Normalized flag is already identical to the protocol FlagSnapshot.
// This alias is mainly for readability on the client side.
export type NormalizedFlag = FlagSnapshot;

// Interpolation types for remote entities
export interface InterpolationSnapshot {
  tick: number;
  pos: { x: number; y: number; z: number };
  rot: number;
  timestamp: number;
}

export interface InterpolationBuffer {
  snapshots: InterpolationSnapshot[];
}

// Decoded server messages after passing through the network decoder
export interface DecodedSnapshotMessage {
  type: 'snapshot';
  snapshot: Snapshot;
  yourId?: number;        // Present when coming from Rust envelope { your_id, snapshot }
}

export interface DecodedWelcomeMessage {
  type: 'welcome';
  yourId: number;
}

export interface DecodedHitMessage {
  type: 'hit-confirmed';
  damage: number;
}

export interface DecodedUnknownMessage {
  type: 'unknown';
  raw: any;
}

export type DecodedServerMessage =
  | DecodedSnapshotMessage
  | DecodedWelcomeMessage
  | DecodedHitMessage
  | DecodedUnknownMessage;


## FILE: apps\client-tauri\src\render\FlagVisual.ts
---------------------------
// apps/client-tauri/src/render/FlagVisual.ts
//
// Encapsulates all visual updates for flag objects created by ModelFactory.
// Renderer calls these methods when receiving a RenderStateFlag.

import * as THREE from 'three';
import { TEAM_COLORS, TEAM_IDS } from '../core/constants';

export class FlagVisual {
  /**
   * Apply ECS flag state to a THREE.Group flag instance.
   *
   * @param group    THREE.Group created by ModelFactory.createFlag()
   * @param team     current owning team (numeric ECS ID)
   * @param progress capture progress from -1 â†’ 1
   */
  public static applyState(
    group: THREE.Group,
    team: number,
    progress: number,
  ) {
    const banner = group.getObjectByName('banner') as THREE.Mesh | null;
    const ring = group.getObjectByName('ring') as THREE.Mesh | null;
    const progressDisc = group.getObjectByName('progress') as THREE.Mesh | null;
    const direction = group.getObjectByName('direction') as THREE.Mesh | null;

    if (!banner || !ring || !progressDisc) {
      console.warn('[FlagVisual] Missing banner/ring/progress in flag model');
      return;
    }

    const bannerMat = banner.material as THREE.MeshBasicMaterial;
    const ringMat = ring.material as THREE.MeshBasicMaterial;
    const progMat = progressDisc.material as THREE.MeshBasicMaterial;
    const dirMat = direction
      ? (direction.material as THREE.MeshBasicMaterial)
      : null;

    // Base ownership color from team
    let baseColor = TEAM_COLORS.NEUTRAL as number;
    if (team === TEAM_IDS.AXIS) baseColor = TEAM_COLORS.AXIS as number;
    else if (team === TEAM_IDS.ALLIES) baseColor = TEAM_COLORS.ALLIES as number;

    // Clamp capture progress [-1, 1]
    const raw = typeof progress === 'number' ? progress : 0;
    const clamped = Math.max(-1, Math.min(1, raw));
    const t = Math.abs(clamped); // 0..1

    // Scale progress disc
    progressDisc.scale.set(t, t, t);

    // Time-based pulse for contested / capturing effects
    const time = performance.now() / 1000;
    const pulse = 0.75 + 0.25 * Math.sin(time * 4); // ~0.5..1.0

    // Which team is currently capturing?
    let capturingColor = 0xffffff;
    let capturingTeam: number | null = null;
    if (clamped > 0) {
      capturingColor = TEAM_COLORS.AXIS as number;
      capturingTeam = TEAM_IDS.AXIS;
    } else if (clamped < 0) {
      capturingColor = TEAM_COLORS.ALLIES as number;
      capturingTeam = TEAM_IDS.ALLIES;
    }

    // Lerp white â†’ capturingColor by |progress|
    const white = new THREE.Color(0xffffff);
    const teamCol = new THREE.Color(capturingColor);
    white.lerp(teamCol, t); // â€œwhitishâ€ when low, pure team color when full

    const isCapturing = clamped !== 0;
    const isContested = isCapturing && t < 0.4; // near-neutral but non-zero

    if (!isCapturing) {
      // Idle: banner is owner color, ring is subtle, arrow hidden
      bannerMat.color.setHex(baseColor);
      progMat.color.setHex(0xffffff);
      ringMat.opacity = 0.3;

      if (direction && dirMat) {
        direction.visible = false;
        dirMat.opacity = 0.0;
      }
    } else {
      // Actively being captured: banner + progress use capture color
      bannerMat.color.copy(white);
      progMat.color.copy(white);

      // Ring opacity increases with progress; pulses when â€œcontestedâ€
      const baseOpacity = 0.25 + 0.5 * t; // 0.25 .. 0.75
      ringMat.opacity = baseOpacity * (isContested ? pulse : 1.0);

      if (direction && dirMat && capturingTeam !== null) {
        direction.visible = true;

        // Direction arrow color = capturing team
        dirMat.color.setHex(capturingColor);
        dirMat.opacity = 0.5 + 0.4 * pulse; // subtle pulse

        // Spin direction based on capturing team (A vs B)
        const dirSign = capturingTeam === TEAM_IDS.AXIS ? 1 : -1;
        direction.rotation.z = time * 2.0 * dirSign;
      }
    }
  }
}


## FILE: apps\client-tauri\src\render\ModelFactory.ts
---------------------------
// apps/client-tauri/src/render/ModelFactory.ts
//
// Central factory for all Three.js models used by the client.
// This keeps geometry/material creation out of Renderer and makes
// it easier to evolve visuals later (LOD, different styles, etc.).

import * as THREE from 'three';
import { TEAM_COLORS } from '../core/constants';

export class ModelFactory {
  /**
   * Create the standard infantry soldier object.
   *
   * We return a THREE.Group so we can name parts (body/head) and
   * recolor the body later based on team.
   */
  public static createPlayer(): THREE.Group {
    const group = new THREE.Group();
    group.name = 'player';

    // Body
    const bodyGeom = new THREE.BoxGeometry(0.6, 1.6, 0.4);
    const bodyMat = new THREE.MeshPhongMaterial({
      color: TEAM_COLORS.NEUTRAL,
    });
    const body = new THREE.Mesh(bodyGeom, bodyMat);
    body.castShadow = true;
    body.name = 'body';
    group.add(body);

    // Head
    const headGeom = new THREE.SphereGeometry(0.3, 16, 16);
    const headMat = new THREE.MeshPhongMaterial({ color: 0xffe0bd });
    const head = new THREE.Mesh(headGeom, headMat);
    head.position.y = 1.1;
    head.castShadow = true;
    head.name = 'head';
    group.add(head);

    return group;
  }

  /**
   * Create a complete flag group:
   * - Base cylinder
   * - Pole (named "pole")
   * - Banner (Plane, named "banner")
   * - Capture ring (named "ring")
   * - Progress disc (Circle, named "progress")
   * - Capture direction arrow (Plane, named "direction")
   *
   * All color logic (team/ownership/progress) is handled in FlagVisual;
   * this factory only creates neutral-colored geometry.
   *
   * @param radius Capture radius for the ring and disc (default 8.0)
   */
  public static createFlag(radius: number = 8.0): THREE.Group {
    const group = new THREE.Group();
    group.name = 'flag';

    // A. Base
    const baseGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
    const baseMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
    const base = new THREE.Mesh(baseGeom, baseMat);
    base.castShadow = true;
    base.receiveShadow = true;
    base.name = 'base';
    group.add(base);

    // B. Pole
    const poleGeom = new THREE.CylinderGeometry(0.1, 0.1, 4, 8);
    const poleMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const pole = new THREE.Mesh(poleGeom, poleMat);
    pole.position.y = 2.2;
    pole.castShadow = true;
    pole.name = 'pole';
    group.add(pole);

    // C. Banner
    const bannerGeom = new THREE.PlaneGeometry(1.8, 1.2);
    const bannerMat = new THREE.MeshBasicMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
    });
    const banner = new THREE.Mesh(bannerGeom, bannerMat);
    banner.position.set(0.9, 2.8, 0);
    banner.rotation.y = Math.PI / 2;
    banner.name = 'banner';
    group.add(banner);

    // D. Capture radius ring
    const ringGeom = new THREE.RingGeometry(radius - 0.3, radius, 64);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.6,
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.01;
    ring.name = 'ring';
    group.add(ring);

    // E. Progress disc (fills as the point is being captured)
    const progGeom = new THREE.CircleGeometry(radius, 64);
    const progMat = new THREE.MeshBasicMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.4,
    });
    const progress = new THREE.Mesh(progGeom, progMat);
    progress.rotation.x = -Math.PI / 2;
    progress.position.y = 0.02;
    progress.scale.set(0, 0, 0); // no capture at start
    progress.name = 'progress';
    group.add(progress);

    // F. Direction arrow: shows capture direction / team color
    const arrowGeom = new THREE.PlaneGeometry(radius * 0.5, radius * 0.12);
    const arrowMat = new THREE.MeshBasicMaterial({
      color: TEAM_COLORS.NEUTRAL,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.0, // hidden until capture starts
    });
    const arrow = new THREE.Mesh(arrowGeom, arrowMat);
    arrow.position.set(radius * 0.75, 0.03, 0);
    arrow.rotation.x = -Math.PI / 2;
    arrow.name = 'direction';
    group.add(arrow);

    return group;
  }
}


## FILE: apps\client-tauri\src\systems\FlagSystem.ts
---------------------------
// apps/client-tauri/src/systems/FlagSystem.ts
//
// ECS-side management of Conquest flags on the client.
// - Ensures each server flag has a corresponding ECS entity.
// - Writes Transform + CapturePoint data from Snapshot.flags.
//
// This is functionally equivalent to the earlier FlagSync helper,
// but lives under /systems to match the modular client architecture.

import {
  Transform,
  addComponent,
  addEntity,
} from '@bf42lite/engine-core';

import { CapturePoint } from '@bf42lite/games-bf42';

import type { Snapshot } from '@bf42lite/protocol';

export class FlagSystem {
  // Map from protocol flag id â†’ ECS entity id
  private static flagMap = new Map<number, number>();

  /**
   * Ensure that a flag ECS entity exists for the given protocol flag id.
   * If it does not exist yet, create it and register components.
   */
  private static ensureFlag(world: any, id: number): number {
    const existing = FlagSystem.flagMap.get(id);
    if (existing !== undefined) {
      return existing;
    }

    const eid = addEntity(world);
    addComponent(world, CapturePoint, eid);
    addComponent(world, Transform, eid);
    FlagSystem.flagMap.set(id, eid);
    return eid;
  }

  /**
   * Apply all flags from a Snapshot into the ECS world.
   *
   * - Positions: Transform.(x,y,z)
   * - Radius: CapturePoint.radius
   * - Owner team: CapturePoint.owner (1 = TeamA, 2 = TeamB, 0 = none)
   * - Capture progress: CapturePoint.capture (server-side value)
   */
  public static applySnapshotFlags(snapshot: Snapshot, world: any): void {
    if (!snapshot.flags || snapshot.flags.length === 0) return;

    for (const f of snapshot.flags) {
      const eid = FlagSystem.ensureFlag(world, f.id);

      // Position
      Transform.x[eid] = f.x;
      Transform.y[eid] = f.y;
      Transform.z[eid] = f.z;

      // Radius (fallback to 8 if not provided)
      CapturePoint.radius[eid] = f.radius ?? 8;

      // Owner mapping: server string â†’ numeric ECS id
      CapturePoint.owner[eid] =
        f.owner === 'TeamA' ? 1 :
        f.owner === 'TeamB' ? 2 : 0;

      // Raw capture value from server (-1 â†’ 1 or similar)
      CapturePoint.capture[eid] = f.capture ?? 0;
    }
  }

  /**
   * Optional: clear all known flags (e.g. when changing maps).
   * This only clears the mapping; caller is responsible for
   * actually removing ECS entities if desired.
   */
  public static reset(): void {
    FlagSystem.flagMap.clear();
  }
}


## FILE: apps\client-tauri\src\systems\handleSnapshot.ts
---------------------------
// src/systems/handleSnapshot.ts

import type { SimWorld } from '@bf42lite/engine-core';
import type { Renderer } from '../core/Renderer';
import type { NetworkManager } from '../managers/NetworkManager';
import type { UIManager } from '../managers/UIManager';

export interface SnapshotMessage {
  type: 'snapshot';
  tick?: number;
  flags?: any[];
  game_state?: {
    team_a_tickets?: number;
    team_b_tickets?: number;
    match_ended?: boolean;
    winner_team?: number | string | null;
  } | null;
}

/**
 * HUD-only snapshot handler.
 * All ECS + entity sync is done in NetworkManager â†’ RemoteEntitySync.
 */
export function handleSnapshot(
  msg: SnapshotMessage,
  _world: SimWorld,
  _renderer: Renderer,
  _net: NetworkManager,
  ui: UIManager,
) {
  // Tickets
  const axis = msg.game_state?.team_a_tickets ?? 0;
  const allies = msg.game_state?.team_b_tickets ?? 0;
  ui.updateTickets(axis, allies);

  // Flag HUD
  ui.updateFlagsHUD(msg.flags);

  // Game over
  const st = msg.game_state;
  const ended = !!st?.match_ended;

  if (ended) {
    let title = 'DRAW';
    const winner = st?.winner_team;

    if (winner === 1 || winner === 'TeamA') title = 'AXIS VICTORY';
    else if (winner === 2 || winner === 'TeamB') title = 'ALLIES VICTORY';

    ui.setGameOver(true, title);
  } else {
    ui.setGameOver(false, '');
  }
}


## FILE: apps\client-tauri\src\systems\InterpolationSystem.ts
---------------------------
// apps/client-tauri/src/systems/InterpolationSystem.ts

import {
  Transform,
  Velocity,
} from '@bf42lite/engine-core';

import type { NetworkManager } from '../managers/NetworkManager';

/**
 * InterpolationSystem pulls historical remote-player snapshots stored
 * in NetworkManager and smooths them into predicted ECS Transform data.
 *
 * This isolates interpolation behavior from NetworkManager.
 */
export class InterpolationSystem {
  private readonly net: NetworkManager;

  constructor(net: NetworkManager) {
    this.net = net;
  }

  /**
   * Apply interpolation to all remote entities based on interpolationTimeMs.
   *
   * @param world                ECS world
   * @param interpolationTimeMs  Target timestamp to sample state from
   */
  public update(world: any, interpolationTimeMs: number): void {
    const remoteStates = this.net.getRemoteHistory(interpolationTimeMs);
    // Expected format: array of { eid, pos:{x,y,z}, rot, vx, vy, vz }

    for (const state of remoteStates) {
      const eid = state.eid;

      // Set position directly (remote players only)
      Transform.x[eid] = state.pos.x;
      Transform.y[eid] = state.pos.y;
      Transform.z[eid] = state.pos.z;

      // Rotation smoothing
      Transform.rotation[eid] = state.rot;

      // Optional velocity smoothing
      if (Velocity.x && Velocity.y && Velocity.z) {
        Velocity.x[eid] = state.vx ?? 0;
        Velocity.y[eid] = state.vy ?? 0;
        Velocity.z[eid] = state.vz ?? 0;
      }
    }
  }
}


## FILE: apps\client-tauri\src\systems\MovementSystem.ts
---------------------------
// apps/client-tauri/src/systems/MovementSystem.ts
//
// Thin wrapper around the core movement system from @bf42lite/engine-core.
// This gives the client its own named MovementSystem module, while still
// using exactly the same underlying ECS movement logic as the server.

import {
  createMovementSystem,
  type SimWorld,
  type System,
} from '@bf42lite/engine-core';

// Alias for clarity in the client layer
export type MovementSystem = System;

/**
 * Create the client movement system.
 *
 * Under the hood this is the same createMovementSystem() that the
 * engine uses for the simulation pipeline.
 */
export function createClientMovementSystem(): MovementSystem {
  return createMovementSystem();
}

/**
 * Optional helper if you prefer an object-style API.
 * Not required for your existing code; provided for future use.
 */
export class MovementSystemRunner {
  private readonly system: MovementSystem;

  constructor() {
    this.system = createMovementSystem();
  }

  /**
   * Step movement once for the given world.
   */
  public update(world: SimWorld): void {
    this.system(world);
  }
}


## FILE: apps\client-tauri\src\systems\PredictionSystem.ts
---------------------------
// apps/client-tauri/src/systems/PredictionSystem.ts
//
// Encapsulates client-side movement prediction:
//
// - Reads input for the current tick
// - Writes InputState for the local entity
// - Runs the movement system (local prediction)
// - Pushes the predicted state into Reconciler history
// - Returns the ClientInput so caller can send it to the server

import { Transform, type SimWorld } from '@bf42lite/engine-core';
import type { ClientInput } from '@bf42lite/protocol';

import type { InputManager } from '../core/InputManager';
import type { Reconciler } from './Reconciler';
import { updateGameFrame } from './updateGameFrame';

export class PredictionSystem {
  private world: SimWorld;
  private input: InputManager;
  private movementSystem: (world: SimWorld) => void;
  private reconciler: Reconciler;
  private getLocalEntityId: () => number;

  /**
   * @param world           ECS world used by the simulation.
   * @param input           Input manager providing per-tick commands.
   * @param movementSystem  Movement system function (e.g. createMovementSystem()).
   * @param reconciler      Reconciler used to store prediction history.
   * @param getLocalEntityId Function returning the current local player entity id.
   */
  constructor(
    world: SimWorld,
    input: InputManager,
    movementSystem: (world: SimWorld) => void,
    reconciler: Reconciler,
    getLocalEntityId: () => number,
  ) {
    this.world = world;
    this.input = input;
    this.movementSystem = movementSystem;
    this.reconciler = reconciler;
    this.getLocalEntityId = getLocalEntityId;
  }

  /**
   * Run one prediction step.
   *
   * - Applies local input to InputState
   * - Steps the movement system
   * - Records the predicted position into Reconciler history
   *
   * Returns the ClientInput so the caller can send it over the network.
   */
  public update(dt: number, tick: number): ClientInput | null {
    const localEntityId = this.getLocalEntityId();

    // 1) Per-frame input + movement prediction
    const cmd = updateGameFrame(
      dt,
      tick,
      localEntityId,
      this.world,
      this.input,
      this.movementSystem,
    ) as ClientInput | null;

    // 2) Store prediction history for reconciliation
    if (localEntityId >= 0 && cmd) {
      this.reconciler.pushHistory(
        tick,
        cmd,
        Transform.x[localEntityId],
        Transform.y[localEntityId],
        Transform.z[localEntityId],
      );
    }

    return cmd;
  }
}


## FILE: apps\client-tauri\src\systems\Reconciler.ts
---------------------------
// apps/client-tauri/src/systems/Reconciler.ts

import { Transform, Velocity, SimWorld } from '@bf42lite/engine-core';
import { ClientInput, EntityState } from '@bf42lite/protocol';
import type { InterpolationBuffer } from '../network/types';
import { log } from '../utils/log';

export interface InputHistory {
  tick: number;
  input: ClientInput;
  pos: { x: number; y: number; z: number };
  timestamp: number;
}

/**
 * Client-side reconciler for predicted movement.
 * Stores a small history of client inputs and positions and compares them
 * to authoritative server snapshots to correct drift.
 */
export class Reconciler {
  private history: InputHistory[] = [];

  // Interpolation buffers for remote entities (used by interpolation.ts)
  public remoteBuffers: Map<number, InterpolationBuffer> = new Map();

  // Normal correction threshold (â‰ˆ1m).
  private readonly ERROR_THRESHOLD_SQ = 1.0;

  // Teleport/spawn threshold (â‰ˆ10m).
  private readonly TELEPORT_THRESHOLD_SQ = 100.0;

  /**
   * Record the current predicted state.
   *
   * Call this once per local simulation step, after applying inputs.
   */
  public pushHistory(
    tick: number,
    input: ClientInput,
    x: number,
    y: number,
    z: number,
  ) {
    this.history.push({
      tick,
      input,
      pos: { x, y, z },
      timestamp: performance.now(),
    });
  }

  public clearHistory() {
    this.history.length = 0;
  }

  /**
   * Compare a server snapshot to the local history and correct if needed.
   *
   * Returns an RTT estimate in milliseconds based on the stored timestamp,
   * or 0 if no matching history was found.
   */
  public reconcile(
    serverTick: number,
    serverState: EntityState,
    eid: number,
    world: SimWorld,
    movementSystem: (w: SimWorld) => void,
  ): number {
    if (!serverState.pos || this.history.length === 0) {
      return 0;
    }

    // 1. Prefer exact history match for this tick.
    let historyIndex = this.history.findIndex(
      (h) => h.tick === serverTick,
    );

    // 2. If no exact match, fall back to closest tick we have.
    if (historyIndex === -1) {
      log.warn('RECON', 'No history for server tick', {
        serverTick,
        historySize: this.history.length,
      });

      let closestIndex = -1;
      let closestDiff = Number.POSITIVE_INFINITY;

      for (let i = 0; i < this.history.length; i++) {
        const diff = Math.abs(this.history[i].tick - serverTick);
        if (diff < closestDiff) {
          closestDiff = diff;
          closestIndex = i;
        }
      }

      if (closestIndex === -1) {
        return 0;
      }

      historyIndex = closestIndex;

      const picked = this.history[historyIndex];
      log.debug('RECON', 'Using closest history tick', {
        serverTick,
        pickedTick: picked.tick,
        delta: closestDiff,
      });
    }

    const historyState = this.history[historyIndex];

    // RTT is time since we originally simulated that tick.
    const rtt = Math.round(
      performance.now() - historyState.timestamp,
    );

    // 3. Compute spatial error between predicted and authoritative positions.
    const dx = historyState.pos.x - serverState.pos.x;
    const dy = historyState.pos.y - serverState.pos.y;
    const dz = historyState.pos.z - serverState.pos.z;
    const distSq = dx * dx + dy * dy + dz * dz;

    // 4. Teleport: error is massive, probably a respawn or big correction.
    if (distSq > this.TELEPORT_THRESHOLD_SQ) {
      log.warn('RECON', 'Teleport correction', {
        serverTick,
        eid,
        distSq: Number(distSq.toFixed(2)),
      });

      Transform.x[eid] = serverState.pos.x;
      Transform.y[eid] = serverState.pos.y;
      Transform.z[eid] = serverState.pos.z;

      if (serverState.vel) {
        Velocity.x[eid] = serverState.vel.x;
        Velocity.y[eid] = serverState.vel.y;
        Velocity.z[eid] = serverState.vel.z;
      }

      this.clearHistory();
      return rtt;
    }

    // 5. Normal correction: small but noticeable mismatch.
    if (distSq > this.ERROR_THRESHOLD_SQ) {
      log.warn('RECON', 'Soft correction', {
        serverTick,
        eid,
        distSq: Number(distSq.toFixed(2)),
        clientPos: {
          x: Number(historyState.pos.x.toFixed(2)),
          y: Number(historyState.pos.y.toFixed(2)),
          z: Number(historyState.pos.z.toFixed(2)),
        },
        serverPos: {
          x: Number(serverState.pos.x.toFixed(2)),
          y: Number(serverState.pos.y.toFixed(2)),
          z: Number(serverState.pos.z.toFixed(2)),
        },
      });

      // For now we fully trust the server.
      Transform.x[eid] = serverState.pos.x;
      Transform.y[eid] = serverState.pos.y;
      Transform.z[eid] = serverState.pos.z;

      if (serverState.vel) {
        Velocity.x[eid] = serverState.vel.x;
        Velocity.y[eid] = serverState.vel.y;
        Velocity.z[eid] = serverState.vel.z;
      }

      // Drop history up to and including the corrected tick.
      this.history.splice(0, historyIndex + 1);
      return rtt;
    }

    // 6. No correction needed: server and client agree closely enough.
    this.history.splice(0, historyIndex + 1);

    log.trace('RECON', 'No correction needed', {
      serverTick,
      eid,
      distSq: Number(distSq.toFixed(3)),
    });

    return rtt;
  }
}


## FILE: apps\client-tauri\src\systems\SnapshotHandler.ts
---------------------------
// apps/client-tauri/src/systems/SnapshotHandler.ts
//
// Unified handler for processing server snapshots.
// This wraps handleSnapshot(...) and returns structured results
// so ClientGame remains thin and easy to maintain.

import type { Snapshot, FlagSnapshot } from '@bf42lite/protocol';

import { handleSnapshot } from './handleSnapshot';
import type { Renderer } from '../core/Renderer';
import type { NetworkManager } from '../managers/NetworkManager';
import type { UIManager } from '../managers/UIManager';

export interface SnapshotResult {
  flags: FlagSnapshot[];
  ticketsAxis: number;
  ticketsAllies: number;
  gameOver: boolean;
  winner?: string;
}

export class SnapshotHandler {
  private world: any;
  private renderer: Renderer;
  private net: NetworkManager;
  private ui: UIManager;

  constructor(
    world: any,
    renderer: Renderer,
    net: NetworkManager,
    ui: UIManager
  ) {
    this.world = world;
    this.renderer = renderer;
    this.net = net;
    this.ui = ui;
  }

  /**
   * Process the snapshot sent by the server.
   *
   * Returns a result object used by ClientGame.
   */
  public process(msg: Snapshot): SnapshotResult {
    // This function applies:
    // - Entity updates
    // - Health updates
    // - Team changes
    // - Flag capture state
    // - Killfeed / hit markers
    // - Ticket counts
    // - GameOver state
    handleSnapshot(msg, this.world, this.renderer, this.net, this.ui);

    const flags = (msg.flags ?? []) as FlagSnapshot[];

    return {
      flags,
      ticketsAxis: msg.tickets?.axis ?? 0,
      ticketsAllies: msg.tickets?.allies ?? 0,
      gameOver: msg.gameOver?.active ?? false,
      winner: msg.gameOver?.winner ?? undefined,
    };
  }
}


## FILE: apps\client-tauri\src\systems\syncLocalPlayer.ts
---------------------------
// apps/client-tauri/src/systems/syncLocalPlayer.ts

import {
    Transform,
  } from '@bf42lite/engine-core';
  import {
    Health,
    Team,
    Loadout,
  } from '@bf42lite/games-bf42';
  
  import type { Snapshot } from '@bf42lite/protocol';
  import type { NetworkManager } from '../managers/NetworkManager';
  import type { UIManager } from '../managers/UIManager';
  import type { Reconciler } from './Reconciler';
  
  import { TEAM_IDS, WEAPON_NAMES } from '../core/constants';
  
  /**
   * Synchronize the local player ECS state + UI from a server Snapshot.
   *
   * Returns the updated last RTT (or the previous one if unchanged).
   */
  export function syncLocalPlayerFromSnapshot(
    msg: Snapshot,
    simWorld: any,
    localEntityId: number,
    net: NetworkManager,
    ui: UIManager,
    reconciler: Reconciler,
    movementSystem: any,
    lastRtt: number,
  ): number {
    // Find the server entity that corresponds to our local ECS entity
    const myServerEntity = msg.entities?.find(
      (e: any) => net.getLocalId(e.id) === localEntityId,
    );
  
    if (!myServerEntity) {
      return lastRtt;
    }
  
    const wasDead = Health.isDead[localEntityId] === 1;
    const isNowDead = !!myServerEntity.isDead;
  
    // Teleport on respawn to avoid smoothing artifacts
    if (wasDead && !isNowDead && myServerEntity.pos) {
      reconciler.clearHistory();
      Transform.x[localEntityId] = myServerEntity.pos.x;
      Transform.y[localEntityId] = myServerEntity.pos.y;
      Transform.z[localEntityId] = myServerEntity.pos.z;
    }
  
    // Health + death state (protocol sends health as a number)
    const hp =
      typeof myServerEntity.health === 'number'
        ? myServerEntity.health
        : 100;
  
    Health.current[localEntityId] = hp;
    Health.isDead[localEntityId] = isNowDead ? 1 : 0;
    ui.updateRespawn(isNowDead, myServerEntity.respawnTimer || 0);
  
    // Team mapping (Rust TeamId â†’ numeric ECS team)
    if (myServerEntity.team) {
      const protoId = myServerEntity.team.id;
      if (protoId === 'TeamA') {
        Team.id[localEntityId] = TEAM_IDS.AXIS;
      } else if (protoId === 'TeamB') {
        Team.id[localEntityId] = TEAM_IDS.ALLIES;
      } else {
        Team.id[localEntityId] = TEAM_IDS.NONE;
      }
    }
  
    // Loadout / class
    if (myServerEntity.loadout) {
      Loadout.classId[localEntityId] =
        myServerEntity.loadout.classId ?? 0;
    }
  
    // Ammo + weapon UI
    const myClassId = Loadout.classId[localEntityId] || 0;
    const weaponName = WEAPON_NAMES[myClassId] ?? 'THOMPSON';
  
    if (myServerEntity.ammo) {
      ui.updateAmmo(
        myServerEntity.ammo.current,
        myServerEntity.ammo.reserve,
        weaponName,
      );
    }
  
    // Reconciliation (movement correction)
    let newLastRtt = lastRtt;
    if (myServerEntity.lastProcessedTick !== undefined) {
      const rtt = reconciler.reconcile(
        myServerEntity.lastProcessedTick,
        myServerEntity,
        localEntityId,
        simWorld,
        movementSystem,
      );
      if (rtt > 0) newLastRtt = rtt;
    }
  
    return newLastRtt;
  }
  

## FILE: apps\client-tauri\src\systems\updateGameFrame.ts
---------------------------
// src/systems/updateGameFrame.ts

import { InputState, type SimWorld } from '@bf42lite/engine-core';
import type { InputManager } from '../core/InputManager';

/**
 * One per-frame client update:
 * - Read input
 * - Write into InputState for the local entity
 * - Run the movement system
 * - Return the input command so the caller can push history / send to server
 */
export function updateGameFrame(
  dt: number,
  currentTick: number,
  localEntityId: number,
  simWorld: SimWorld,
  input: InputManager,
  movementSystem: (world: SimWorld) => void,
) {
  // 1. Read input for this tick
  const cmd = input.getCommand(currentTick);

  // 2. Write into ECS input components for the local entity
  if (localEntityId >= 0) {
    InputState.moveY[localEntityId] = cmd.axes.forward;
    InputState.moveX[localEntityId] = cmd.axes.right;
    InputState.viewX[localEntityId] = cmd.axes.yaw;
    InputState.viewY[localEntityId] = cmd.axes.pitch;

    // Button bitmask:
    // bit 0: jump
    // bit 1: shoot  (used by WeaponSystem via InputState.buttons & 2)
    // bit 2: reload
    let buttons = 0;
    if (cmd.axes.jump)   buttons |= 1;
    if (cmd.axes.shoot)  buttons |= 2;
    if (cmd.axes.reload) buttons |= 4;

    InputState.buttons[localEntityId] = buttons;
  }

  // 3. Run movement (local prediction)
  movementSystem(simWorld);

  // 4. Hand the command back to ClientGame
  return cmd;
}


## FILE: apps\client-tauri\src\ui\HUDUpdater.ts
---------------------------
// apps/client-tauri/src/ui/HUDUpdater.ts
//
// Centralized helper for updating HUD elements.
// The goal is to gradually move direct UIManager calls here so that
// snapshot handlers, systems, and ClientGame do not talk to the DOM/UI
// directly, only to this faÃ§ade.

import type { UIManager } from '../managers/UIManager';
import type { Snapshot } from '@bf42lite/protocol';

export class HUDUpdater {
  private ui: UIManager;

  constructor(ui: UIManager) {
    this.ui = ui;
  }

  /**
   * Update FPS + RTT stats in the HUD.
   */
  public updateStats(fps: number, rttMs: number): void {
    this.ui.updateStats(fps, rttMs);
  }

  /**
   * Update local player's health in the HUD.
   */
  public updateHealth(health: number): void {
    this.ui.updateHealth(health);
  }

  /**
   * Update respawn timer and death state in the HUD.
   */
  public updateRespawn(isDead: boolean, respawnTimerSec: number): void {
    this.ui.updateRespawn(isDead, respawnTimerSec);
  }

  /**
   * Update ammo + weapon name in the HUD.
   */
  public updateAmmo(current: number, reserve: number, weaponName: string): void {
    this.ui.updateAmmo(current, reserve, weaponName);
  }

  /**
   * Update hit marker feedback (damage done).
   */
  public showHitMarker(damage: number): void {
    this.ui.showHitMarker(damage);
  }

  /**
   * Apply HUD-related parts of a snapshot (tickets, game over, flag HUD, etc.).
   * This is a faÃ§ade over the more detailed logic currently inside handleSnapshot.
   */
  public applySnapshotHUD(msg: Snapshot): void {
    // Tickets (if present)
    if (msg.game_state && msg.game_state.tickets) {
      const tickets = msg.game_state.tickets;
      this.ui.updateTickets(tickets.axis ?? 0, tickets.allies ?? 0);
    }

    // Game over state (if present)
    if (msg.game_state && msg.game_state.game_over) {
      const over = msg.game_state.game_over;
      this.ui.showGameOver(over.winnerTeamId ?? null, over.reason ?? '');
    }

    // Flag HUD (if you expose it in UIManager)
    if (msg.flags && msg.flags.length > 0 && this.ui.updateFlagHud) {
      // Minimal example: pass raw flags; UIManager remains responsible
      this.ui.updateFlagHud(msg.flags);
    }
  }
}


## FILE: apps\client-tauri\src\utils\log.ts
---------------------------
// src/utils/log.ts

type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'trace';

interface LogConfig {
    level: LogLevel;
    enabledTags: Set<string>;
}

const LEVEL_ORDER: Record<LogLevel, number> = {
    error: 0,
    warn: 1,
    info: 2,
    debug: 3,
    trace: 4,
};

// Default config â€” switch here for "debug build"
const config: LogConfig = {
    level: 'info', // show: error, warn, info
    enabledTags: new Set(['NET', 'CONQUEST', 'SIM', 'RENDER', 'RECON']),
};

function shouldLog(level: LogLevel, tag: string): boolean {
    if (LEVEL_ORDER[level] > LEVEL_ORDER[config.level]) return false;
    if (!config.enabledTags.has(tag)) return false;
    return true;
}

export const log = {
    setLevel(level: LogLevel): void {
        config.level = level;
    },

    enable(tag: string): void {
        config.enabledTags.add(tag);
    },

    disable(tag: string): void {
        config.enabledTags.delete(tag);
    },

    error(tag: string, msg: string, data?: any): void {
        if (shouldLog('error', tag)) console.error(`[ERROR][${tag}] ${msg}`, data ?? '');
    },

    warn(tag: string, msg: string, data?: any): void {
        if (shouldLog('warn', tag)) console.warn(`[WARN][${tag}] ${msg}`, data ?? '');
    },

    info(tag: string, msg: string, data?: any): void {
        if (shouldLog('info', tag)) console.info(`[INFO][${tag}] ${msg}`, data ?? '');
    },

    debug(tag: string, msg: string, data?: any): void {
        if (shouldLog('debug', tag)) console.debug(`[DEBUG][${tag}] ${msg}`, data ?? '');
    },

    trace(tag: string, msg: string, data?: any): void {
        if (shouldLog('trace', tag)) console.log(`[TRACE][${tag}] ${msg}`, data ?? '');
    },
};


## FILE: apps\client-tauri\src\world\worldRender.ts
---------------------------
// apps/client-tauri/src/world/worldRender.ts

import {
    defineQuery,
    Transform,
    InputState,
  } from '@bf42lite/engine-core';
  import { Soldier, CapturePoint, Team, Health } from '@bf42lite/games-bf42';
  
  import type { Renderer } from '../core/Renderer';
  import type { UIManager } from '../managers/UIManager';
  
  // ECS queries for players and flags
  const playerQuery = defineQuery([Transform, Soldier]);
  const flagQuery = defineQuery([CapturePoint, Transform]);
  
  /**
   * Single place responsible for:
   * - Updating HUD stats from ECS
   * - Rendering players and flags via Renderer
   */
  export function updateWorldRender(
    world: any,
    renderer: Renderer,
    ui: UIManager,
    localEntityId: number,
    currentFps: number,
    lastRtt: number,
  ) {
    // UI stats + health
    ui.updateStats(currentFps, lastRtt);
    if (localEntityId >= 0) {
      ui.updateHealth(Health.current[localEntityId]);
    }
  
    // Render players
    const players = playerQuery(world);
    for (const eid of players) {
      const isMe = eid === localEntityId;
  
      const state = {
        type: 'player' as const,
        pos: {
          x: Transform.x[eid],
          y: Transform.y[eid],
          z: Transform.z[eid],
        },
        rot: Transform.rotation[eid],
        pitch: isMe ? InputState.viewY[eid] : 0,
        team: Team.id[eid],
      };
  
      renderer.updateEntity(eid, state, isMe);
    }
  
    // Render flags (capture points)
    const flags = flagQuery(world);
    for (const eid of flags) {
        const raw = CapturePoint.progress[eid] || 0;
        const progress = Math.min(1, Math.abs(raw / 100));
        
        const state = {
          type: 'flag' as const,
          pos: {
            x: Transform.x[eid],
            y: Transform.y[eid],
            z: Transform.z[eid],
          },
          team: CapturePoint.team[eid],    // existing schema
          progress,
        };
        
  
      renderer.updateEntity(eid, state, false);
    }
  
    // Final frame
    renderer.render();
  }
  

